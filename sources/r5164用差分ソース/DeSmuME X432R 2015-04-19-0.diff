Index: GPU.cpp
===================================================================
--- GPU.cpp	(revision 5164)
+++ GPU.cpp	(working copy)
@@ -603,11 +603,16 @@
 			final = cfinal.val;
 		}
 		else final = R6G6B6TORGB15(red,green,blue);
+		
+		#ifdef X432R_CUSTOMRENDERER_ENABLED
+		X432R::backBuffer.SetFinalColor<X432R::SOURCELAYER_3D, X432R::BLENDMODE_ENABLED>(dstX, srcX, final, 0, 0, 0);
+		#endif
 	}
 	else
 	{
 		final = R6G6B6TORGB15(red,green,blue);
 		//perform the special effect
+		#ifndef X432R_CUSTOMRENDERER_ENABLED
 		if(windowEffect)
 			switch(FUNC) {
 				case Increase: final = currentFadeInColors[final&0x7FFF]; break;
@@ -616,7 +621,35 @@
 				case Blend:
 					break;
 			}
+		#else
+		switch(FUNC)
+		{
+			case Increase:
+				if( !windowEffect || (BLDY_EVY == 0) ) goto noblend;
+				
+				final = currentFadeInColors[final&0x7FFF];
+				
+				X432R::backBuffer.SetFinalColor<X432R::SOURCELAYER_3D, X432R::BLENDMODE_BRIGHTUP>(dstX, srcX, final, 0, 0, 0);
+				break;
+				
+			case Decrease:
+				if( !windowEffect || (BLDY_EVY == 0) ) goto noblend;
+				
+				final = currentFadeOutColors[final&0x7FFF];
+				
+				X432R::backBuffer.SetFinalColor<X432R::SOURCELAYER_3D, X432R::BLENDMODE_BRIGHTDOWN>(dstX, srcX, final, 0, 0, 0);
+				break;
+				
+//			case NoBlend:
+//			case Blend:
+			default:
+				noblend:
+				
+				X432R::backBuffer.SetFinalColor<X432R::SOURCELAYER_3D, X432R::BLENDMODE_DISABLED>(dstX, srcX, 0, 0, 0, 0);
+				break;
 	}
+		#endif
+	}
 
 	HostWriteWord(dst, passing, (final | 0x8000));
 	bgPixels[x] = 0;
@@ -634,6 +667,7 @@
 
 	bool windowEffect = true;
 
+	#ifndef X432R_CUSTOMRENDERER_ENABLED
 	if(WINDOW)
 	{
 		bool windowDraw = false;
@@ -660,6 +694,61 @@
 		case NoBlend: break;
 	}
 	return true;
+	#else
+	if(BACKDROP) return false;
+	
+	if(WINDOW)	//backdrop must always be drawn
+	{
+		bool windowDraw = false;
+		renderline_checkWindows(x, windowDraw, windowEffect);
+		
+		//we never have anything more to do if the window rejected us
+		if( !windowDraw ) return false;
+	}
+	
+	const u8 bg_under = bgPixels[x];
+	const u16 backcolor = HostReadWord(currDst, x << 1);
+	const u16 original_color = color;
+	
+	//special effects rejected. just draw it.
+	if(blend1 && windowEffect)
+	{
+		//perform the special effect
+		switch(FUNC)
+		{
+			case Blend:
+				if(BLDALPHA_EVA == 0) return false;
+				if( !blend2[bg_under] ) break;
+				
+				color = blend(color, backcolor);
+				
+				X432R::backBuffer.SetFinalColor<X432R::SOURCELAYER_BG, X432R::BLENDMODE_ENABLED>(x, 0, color, original_color, 0, currBgNum);
+				return true;
+			
+			case Increase:
+				if(BLDY_EVY == 0) break;
+				
+				color = currentFadeInColors[color];
+				
+				X432R::backBuffer.SetFinalColor<X432R::SOURCELAYER_BG, X432R::BLENDMODE_BRIGHTUP>(x, 0, color, 0, 0, currBgNum);
+				return true;
+			
+			case Decrease:
+				if(BLDY_EVY == 0) break;
+				
+				color = currentFadeOutColors[color];
+				
+				X432R::backBuffer.SetFinalColor<X432R::SOURCELAYER_BG, X432R::BLENDMODE_BRIGHTDOWN>(x, 0, color, 0, 0, currBgNum);
+				return true;
+			
+			case NoBlend:
+				break;
+		}
+	}
+	
+	X432R::backBuffer.SetFinalColor<X432R::SOURCELAYER_BG, X432R::BLENDMODE_DISABLED>(x, 0, color, 0, 0, currBgNum);
+	return true;
+	#endif
 }
 
 template<BlendFunc FUNC, bool WINDOW>
@@ -677,6 +766,10 @@
 			return;
 	}
 
+	#ifdef X432R_CUSTOMRENDERER_ENABLED
+	const u16 backcolor = HostReadWord(dst, x << 1);
+	#endif
+
 	//if the window effect is satisfied, then we can do color effects to modify the color
 	if(windowEffectSatisfied)
 	{
@@ -714,6 +807,7 @@
 		}
 
 	
+		#ifndef X432R_CUSTOMRENDERER_ENABLED
 		switch(selectedFunc) 
 		{
 		case NoBlend: break;
@@ -724,10 +818,52 @@
 			color = _blend(color,backColor,&gpuBlendTable555[eva][evb]); 
 			break;
 		}
+		#else
+		const u16 original_color = color;
+		
+		switch(selectedFunc)
+		{
+			case Increase:
+				if(gpu->BLDY_EVY == 0) break;
+				
+				color = gpu->currentFadeInColors[color&0x7FFF];
+				
+				X432R::backBuffer.SetFinalColor<X432R::SOURCELAYER_OBJ, X432R::BLENDMODE_BRIGHTUP>(x, 0, color, 0, 0, 4);
+				goto finish;
+			
+			case Decrease:
+				if(gpu->BLDY_EVY == 0) break;
+				
+				color = gpu->currentFadeOutColors[color&0x7FFF];
+				
+				X432R::backBuffer.SetFinalColor<X432R::SOURCELAYER_OBJ, X432R::BLENDMODE_BRIGHTUP>(x, 0, color, 0, 0, 4);
+				goto finish;
+			
+			case Blend:
+				if(eva == 0) return;
+				
+				color = _blend( color, backcolor, &gpuBlendTable555[eva][evb] );
+				
+				if(alpha < 255)
+					alpha = std::min<u8>(alpha, X432R::BLENDALPHA_MAX);
+				
+				X432R::backBuffer.SetFinalColor<X432R::SOURCELAYER_OBJ, X432R::BLENDMODE_ENABLED>(x, 0, color, original_color, alpha, 4);
+				goto finish;
+			
+			case NoBlend:
+				break;
 	}
+		#endif
+	}
 
+	#ifdef X432R_CUSTOMRENDERER_ENABLED
+	X432R::backBuffer.SetFinalColor<X432R::SOURCELAYER_OBJ, X432R::BLENDMODE_DISABLED>(x, 0, color, 0, 0, 4);
+	
+	finish:
+	#endif
+	
 	HostWriteWord(dst, x<<1, (color | 0x8000));
-	gpu->bgPixels[x] = 4;	
+	gpu->bgPixels[x] = 4;
 }
 
 //FUNCNUM is only set for backdrop, for an optimization of looking it up early
@@ -1901,6 +2037,10 @@
 
 	disp_fifo.head = disp_fifo.tail = 0;
 	osd->clear();
+	
+	#ifdef X432R_CUSTOMRENDERER_ENABLED
+	X432R::ClearBuffers();
+	#endif
 }
 
 void Screen_DeInit(void)
@@ -1982,6 +2122,7 @@
 
 	u16 backdrop_color = T1ReadWord(MMU.ARM9_VMEM, gpu->core * 0x400) & 0x7FFF;
 
+	#ifndef X432R_CUSTOMRENDERER_ENABLED
 	//we need to write backdrop colors in the same way as we do BG pixels in order to do correct window processing
 	//this is currently eating up 2fps or so. it is a reasonable candidate for optimization. 
 	gpu->currBgNum = 5;
@@ -2012,7 +2153,35 @@
 		case 6: for(int x=0;x<256;x++) gpu->___setFinalColorBck<false,true,6>(backdrop_color,x,1); break;
 		case 7: for(int x=0;x<256;x++) gpu->___setFinalColorBck<false,true,7>(backdrop_color,x,1); break;
 	}
+	#else
+	//we need to write backdrop colors in the same way as we do BG pixels in order to do correct window processing
+	//this is currently eating up 2fps or so. it is a reasonable candidate for optimization. 
+	gpu->currBgNum = 5;
 	
+	u16 backdrop_color2 = backdrop_color;
+	
+	if(gpu->BLDCNT & 0x20)		//backdrop is selected for color effect
+	{
+		switch(gpu->setFinalColorBck_funcNum)
+		{
+			//for backdrops, fade in and fade out can be applied if it's a 1st target screen
+			case 2:
+			case 6:
+				backdrop_color2 = gpu->currentFadeInColors[backdrop_color];
+				break;
+		
+			case 3:
+			case 7:
+				backdrop_color2 = gpu->currentFadeOutColors[backdrop_color];
+				break;
+		}
+	}
+	
+	memset_u16_le<256>(gpu->currDst, backdrop_color2);
+	
+	X432R::backBuffer.SetBackdropColor(backdrop_color2);
+	#endif
+	
 	memset(gpu->bgPixels,5,256);
 
 	// init background color & priorities
@@ -2244,8 +2413,31 @@
 							case 1:
 								//capture dispfifo
 								//(not yet tested)
+								#ifndef X432R_DISPCAPTURE_MAINMEMORYFIFO_TEST
 								for(int i=0; i < 128; i++)
 									T1WriteLong(cap_dst, i << 2, DISP_FIFOrecv());
+								#else
+								if( X432R::backBuffer.IsHighResolutionRenderingSkipped() )
+								{
+									for(u32 i = 0; i < 128; ++i)
+										T1WriteLong( cap_dst, i << 2, DISP_FIFOrecv() );
+								}
+								else
+								{
+									u32 *fifo_buffer = X432R::backBuffer.GetCurrentMainMemoryFIFOBuffer();
+									u32 color;
+									
+									for(u32 i = 0; i < 128; ++i)
+									{
+										color = DISP_FIFOrecv();
+										
+										T1WriteLong(cap_dst, i << 2, color);
+										
+										*fifo_buffer++ = (u32)RGB15TO24_REVERSE(color >> 16) | 0xFF000000;			// not tested
+										*fifo_buffer++ = (u32)RGB15TO24_REVERSE(color & 0x0000FFFF) | 0xFF000000;
+									}
+								}
+								#endif
 								break;
 						}
 					}
@@ -2274,9 +2466,32 @@
 						{
 							//fifo - tested by splinter cell chaos theory thermal view
 							srcB = fifoLine;
+							#ifndef X432R_DISPCAPTURE_MAINMEMORYFIFO_TEST
 							for (int i=0; i < 128; i++)
 								T1WriteLong((u8*)srcB, i << 2, DISP_FIFOrecv());
+							#else
+							if( X432R::backBuffer.IsHighResolutionRenderingSkipped() )
+							{
+								for(u32 i = 0; i < 128; ++i)
+									T1WriteLong( (u8*)srcB, i << 2, DISP_FIFOrecv() );
 						}
+							else
+							{
+								u32 *fifo_buffer = X432R::backBuffer.GetCurrentMainMemoryFIFOBuffer();
+								u32 color;
+								
+								for(u32 i = 0; i < 128; ++i)
+								{
+									color = DISP_FIFOrecv();
+									
+									T1WriteLong( (u8*)srcB, i << 2, color );
+									
+									*fifo_buffer++ = (u32)RGB15TO24_REVERSE(color >> 16) | 0xFF000000;			// not tested
+									*fifo_buffer++ = (u32)RGB15TO24_REVERSE(color & 0x0000FFFF) | 0xFF000000;
+								}
+							}
+							#endif
+						}
 
 
 						const int todo = (gpu->dispCapCnt.capx==DISPCAPCNT::_128?128:256);
@@ -2525,7 +2740,19 @@
 	}
 
 	// skip some work if master brightness makes the screen completely white or completely black
+	#ifndef X432R_CUSTOMRENDERER_ENABLED
 	if(gpu->MasterBrightFactor >= 16 && (gpu->MasterBrightMode == 1 || gpu->MasterBrightMode == 2))
+	#else
+	X432R::backBuffer.UpdateRenderLineParams(screen, l);
+	
+	const bool is_lowreso_screen = X432R::backBuffer.IsHighResolutionRenderingSkipped();
+	
+	if( !is_lowreso_screen && (gpu->BLDY_EVY <= 2) )
+		gpu->BLDY_EVY = 0;		// temp, 稀にフェード効果の後にBLDY_EVYが0にリセットされていない場合があるので2以下を無視（再現度は低下する）
+	
+//	if( X432R::backBuffer.IsHighResolutionRenderingDisabled() && (gpu->MasterBrightFactor >= 16) && ( (gpu->MasterBrightMode == 1) || (gpu->MasterBrightMode == 2) ) )
+	if( is_lowreso_screen && (gpu->MasterBrightFactor >= 16) && ( (gpu->MasterBrightMode == 1) || (gpu->MasterBrightMode == 2) ) )
+	#endif
 	{
 		// except if it could cause any side effects (for example if we're capturing), then don't skip anything
 		if(!(gpu->core == GPU_MAIN && (gpu->dispCapCnt.enabled || l == 0 || l == 191)))
@@ -2536,6 +2763,10 @@
 		}
 	}
 
+	#ifdef X432R_PROCESSTIME_CHECK
+	X432R::AutoStopTimeCounter timecounter(X432R::timeCounter_2D);
+	#endif
+
 	//cache some parameters which are assumed to be stable throughout the rendering of the entire line
 	gpu->currLine = l;
 	u16 mosaic_control = T1ReadWord((u8 *)&gpu->dispx_st->dispx_MISC.MOSAIC, 0);
@@ -2618,7 +2849,13 @@
 	}
 
 
+	#ifndef X432R_CUSTOMRENDERER_ENABLED
 	GPU_RenderLine_MasterBrightness(screen, l);
+	#else
+//	if( X432R::backBuffer.IsHighResolutionRenderingDisabled() )
+	if(is_lowreso_screen)
+		GPU_RenderLine_MasterBrightness(screen, l);
+	#endif
 }
 
 void gpu_savestate(EMUFILE* os)
@@ -2758,3 +2995,1652 @@
 {
 	gpu_angle = angle;
 }
+
+
+#ifdef X432R_CUSTOMRENDERER_ENABLED
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1700)
+#ifdef X432R_PPL_TEST
+#include <ppl.h>
+#elif defined(X432R_CPP_AMP_TEST)
+#include <amp.h>
+#endif
+#endif
+
+namespace X432R
+{
+	//---------- RGBA8888 ----------
+	
+	u8 blendColorTable[BLENDALPHA_MAX + 1][256][256];
+	u8 blendColorTable2[BLENDALPHA_MAX2 + 1][BLENDALPHA_MAX2 + 1][256][256];
+	
+	void RGBA8888::InitBlendColorTable()
+	{
+		static bool created = false;
+		
+		if(created) return;
+		
+		u32 alpha1, alpha2, color1, color2;
+		float a1, a2;
+		
+		// blendColorTable
+		for(alpha1 = 0; alpha1 <= BLENDALPHA_MAX; ++alpha1)
+		{
+			a1 = (float)alpha1 / (float)BLENDALPHA_MAX;
+			a2 = (float)(BLENDALPHA_MAX - alpha1) / (float)BLENDALPHA_MAX;
+			
+			for(color1 = 0; color1 < 256; ++color1)
+			{
+				for(color2 = 0; color2 < 256; ++color2)
+				{
+					blendColorTable[alpha1][color1][color2] = (u8)std::min<u32>( (color1 * a1) + (color2 * a2), 0xFF );
+				}
+			}
+		}
+		
+		// blendColorTable2
+		for(alpha1 = 0; alpha1 <= BLENDALPHA_MAX2; ++alpha1)
+		{
+			a1 = (float)alpha1 / (float)BLENDALPHA_MAX2;
+			
+			for(alpha2 = 0; alpha2 <= BLENDALPHA_MAX2; ++alpha2)
+			{
+				a2 = (float)alpha2 / (float)BLENDALPHA_MAX2;
+				
+				for(color1 = 0; color1 < 256; ++color1)
+				{
+					for(color2 = 0; color2 < 256; ++color2)
+					{
+						blendColorTable2[alpha1][alpha2][color1][color2] = (u8)std::min<u32>( (color1 * a1) + (color2 * a2), 0xFF );
+					}
+				}
+			}
+		}
+		
+		created = true;
+	}
+	
+	
+	//---------- HighResolutionFramebuffers ----------
+//	concurrency::accelerator acceleratorDevice;
+	
+	HighResolutionFramebuffers::HighResolutionFramebuffers()
+	{
+//		Clear();			// コンストラクタでバッファの初期化を行うと実行ファイルのサイズが肥大化することがある
+		
+		#if defined(_MSC_VER) && (_MSC_VER >= 1700) && !defined(X432R_PPL_TEST) && defined(X432R_CPP_AMP_TEST)
+/*		std::vector<concurrency::accelerator> devices = concurrency::accelerator::get_all();
+		unsigned int major_version, minor_version, memory_size;
+		
+		for(unsigned int i = 0; i < devices.size(); ++i)
+		{
+			concurrency::accelerator &device = devices[i];
+			major_version = HIWORD(device.version);
+			minor_version = LOWORD(device.version);
+			memory_size = device.dedicated_memory / 1024;		// KB → MB
+			
+			if( device.is_emulated || (major_version < 11) || (memory_size < 256) ) continue;
+			
+			acceleratorDevice = device;
+			break;
+		}
+		
+		MessageBoxW( NULL, ( L"accelerator: " + acceleratorDevice.description ).c_str(), L"C++ AMP test", MB_OK );
+*/		
+		const concurrency::accelerator default_device;
+		MessageBoxW( NULL, ( L"accelerator: " + default_device.description ).c_str(), L"C++ AMP test", MB_OK );
+		#endif
+	}
+	
+	void HighResolutionFramebuffers::Clear()
+	{
+		memset( this, 0, sizeof(HighResolutionFramebuffers) );
+		
+		subScreenIndex = 1;
+		
+		vramBlockMainScreen = 0xFF;
+		memset( vramBlockBG, 0xFF, sizeof(vramBlockBG) );
+		memset( vramBlockOBJ, 0xFF, sizeof(vramBlockOBJ) );
+		memset( highResolutionBGNum, 0xFF, sizeof(highResolutionBGNum) );
+		
+		displayCaptureWriteBlockIndex = 0xFF;
+		displayCaptureReadBlockIndex = 0xFF;
+		displayCaptureSourceA = 0xFF;
+		displayCaptureSourceB = 0xFF;
+		displayCaptureBlendingRatioA = BLENDALPHA_MAX2;
+		displayCaptureBlendingRatioB = BLENDALPHA_MAX2;
+		
+		currentRenderMagnification = GetCurrentRenderMagnification();
+		currentRenderWidth = 256 * currentRenderMagnification;
+		currentRenderHeight = 192 * currentRenderMagnification;
+		skipHighResolutionRendering[0] = true;
+		skipHighResolutionRendering[1] = true;
+	}
+	
+	void HighResolutionFramebuffers::ClearVramBuffer(const u8 vram_block)
+	{
+		if(vram_block > 3) return;
+		
+		vramPurpose[vram_block] = VramConfiguration::Purpose::OFF;
+		
+		if( !vramIsValid[vram_block] ) return;
+		
+		vramIsValid[vram_block] = false;
+		displayCaptureWriteOffset[vram_block] = 0;
+		
+//		memset( highResolutionBuffer_Vram[vram_block], 0, sizeof( highResolutionBuffer_Vram[vram_block] ) );		// バッファをクリアしなくてもたぶん問題なし
+		
+		#ifdef X432R_SAMPLEDVRAMDATACHECK_TEST
+		memset( vramSampledPixelData[vram_block], 0, sizeof( vramSampledPixelData[vram_block] ) );
+		#endif
+	}
+	
+	
+	void HighResolutionFramebuffers::UpdateMasterBrightness()
+	{
+		const GPU *gpu;
+		u32 color_rgba8888, alpha;
+		
+		for(u32 i = 0; i < 2; ++i)
+		{
+			gpu = (i == mainScreenIndex) ? MainScreen.gpu : SubScreen.gpu;
+			
+			color_rgba8888 = 0;
+			alpha = gpu->MasterBrightFactor;
+			
+			if(alpha > 2)							// 稀にフェード効果の後にMasterBrightnessが0にリセットされていない場合があるので2以下を無視（再現度は低下する）
+//			if( (alpha > 2) && (alpha < 0x1F) )
+			{
+				alpha = std::min<u32>(alpha * 16, 0xFF) << 24;
+				
+				switch(gpu->MasterBrightMode)
+				{
+					case 1:		// bright up
+						color_rgba8888 = alpha | 0x00FFFFFF;
+						break;
+					
+					case 2:		// bright down
+						color_rgba8888 = alpha;
+						break;
+				}
+			}
+			
+			masterBrightness[i] = color_rgba8888;
+		}
+	}
+	
+	
+	#ifndef X432R_SAMPLEDVRAMDATACHECK_TEST
+	inline bool HighResolutionFramebuffers::IsVramValid(const u8 vram_block)
+	{
+		#ifdef X432R_CUSTOMRENDERER_DEBUG
+		if( vramConfiguration.banks[vram_block].ofs != 0 )
+			X432R::ShowDebugMessage("VRAM Offset");
+		#endif
+		
+		return vramIsValid[vram_block];
+	}
+	#else
+	inline void HighResolutionFramebuffers::GetSampledVramPixelData(u16 * const sampled_pixels, const u8 vram_block)		// temp
+	{
+		assert( (vram_block <= 3) && (sampled_pixels != NULL) );
+		
+		u16 *source_buffer = (u16 *)( MMU.ARM9_LCD + (vram_block * 0x20000) ) + displayCaptureWriteOffset[vram_block];
+		
+		sampled_pixels[0] = source_buffer[ ( 48 * 256) +  64 ];
+		sampled_pixels[1] = source_buffer[ ( 48 * 256) + 128 ];
+		sampled_pixels[2] = source_buffer[ ( 48 * 256) + 192 ];
+		sampled_pixels[3] = source_buffer[ ( 96 * 256) +  64 ];
+		sampled_pixels[4] = source_buffer[ ( 96 * 256) + 128 ];
+		sampled_pixels[5] = source_buffer[ ( 96 * 256) + 192 ];
+		sampled_pixels[6] = source_buffer[ (144 * 256) +  64 ];
+		sampled_pixels[7] = source_buffer[ (144 * 256) + 128 ];
+		sampled_pixels[8] = source_buffer[ (144 * 256) + 192 ];
+	}
+	
+	inline bool HighResolutionFramebuffers::IsVramValid(const u8 vram_block)		// temp
+	{
+		if( !vramIsValid[vram_block] ) return false;
+		
+		u16 sampled_vramdata[9];
+		
+		GetSampledVramPixelData(sampled_vramdata, vram_block);
+		
+		#ifdef X432R_CUSTOMRENDERER_DEBUG
+		if( vramConfiguration.banks[vram_block].ofs != 0 )
+			X432R::ShowDebugMessage("VRAM Offset");
+		#endif
+		
+		return ( memcmp( sampled_vramdata, vramSampledPixelData[vram_block], sizeof(sampled_vramdata) ) == 0 );
+		
+		// MMU.cpp MMU_VRAMmapRefreshBank()でVRAMの変更をチェックし、vramIsValid[]にfalseをセットすればこの処理は不要になるはず
+	}
+	#endif
+	
+	
+	inline bool HighResolutionFramebuffers::CheckOBJParams(const GPU * const gpu, const _DISPCNT * const display_control, const u32 screen_index, const u32 dispcapture_offset)
+	{
+		if( !(bool)display_control->OBJ_Enable ) return false;
+		
+		// ピクセルフォーマットがdirect color(RGBA5551)、source bitmap widthが256に設定されている場合にのみ高解像度VRAMをOBJとして描画
+		if( (display_control->OBJ_BMP_mapping != 0) || (display_control->OBJ_BMP_2D_dim != 1) ) return false;
+		
+		_OAM_ sprite_info;
+		u32 vram_adress;
+		size size;
+		s32 offset_x, offset_y;
+		
+		for(u32 i = 0; i < 128; ++i)
+		{
+			SlurpOAM(&sprite_info, gpu->oam, i);
+			
+			if( (sprite_info.RotScale == 2) || (sprite_info.Mode != 3) || (sprite_info.PaletteIndex == 0) ) continue;
+			
+			vram_adress = ( (sprite_info.TileIndex & 0x1F) * 0x10 ) + ( (sprite_info.TileIndex & ~0x1F) * 0x80 );
+			size = sprSizeTab[sprite_info.Size][sprite_info.Shape];
+			
+			if( (vram_adress != dispcapture_offset) || (size.x != 64) || (size.y != 64) ) continue;
+			
+			offset_x = sprite_info.X;
+			offset_y = (sprite_info.Y >= 192) ? (s32)( (s8)(sprite_info.Y) ) : sprite_info.Y;
+			
+			#ifdef X432R_CUSTOMRENDERER_DEBUG
+			if( (offset_x != 0) || (offset_y != 0) )
+				X432R::ShowDebugMessage("OBJ Offset");
+			
+			if(sprite_info.VFlip)
+				X432R::ShowDebugMessage("OBJ VFlip");
+			
+			if(sprite_info.HFlip)
+				X432R::ShowDebugMessage("OBJ HFlip");
+			#endif
+			
+			BGxPARMS &dest_params = highResolutionOBJOffset[screen_index];
+			
+			if(sprite_info.RotScale & 1)
+			{
+				#ifdef X432R_CUSTOMRENDERER_DEBUG
+				X432R::ShowDebugMessage("OBJ RotScale");
+				#endif
+				
+				#ifndef X432R_HIGHRESO_BG_OBJ_ROTSCALE_TEST
+				dest_params.BGxPA = -1;		// temp
+				#else
+				dest_params. = ;
+				dest_params. = ;
+				dest_params. = ;
+				dest_params. = ;
+				#endif
+			}
+			else
+			{
+				dest_params.BGxPA = 0;		// temp
+			}
+			
+			dest_params.BGxX = offset_x;
+			dest_params.BGxY = offset_y;
+			
+			highResolutionOBJFlipX[screen_index] = (bool)sprite_info.HFlip;
+			highResolutionOBJFlipY[screen_index] = (bool)sprite_info.VFlip;
+			
+			return true;
+		}
+		
+		return false;
+	}
+	
+	inline bool HighResolutionFramebuffers::CheckBGParams(const GPU * const gpu, const u32 layer_num)
+	{
+		assert( (layer_num == 2) || (layer_num == 3) );
+		
+		// ピクセルフォーマットがdirect color(RGBA5551)に設定されている場合にのみ高解像度VRAMをBG2/BG3として描画
+		if( ( gpu->BGTypes[layer_num] != BGType_AffineExt_Direct ) || ( gpu->BGSize[layer_num][0] != 256 ) || ( gpu->BGSize[layer_num][1] != 256 ) ) return false;
+		
+		return true;
+	}
+	
+	bool HighResolutionFramebuffers::UpdateHighResolutionBGNum(const GPU * const gpu, const _DISPCNT * const display_control, const u32 screen_index)
+	{
+		assert( (screen_index == 0) || (screen_index == 1) );
+		
+		const bool bg2 = display_control->BG2_Enable && CheckBGParams(gpu, 2);
+		const bool bg3 = display_control->BG3_Enable && CheckBGParams(gpu, 3);
+		
+		if( !bg2 && !bg3 )
+		{
+			highResolutionBGNum[screen_index] = 0xFF;
+			return false;
+		}
+		
+		u8 layer_num;
+		
+		if( bg2 && !bg3 )
+			layer_num = 2;
+		
+		else if( !bg2 && bg3 )
+			layer_num = 3;
+		
+		else
+		{
+			// 優先度の低い方に割り当てられていると想定
+			const u8 bg2_priority = gpu->bgPrio[2];
+			const u8 bg3_priority = gpu->bgPrio[3];
+			
+			if(bg2_priority == bg3_priority)
+				layer_num = 3;											// priorityが同じならBGnumが大きい方が優先度が低い
+			
+			else
+				layer_num = (bg2_priority < bg3_priority) ? 3 : 2;		// priorityの値が大きい方が優先度が低い
+		}
+		
+		const BGxPARMS &source_params = (layer_num == 2) ? (gpu->dispx_st)->dispx_BG2PARMS : (gpu->dispx_st)->dispx_BG3PARMS;
+		const GPU::AffineInfo &affine_info = gpu->affineInfo[layer_num - 2];
+		BGxPARMS &dest_params = highResolutionBGOffset[screen_index];
+		
+		highResolutionBGNum[screen_index] = layer_num;
+		
+//		dest_params.BGxX = source_params.BGxX;
+//		dest_params.BGxY = source_params.BGxY;
+		dest_params.BGxX = affine_info.x;
+		dest_params.BGxY = affine_info.y;
+		dest_params.BGxPA = source_params.BGxPA;
+		dest_params.BGxPB = source_params.BGxPB;
+		dest_params.BGxPC = source_params.BGxPC;
+		dest_params.BGxPD = source_params.BGxPD;
+		
+		#ifdef X432R_CUSTOMRENDERER_DEBUG
+		if( (dest_params.BGxPA != 256) || (dest_params.BGxPB != 0) || (dest_params.BGxPC != 0) || (dest_params.BGxPD != 256) )
+			X432R::ShowDebugMessage("BG RotScale");
+		
+		if( (dest_params.BGxX != 0) || (dest_params.BGxY != 0) )
+			X432R::ShowDebugMessage("BG Offset");
+		#endif
+		
+		return true;
+	}
+	
+	#if !defined(X432R_LAYERPOSITIONOFFSET_TEST2) || !defined(X432R_HIGHRESO_BG_OBJ_ROTSCALE_TEST)
+	bool HighResolutionFramebuffers::CheckBGOffset(const u32 screen_index)
+	{
+		const BGxPARMS &params = highResolutionBGOffset[screen_index];
+		
+		#ifndef X432R_HIGHRESO_BG_OBJ_ROTSCALE_TEST
+		if( (params.BGxPA != 256) || (params.BGxPB != 0) || (params.BGxPC != 0) || (params.BGxPD != 256) ) return false;
+		#endif
+		
+		#ifndef X432R_LAYERPOSITIONOFFSET_TEST2
+		if( (params.BGxX != 0) || (params.BGxY != 0) ) return false;
+		#endif
+		
+		return true;
+	}
+	
+	bool HighResolutionFramebuffers::CheckOBJOffset(const u32 screen_index)
+	{
+		const BGxPARMS &params = highResolutionOBJOffset[screen_index];
+		
+		#ifndef X432R_HIGHRESO_BG_OBJ_ROTSCALE_TEST
+		if(params.BGxPA == -1) return false;		// temp
+		#endif
+		
+		#ifndef X432R_LAYERPOSITIONOFFSET_TEST2
+		if( (params.BGxX != 0) || (params.BGxY != 0) ) return false;
+		#endif
+		
+		if( highResolutionOBJFlipX[screen_index] || highResolutionOBJFlipY[screen_index] ) return false;
+		
+		return true;
+	}
+	#endif
+	
+	void HighResolutionFramebuffers::UpdateGpuParams()
+	{
+		mainScreenIndex = MainScreen.offset ? 1 : 0;
+		subScreenIndex = mainScreenIndex ? 0 : 1;
+		mainGpuDisplayMode = MainScreen.gpu->dispMode;
+		subGpuDisplayMode = SubScreen.gpu->dispMode;
+		
+		UpdateMasterBrightness();
+		
+		vramBlockMainScreen = 0xFF;
+		
+		memset( vramBlockBG, 0xFF, sizeof(vramBlockBG) );
+		memset( vramBlockOBJ, 0xFF, sizeof(vramBlockOBJ) );
+		memset( highResolutionBGNum, 0xFF, sizeof(highResolutionBGNum) );
+		
+		const _DISPCNT * const displaycontrol_main = &(_DISPCNT)(MainScreen.gpu->dispx_st)->dispx_DISPCNT.bits;
+		const _DISPCNT * const displaycontrol_sub = &(_DISPCNT)(SubScreen.gpu->dispx_st)->dispx_DISPCNT.bits;
+		mainGpuBG03DEnabled = (bool)displaycontrol_main->BG0_Enable && (bool)displaycontrol_main->BG0_3D;
+//		mainGpuBG03DEnabled = (bool)displaycontrol_main->BG0_Enable && (bool)displaycontrol_main->BG0_3D && (gfx3d.vertlist->count > 0);
+		
+		skipHighResolutionRendering[mainScreenIndex] = !mainGpuBG03DEnabled;
+		skipHighResolutionRendering[subScreenIndex] = true;
+		
+//		memset( highResolutionBGOffset, 0, sizeof(highResolutionBGOffset) );
+//		memset( highResolutionOBJOffset, 0, sizeof(highResolutionOBJOffset) );
+		
+		#ifdef X432R_DISPCAPTURE_MAINMEMORYFIFO_TEST
+		memset( MainMemoryFIFOBuffer, 0, sizeof(MainMemoryFIFOBuffer) );
+		#endif
+		
+		VramConfiguration::Purpose purpose;
+		
+		for(u32 i = 0; i < 4; ++i)
+		{
+			purpose = vramConfiguration.banks[i].purpose;
+			
+			switch(purpose)
+			{
+				case VramConfiguration::Purpose::ABG:
+					if( !IsVramValid(i) || !UpdateHighResolutionBGNum(MainScreen.gpu, displaycontrol_main, mainScreenIndex) ) break;
+					
+					#if !defined(X432R_LAYERPOSITIONOFFSET_TEST2) || !defined(X432R_HIGHRESO_BG_OBJ_ROTSCALE_TEST)
+					if( !CheckBGOffset(mainScreenIndex) )		// 高解像度BG/OBJを描画しないが、VRAMの内容はクリアせずに保持しておく
+					{
+						highResolutionBGNum[mainScreenIndex] = 0xFF;
+						continue;
+					}
+					#endif
+					
+					vramPurpose[i] = purpose;
+					vramBlockBG[mainScreenIndex] = i;
+					skipHighResolutionRendering[mainScreenIndex] = false;
+					continue;
+				
+				case VramConfiguration::Purpose::AOBJ:
+					if( !IsVramValid(i) || !CheckOBJParams( MainScreen.gpu, displaycontrol_main, mainScreenIndex, displayCaptureWriteOffset[i] ) ) break;
+					
+					#if !defined(X432R_LAYERPOSITIONOFFSET_TEST2) || !defined(X432R_HIGHRESO_BG_OBJ_ROTSCALE_TEST)
+					if( !CheckOBJOffset(mainScreenIndex) ) continue;
+					#endif
+					
+					vramPurpose[i] = purpose;
+					vramBlockOBJ[mainScreenIndex] = i;
+					skipHighResolutionRendering[mainScreenIndex] = false;
+					continue;
+				
+				case VramConfiguration::Purpose::BBG:
+					if( !IsVramValid(i) || !UpdateHighResolutionBGNum(SubScreen.gpu, displaycontrol_sub, subScreenIndex) ) break;
+					
+					#if !defined(X432R_LAYERPOSITIONOFFSET_TEST2) || !defined(X432R_HIGHRESO_BG_OBJ_ROTSCALE_TEST)
+					if( !CheckBGOffset(subScreenIndex) )
+					{
+						highResolutionBGNum[subScreenIndex] = 0xFF;
+						continue;
+					}
+					#endif
+					
+					vramPurpose[i] = purpose;
+					vramBlockBG[subScreenIndex] = i;
+					skipHighResolutionRendering[subScreenIndex] = false;
+					continue;
+				
+				case VramConfiguration::Purpose::BOBJ:
+					if( !IsVramValid(i) || !CheckOBJParams( SubScreen.gpu, displaycontrol_sub, subScreenIndex, displayCaptureWriteOffset[i] ) ) break;
+					
+					#if !defined(X432R_LAYERPOSITIONOFFSET_TEST2) || !defined(X432R_HIGHRESO_BG_OBJ_ROTSCALE_TEST)
+					if( !CheckOBJOffset(subScreenIndex) ) continue;
+					#endif
+					
+					vramPurpose[i] = purpose;
+					vramBlockOBJ[subScreenIndex] = i;
+					skipHighResolutionRendering[subScreenIndex] = false;
+					continue;
+				
+				case VramConfiguration::Purpose::LCDC:
+					vramPurpose[i] = purpose;
+					
+					if( !IsVramValid(i) || (mainGpuDisplayMode != 2) || (i != MainScreen.gpu->vramBlock) ) continue;
+					
+					vramBlockMainScreen = i;
+					continue;
+				
+				#ifdef X432R_CUSTOMRENDERER_DEBUG
+				case VramConfiguration::Purpose::TEX:
+					if( IsVramValid(i) && ( vramPurpose[i] == VramConfiguration::LCDC ) )
+						X432R::ShowDebugMessage("displaycapture->texture ?");
+					
+					break;
+				#endif
+			}
+			
+			ClearVramBuffer(i);
+		}
+		
+		UpdateDisplayCaptureParams(MainScreen.gpu->dispCapCnt);
+		
+		#ifdef X432R_HIGHRESOLUTION_RENDERLINE_DEBUG
+		skipHighResolutionRendering[0] = false;
+		skipHighResolutionRendering[1] = false;
+		#endif
+		
+		#ifdef X432R_3D_REARPLANE_TEST
+//		display3DControl = ( (REG_DISPx *)( &MMU.ARM9_REG[0] ) )->dispA_DISP3DCNT.bits;
+		rearPlane3DEnabled = ( ( (REG_DISPx *)( &MMU.ARM9_REG[0] ) )->dispA_DISP3DCNT.bits.RearPlaneMode == 1 );
+		
+		if(rearPlane3DEnabled)
+		{
+			u8 vram_bank_control;
+			
+			for(u32 i = 0; i < 4; ++i)
+			{
+				vram_bank_control = T1ReadByte( MMU.MMU_MEM[ARMCPU_ARM9][0x40], 0x240 + i );
+				
+				if(i <= 1)
+					vramBankControl_VramMST[i] = vram_bank_control & 0x03;		// VRAM A,B: bit0-1
+				else
+					vramBankControl_VramMST[i] = vram_bank_control & 0x07;		// VRAM B,C: bit0-2
+				
+				vramBankControl_VramOffset[i] = (vram_bank_control >> 3) & 0x03;
+				vramBankControl_VramEnabled[i] = (bool)(vram_bank_control >> 7);
+			}
+		}
+		#endif
+		
+		#ifdef X432R_CUSTOMRENDERER_DEBUG
+		_DISP3DCNT disp3d_control = ( (REG_DISPx *)( &MMU.ARM9_REG[0] ) )->dispA_DISP3DCNT.bits;
+		
+		if(disp3d_control.RearPlaneMode == 1)
+			ShowDebugMessage("DISP3DCNT RearPlane");
+		
+		if(disp3d_control.EnableAntiAliasing == 1)
+			ShowDebugMessage("DISP3DCNT AntiAliasing");
+		
+		if(disp3d_control.EnableAlphaBlending == 1)
+			ShowDebugMessage("DISP3DCNT AlphaBlending");
+		
+		if( mainGpuBG03DEnabled && ( MainScreen.gpu->getHOFS(0) != 0 ) )
+			ShowDebugMessage("BG0_3D Offset");
+		#endif
+	}
+	
+	void HighResolutionFramebuffers::UpdateDisplayCaptureParams(DISPCAPCNT params)
+	{
+		displayCaptureWriteBlockIndex = 0xFF;
+		displayCaptureReadBlockIndex = 0xFF;
+		displayCaptureSourceA = 0xFF;
+		displayCaptureSourceB = 0xFF;
+		displayCaptureBlendingRatioA = BLENDALPHA_MAX2;
+		displayCaptureBlendingRatioB = BLENDALPHA_MAX2;
+		
+		if( !(params.val & 0x80000000) ) return;
+		if( (params.capx != DISPCAPCNT::_256) || (params.capy != 192) ) return;
+//		if( (params.writeOffset != 0) || (params.readOffset != 0) ) return;
+		
+		#ifdef X432R_CUSTOMRENDERER_DEBUG
+		if(params.writeOffset != 0)
+			ShowDebugMessage("DisplayCapture WriteOffset");
+		
+		if(params.readOffset != 0)
+			ShowDebugMessage("DisplayCapture ReadOffset");
+		#endif
+		
+		u8 vram_writeblock = 0xFF;
+		
+		vram_writeblock = params.writeBlock;
+		
+		if( (vram_writeblock > 3) || ( vramPurpose[vram_writeblock] != VramConfiguration::Purpose::LCDC ) || skipHighResolutionRendering[mainScreenIndex] ) return;
+		
+		u8 vram_readblock = 0xFF;
+		u8 source_a = 0xFF;
+		u8 source_b = 0xFF;
+		u8 blend_a = BLENDALPHA_MAX2;
+		u8 blend_b = BLENDALPHA_MAX2;
+		
+		switch(params.capSrc)
+		{
+			case 0:
+				source_a = params.srcA;
+				break;
+			
+			case 1:
+				#ifdef X432R_CUSTOMRENDERER_DEBUG
+				if(params.srcB == 1)
+					ShowDebugMessage("DisplayCapture FIFO");
+				#endif
+				
+				if(params.srcB == 0)
+				{
+					vram_readblock = params.readBlock;
+					
+//					if( (vram_readblock > 3) || ( vramPurpose[vram_readblock] != VramConfiguration::Purpose::LCDC ) ) return;
+					if(vram_readblock > 3) return;
+					
+/*					if( !VramIsValid[vram_readblock] )
+					{
+						vram_readblock = 0xFF;
+						source_b = 0xFF;
+						break;
+					}
+*/				}
+				#ifndef X432R_DISPCAPTURE_MAINMEMORYFIFO_TEST
+				else return;
+				#endif
+				
+				if( (params.srcB == 0) && vramIsValid[vram_readblock] )
+					source_b = params.srcB;
+				
+				break;
+			
+			default:
+				#ifdef X432R_CUSTOMRENDERER_DEBUG
+				if(params.srcB == 1)
+					ShowDebugMessage("DisplayCapture GpuBuffer + FIFO");
+				#endif
+				
+				if(params.srcB == 0)
+				{
+					vram_readblock = params.readBlock;
+					
+//					if( (vram_readblock > 3) || ( vramPurpose[vram_readblock] != VramConfiguration::Purpose::LCDC ) ) return;
+					if(vram_readblock > 3) return;
+					
+/*					if( !VramIsValid[vram_readblock] )
+					{
+						vram_readblock = 0xFF;
+						source_b = 0xFF;
+						break;
+					}
+*/				}
+				#ifndef X432R_DISPCAPTURE_MAINMEMORYFIFO_TEST
+				else return;
+				#endif
+				
+				if( ( (params.srcB == 0) && !vramIsValid[vram_readblock] ) )
+					source_a = params.srcA;
+				
+				else if(params.EVA == 0)
+					source_b = params.srcB;
+				
+				else
+				{
+					source_a = params.srcA;
+					source_b = params.srcB;
+					blend_a = std::min<u8>(params.EVA, BLENDALPHA_MAX2);
+					blend_b = std::min<u8>(params.EVB, BLENDALPHA_MAX2);
+				}
+				break;
+		}
+		
+		displayCaptureWriteBlockIndex = vram_writeblock;
+		displayCaptureReadBlockIndex = vram_readblock;
+		displayCaptureSourceA = source_a;
+		displayCaptureSourceB = source_b;
+		displayCaptureBlendingRatioA = blend_a;
+		displayCaptureBlendingRatioB = blend_b;
+		
+		displayCaptureWriteOffset[vram_writeblock] = params.writeOffset * 0x8000;
+	}
+	
+	
+	#if !defined(_MSC_VER) || (_MSC_VER < 1700) || !defined(X432R_PPL_TEST)
+	template <u32 RENDER_MAGNIFICATION, bool HIGHRESO, u8 CAPTURESOURCE_A, u8 CAPTURESOURCE_B, u8 GPU_DISPLAYMODE>
+	void HighResolutionFramebuffers::UpdateFrontBufferAndDisplayCapture(u32 *front_buffer, const u32 screen_index)
+	{
+		assert( (screen_index == 0) || (screen_index == 1) );
+		assert(front_buffer != NULL);
+		
+		const u32 screenoffset_highreso = screen_index * 256 * 192 * RENDER_MAGNIFICATION * RENDER_MAGNIFICATION;
+		const u32 screenoffset_normal = screen_index * 256 * 192;
+		
+		const u16 * const normalbuffer_begin = (u16 *)GPU_screen + screenoffset_normal;
+		const u32 * const backgroundbuffer_begin = backgroundBuffer + screenoffset_normal;
+		const bool * const highresoflagbuffer_begin = highResolutionFlagBuffer + screenoffset_normal;
+		
+		u32 *highreso_buffer = highResolutionBuffer_Final + screenoffset_highreso;
+		const u16 *normal_buffer;
+		const u32 *background_buffer;
+		const bool *highresoflag_buffer;
+		
+		u32 downscaled_index;
+		u32 color_rgba8888, background_rgba8888, nativescreen_rgba8888;
+		bool is_lowreso_pixel;
+		
+		const u32 *maingpu3d_buffer = (CAPTURESOURCE_A == 1) ? highResolutionBuffer_3D : NULL;
+		u32 *vram_writebuffer = ( (CAPTURESOURCE_A <= 1) || (CAPTURESOURCE_B <= 1) ) ? highResolutionBuffer_Vram[displayCaptureWriteBlockIndex] : NULL;
+		const u32 *vram_readbuffer = (CAPTURESOURCE_B == 0) ? highResolutionBuffer_Vram[displayCaptureReadBlockIndex] : NULL;
+		const u32 *vram_screenbuffer = (GPU_DISPLAYMODE == 2) ? highResolutionBuffer_Vram[vramBlockMainScreen] : NULL;
+		
+		#ifdef X432R_DISPCAPTURE_MAINMEMORYFIFO_TEST
+		const u32 *fifo_buffer = (CAPTURESOURCE_B == 1) ? MainMemoryFIFOBuffer : NULL;
+		u32 fifo_rgba8888;
+		#endif
+		
+		u32 x, y;
+		
+		
+		front_buffer += screenoffset_highreso;
+		
+		
+		for( y = 0; y < (192 * RENDER_MAGNIFICATION); ++y )
+		{
+			downscaled_index = (y / RENDER_MAGNIFICATION) * 256;
+			
+			normal_buffer = normalbuffer_begin + downscaled_index;
+			background_buffer = backgroundbuffer_begin + downscaled_index;
+			highresoflag_buffer = highresoflagbuffer_begin + downscaled_index;
+			
+			for( x = 0; x < (256 * RENDER_MAGNIFICATION); ++x, ++front_buffer )
+			{
+//				highreso_index = (y * 256 * RENDER_MAGNIFICATION) + x;
+				
+				if( (x % RENDER_MAGNIFICATION) == 0 )
+				{
+					nativescreen_rgba8888 = (u32)RGB15TO24_REVERSE(*normal_buffer++) | 0xFF000000;
+					
+					if( !HIGHRESO )
+						color_rgba8888 = nativescreen_rgba8888;
+					else
+					{
+						background_rgba8888 = *background_buffer++ | 0xFF000000;
+						is_lowreso_pixel = !(*highresoflag_buffer++);
+						
+						#ifdef X432R_CUSTOMRENDERER_DEBUG2
+						if(debugModeEnabled2)
+							background_rgba8888 = RGBA8888::AlphaBlend(0xFF00FF00, background_rgba8888, 8).Color;
+						#endif
+					}
+					
+					#ifdef X432R_DISPCAPTURE_MAINMEMORYFIFO_TEST
+					if(CAPTURESOURCE_B == 1)
+						fifo_rgba8888 = *fifo_buffer++;
+					#endif
+					
+				}
+				
+				if(HIGHRESO)
+				{
+					if( is_lowreso_pixel || (*highreso_buffer == 0) )
+						color_rgba8888 = background_rgba8888;
+					else
+						color_rgba8888 = *highreso_buffer;
+						
+					*highreso_buffer++ = 0;			// 次フレームのために値をクリアしておく
+				}
+				
+				switch(GPU_DISPLAYMODE)
+				{
+					case 1:
+						*front_buffer = color_rgba8888;
+						break;
+					
+					case 2:
+						*front_buffer = *vram_screenbuffer++;
+						break;
+					
+/*					#ifdef X432R_DISPCAPTURE_MAINMEMORYFIFO_TEST
+					case 3:
+						*front_buffer = *fifo_buffer;
+						break;
+					
+					case 0:
+						*front_buffer = 0xFFFFFFFF;
+						break;
+					#endif
+*/					
+					default:
+						*front_buffer = nativescreen_rgba8888;
+						break;
+				}
+				
+				// DispCapture
+				if( (CAPTURESOURCE_A != 0xFF) || (CAPTURESOURCE_B != 0xFF) )
+				{
+					if(CAPTURESOURCE_B == 0xFF)
+					{
+						if(CAPTURESOURCE_A == 0)
+							*vram_writebuffer++ = color_rgba8888;				// BG+3D+OBJ
+						
+						else if(CAPTURESOURCE_A == 1)
+							*vram_writebuffer++ = *maingpu3d_buffer++;			// 3D only
+					}
+					
+					else if(CAPTURESOURCE_A == 0xFF)
+					{
+						if(CAPTURESOURCE_B == 0)
+							*vram_writebuffer++ = *vram_readbuffer++;			// VRAM
+						#ifdef X432R_DISPCAPTURE_MAINMEMORYFIFO_TEST
+						else if(CAPTURESOURCE_B == 1)
+							*vram_writebuffer++ = *fifo_buffer;					// MainMemoryDisplayFIFO
+						#endif
+					}
+					
+					else if( (CAPTURESOURCE_A == 0) && (CAPTURESOURCE_B == 0) )		// BG+3D+OBJ + VRAM
+						*vram_writebuffer++ = RGBA8888::AlphaBlend(color_rgba8888, *vram_readbuffer++, displayCaptureBlendingRatioA, displayCaptureBlendingRatioB).Color;
+					
+					else if( (CAPTURESOURCE_A == 1) && (CAPTURESOURCE_B == 0) )		// 3D + VRAM
+						*vram_writebuffer++ = RGBA8888::AlphaBlend(*maingpu3d_buffer++, *vram_readbuffer++, displayCaptureBlendingRatioA, displayCaptureBlendingRatioB).Color;
+					
+					#ifdef X432R_DISPCAPTURE_MAINMEMORYFIFO_TEST
+					else if( (CAPTURESOURCE_A == 0) && (CAPTURESOURCE_B == 1) )		// BG+3D+OBJ + MainMemoryDisplayFIFO
+						*vram_writebuffer++ = RGBA8888::AlphaBlend(color_rgba8888, *fifo_buffer, displayCaptureBlendingRatioA, displayCaptureBlendingRatioB).Color;
+					
+					else if( (CAPTURESOURCE_A == 1) && (CAPTURESOURCE_B == 1) )		// 3D + MainMemoryDisplayFIFO
+						*vram_writebuffer++ = RGBA8888::AlphaBlend(*maingpu3d_buffer++, *fifo_buffer, displayCaptureBlendingRatioA, displayCaptureBlendingRatioB).Color;
+					#endif
+				}
+			}
+		}
+		
+		if( (CAPTURESOURCE_A > 1) && (CAPTURESOURCE_B > 1) ) return;
+		
+		vramIsValid[displayCaptureWriteBlockIndex] = true;
+		
+		#ifdef X432R_SAMPLEDVRAMDATACHECK_TEST
+		GetSampledVramPixelData( vramSampledPixelData[displayCaptureWriteBlockIndex], displayCaptureWriteBlockIndex );
+		#endif
+	}
+	#else
+	template <u32 RENDER_MAGNIFICATION, bool HIGHRESO, u8 CAPTURESOURCE_A, u8 CAPTURESOURCE_B, u8 GPU_DISPLAYMODE>
+	void HighResolutionFramebuffers::UpdateFrontBufferAndDisplayCapture(u32 *frontbuffer_begin, const u32 screen_index)
+	{
+		assert( (screen_index == 0) || (screen_index == 1) );
+		assert(frontbuffer_begin != NULL);
+		
+		const u32 screenoffset_highreso = screen_index * 256 * 192 * RENDER_MAGNIFICATION * RENDER_MAGNIFICATION;
+		const u32 screenoffset_normal = screen_index * 256 * 192;
+		
+		u32 * const highresobuffer_begin = highResolutionBuffer_Final + screenoffset_highreso;
+		const u16 * const normalbuffer_begin = (u16 *)GPU_screen + screenoffset_normal;
+		const u32 * const backgroundbuffer_begin = backgroundBuffer + screenoffset_normal;
+		const bool * const highresoflagbuffer_begin = highResolutionFlagBuffer + screenoffset_normal;
+		
+		const u32 * const maingpu3dbuffer_begin = (CAPTURESOURCE_A == 1) ? highResolutionBuffer_3D : NULL;
+		u32 * const vramwritebuffer_begin = ( (CAPTURESOURCE_A <= 1) || (CAPTURESOURCE_B <= 1) ) ? highResolutionBuffer_Vram[displayCaptureWriteBlockIndex] : NULL;
+		const u32 * const vramreadbuffer_begin = (CAPTURESOURCE_B == 0) ? highResolutionBuffer_Vram[displayCaptureReadBlockIndex] : NULL;
+		const u32 * const vramscreenbuffer_begin = (GPU_DISPLAYMODE == 2) ? highResolutionBuffer_Vram[vramBlockMainScreen] : NULL;
+		
+		#ifdef X432R_DISPCAPTURE_MAINMEMORYFIFO_TEST
+		const u32 * const fifobuffer_begin = (CAPTURESOURCE_B == 1) ? MainMemoryFIFOBuffer : NULL;
+		#endif
+		
+		
+		frontbuffer_begin += screenoffset_highreso;
+		
+		
+		concurrency::parallel_for( (u32)0, RENDER_MAGNIFICATION, [&](const u32 offset)
+		{
+			const u32 y_begin = 192 * offset;
+			const u32 y_end = y_begin + 192;
+			
+			const u32 highreso_index = (y_begin * 256 * RENDER_MAGNIFICATION);
+			
+			u32 *highreso_buffer = highresobuffer_begin + highreso_index;
+			u32 *front_buffer = frontbuffer_begin + highreso_index;
+			const u16 *normal_buffer;
+			const u32 *background_buffer;
+			const bool *highresoflag_buffer;
+			
+			const u32 *maingpu3d_buffer = (CAPTURESOURCE_A == 1) ? (maingpu3dbuffer_begin + highreso_index) : NULL;
+			u32 *vram_writebuffer = ( (CAPTURESOURCE_A <= 1) || (CAPTURESOURCE_B <= 1) ) ? (vramwritebuffer_begin + highreso_index) : NULL;
+			const u32 *vram_readbuffer = (CAPTURESOURCE_B == 0) ? (vramreadbuffer_begin + highreso_index) : NULL;
+			const u32 *vram_screenbuffer = (GPU_DISPLAYMODE == 2) ? (vramscreenbuffer_begin + highreso_index) : NULL;
+			
+			u32 x, y, downscaled_index;
+			u32 color_rgba8888, background_rgba8888, nativescreen_rgba8888;
+			bool is_lowreso_pixel;
+			
+			#ifdef X432R_DISPCAPTURE_MAINMEMORYFIFO_TEST
+			const u32 *fifo_buffer = (CAPTURESOURCE_B == 1) ? (fifobuffer_begin + highreso_index) : NULL;
+			u32 fifo_rgba8888;
+			#endif
+			
+			for(y = y_begin; y < y_end; ++y)
+			{
+				downscaled_index = (y / RENDER_MAGNIFICATION) * 256;
+				
+				normal_buffer = normalbuffer_begin + downscaled_index;
+				background_buffer = backgroundbuffer_begin + downscaled_index;
+				highresoflag_buffer = highresoflagbuffer_begin + downscaled_index;
+				
+				for(x = 0; x < (256 * RENDER_MAGNIFICATION); ++x, ++front_buffer )
+				{
+					if( (x % RENDER_MAGNIFICATION) == 0 )
+					{
+						nativescreen_rgba8888 = (u32)RGB15TO24_REVERSE(*normal_buffer++) | 0xFF000000;
+						
+						if( !HIGHRESO )
+							color_rgba8888 = nativescreen_rgba8888;
+						else
+						{
+							background_rgba8888 = *background_buffer++ | 0xFF000000;
+							is_lowreso_pixel = !(*highresoflag_buffer++);
+							
+							#ifdef X432R_CUSTOMRENDERER_DEBUG2
+							if(debugModeEnabled2)
+								background_rgba8888 = RGBA8888::AlphaBlend(0xFF00FF00, background_rgba8888, 8).Color;
+							#endif
+						}
+						
+						#ifdef X432R_DISPCAPTURE_MAINMEMORYFIFO_TEST
+						if(CAPTURESOURCE_B == 1)
+							fifo_rgba8888 = *fifo_buffer++;
+						#endif
+					}
+					
+					if(HIGHRESO)
+					{
+						if( is_lowreso_pixel || (*highreso_buffer == 0) )
+							color_rgba8888 = background_rgba8888;
+						else
+							color_rgba8888 = *highreso_buffer | 0xFF000000;
+						
+						*highreso_buffer++ = 0;			// 次フレームのために値をクリアしておく
+					}
+					
+					switch(GPU_DISPLAYMODE)
+					{
+						case 1:
+							*front_buffer = color_rgba8888;
+							break;
+						
+						case 2:
+							*front_buffer = *vram_screenbuffer++;
+							break;
+						
+/*						#ifdef X432R_DISPCAPTURE_MAINMEMORYFIFO_TEST
+						case 3:
+							*front_buffer = *fifo_buffer | 0xFF000000;
+							break;
+						
+						case 0:
+							*front_buffer = 0xFFFFFFFF;
+							break;
+						#endif
+*/						
+						default:
+							*front_buffer = nativescreen_rgba8888;
+							break;
+					}
+					
+					// DispCapture
+					if( (CAPTURESOURCE_A != 0xFF) || (CAPTURESOURCE_B != 0xFF) )
+					{
+						if(CAPTURESOURCE_B == 0xFF)
+						{
+							if(CAPTURESOURCE_A == 0)
+								*vram_writebuffer++ = color_rgba8888;							// BG+3D+OBJ
+							
+							else if(CAPTURESOURCE_A == 1)
+								*vram_writebuffer++ = *maingpu3d_buffer++ | 0xFF000000;			// 3D only
+						}
+						
+						else if(CAPTURESOURCE_A == 0xFF)
+						{
+							if(CAPTURESOURCE_B == 0)
+								*vram_writebuffer++ = *vram_readbuffer++;						// VRAM
+							#ifdef X432R_DISPCAPTURE_MAINMEMORYFIFO_TEST
+							else if(CAPTURESOURCE_B == 1)
+								*vram_writebuffer++ = *fifo_buffer | 0xFF000000;				// MainMemoryDisplayFIFO
+							#endif
+						}
+						
+						else if( (CAPTURESOURCE_A == 0) && (CAPTURESOURCE_B == 0) )		// BG+3D+OBJ + VRAM
+							*vram_writebuffer++ = RGBA8888::AlphaBlend(color_rgba8888, *vram_readbuffer++, displayCaptureBlendingRatioA, displayCaptureBlendingRatioB).Color;
+						
+						else if( (CAPTURESOURCE_A == 1) && (CAPTURESOURCE_B == 0) )		// 3D + VRAM
+							*vram_writebuffer++ = RGBA8888::AlphaBlend(*maingpu3d_buffer++, *vram_readbuffer++, displayCaptureBlendingRatioA, displayCaptureBlendingRatioB).Color;
+						
+						#ifdef X432R_DISPCAPTURE_MAINMEMORYFIFO_TEST
+						else if( (CAPTURESOURCE_A == 0) && (CAPTURESOURCE_B == 1) )		// BG+3D+OBJ + MainMemoryDisplayFIFO
+							*vram_writebuffer++ = RGBA8888::AlphaBlend(color_rgba8888, *fifo_buffer, displayCaptureBlendingRatioA, displayCaptureBlendingRatioB).Color;
+						
+						else if( (CAPTURESOURCE_A == 1) && (CAPTURESOURCE_B == 1) )		// 3D + MainMemoryDisplayFIFO
+							*vram_writebuffer++ = RGBA8888::AlphaBlend(*maingpu3d_buffer++, *fifo_buffer, displayCaptureBlendingRatioA, displayCaptureBlendingRatioB).Color;
+						#endif
+					}
+				}
+			}
+		});
+		
+		if( (CAPTURESOURCE_A > 1) && (CAPTURESOURCE_B > 1) ) return;
+		
+		vramIsValid[displayCaptureWriteBlockIndex] = true;
+		
+		#ifdef X432R_SAMPLEDVRAMDATACHECK_TEST
+		GetSampledVramPixelData( vramSampledPixelData[displayCaptureWriteBlockIndex], displayCaptureWriteBlockIndex );
+		#endif
+	}
+	#endif
+	
+	template <u32 RENDER_MAGNIFICATION>
+	void HighResolutionFramebuffers::UpdateFrontBuffer(u32 *front_buffer, const u32 screen_index)
+	{
+		assert( (screen_index == 0) || (screen_index == 1) );
+		assert(front_buffer != NULL);
+		
+		const u16 *normal_buffer = (u16 *)GPU_screen + (screen_index * 256 * 192);
+		
+		front_buffer += (screen_index * 256 * 192 * RENDER_MAGNIFICATION * RENDER_MAGNIFICATION);
+		
+		for(u32 i = 0; i < (256 * 192); ++i, ++front_buffer, ++normal_buffer)
+		{
+			*front_buffer = (u32)RGB15TO24_REVERSE(*normal_buffer) | 0xFF000000;
+		}
+	}
+	
+	template <u32 RENDER_MAGNIFICATION>
+	inline void HighResolutionFramebuffers::UpdateFrontBufferAndDisplayCapture(u32 * const front_buffer, u32 * const master_brightness, bool * const is_highreso_screen)
+	{
+		X432R_STATIC_RENDER_MAGNIFICATION_CHECK();
+		
+		
+		// MainScreen
+		u8 display_mode = 0xFF;
+		
+		if( (mainGpuDisplayMode == 1) || ( (mainGpuDisplayMode == 2) && (vramBlockMainScreen <= 3) ) )
+			display_mode = mainGpuDisplayMode;
+		
+		is_highreso_screen[mainScreenIndex] = true;
+		
+		#define X432R_CALL_UPDATEFRONTBUFFER(source_a,source_b) \
+		{ \
+			if( skipHighResolutionRendering[mainScreenIndex] ) \
+			{ \
+				switch(display_mode) \
+				{ \
+					case 1:		UpdateFrontBufferAndDisplayCapture<RENDER_MAGNIFICATION, false, source_a, source_b, 1>(front_buffer, mainScreenIndex);		break; \
+					case 2:		UpdateFrontBufferAndDisplayCapture<RENDER_MAGNIFICATION, false, source_a, source_b, 2>(front_buffer, mainScreenIndex);		break; \
+					default:	UpdateFrontBufferAndDisplayCapture<RENDER_MAGNIFICATION, false, source_a, source_b, 0xFF>(front_buffer, mainScreenIndex);	break; \
+				} \
+			} \
+			else \
+			{ \
+				switch(display_mode) \
+				{ \
+					case 1:		UpdateFrontBufferAndDisplayCapture<RENDER_MAGNIFICATION, true, source_a, source_b, 1>(front_buffer, mainScreenIndex);		break; \
+					case 2:		UpdateFrontBufferAndDisplayCapture<RENDER_MAGNIFICATION, true, source_a, source_b, 2>(front_buffer, mainScreenIndex);		break; \
+					default:	UpdateFrontBufferAndDisplayCapture<RENDER_MAGNIFICATION, true, source_a, source_b, 0xFF>(front_buffer, mainScreenIndex);	break; \
+				} \
+			} \
+		}
+		
+		switch(displayCaptureSourceA)
+		{
+			case 0:
+				switch(displayCaptureSourceB)
+				{
+					case 0:
+						X432R_CALL_UPDATEFRONTBUFFER(0, 0)
+						break;
+					
+					case 1:
+						X432R_CALL_UPDATEFRONTBUFFER(0, 1)
+						break;
+					
+					default:
+						X432R_CALL_UPDATEFRONTBUFFER(0, 0xFF)
+						break;
+				}
+				break;
+			
+			case 1:
+				switch(displayCaptureSourceB)
+				{
+					case 0:
+						X432R_CALL_UPDATEFRONTBUFFER(1, 0)
+						break;
+					
+					case 1:
+						X432R_CALL_UPDATEFRONTBUFFER(1, 1)
+						break;
+					
+					default:
+						X432R_CALL_UPDATEFRONTBUFFER(1, 0xFF)
+						break;
+				}
+				break;
+			
+			default:
+				switch(displayCaptureSourceB)
+				{
+					case 0:
+						X432R_CALL_UPDATEFRONTBUFFER(0xFF, 0)
+						break;
+					
+					case 1:
+						X432R_CALL_UPDATEFRONTBUFFER(0xFF, 1)
+						break;
+					
+					default:
+						if( ( (display_mode == 1) && !skipHighResolutionRendering[mainScreenIndex] ) || (display_mode == 2) )
+							X432R_CALL_UPDATEFRONTBUFFER(0xFF, 0xFF)
+						else
+						{
+							UpdateFrontBuffer<RENDER_MAGNIFICATION>(front_buffer, mainScreenIndex);
+							is_highreso_screen[mainScreenIndex] = false;
+						}
+						break;
+				}
+				break;
+		}
+		
+		#undef X432R_CALL_UPDATEFRONTBUFFER
+		
+		
+		// SubScreen
+		if( (subGpuDisplayMode == 1) && !skipHighResolutionRendering[subScreenIndex] )
+		{
+			UpdateFrontBufferAndDisplayCapture<RENDER_MAGNIFICATION, true, 0xFF, 0xFF, 1>(front_buffer, subScreenIndex);
+			is_highreso_screen[subScreenIndex] = true;
+		}
+		else
+		{
+			UpdateFrontBuffer<RENDER_MAGNIFICATION>(front_buffer, subScreenIndex);
+			is_highreso_screen[subScreenIndex] = false;
+		}
+		
+		
+		master_brightness[0] = masterBrightness[0];
+		master_brightness[1] = masterBrightness[1];
+		
+		currentFrameRendered = false;
+	}
+	
+	template void HighResolutionFramebuffers::UpdateFrontBufferAndDisplayCapture<2>(u32 * const front_buffer, u32 * const master_brightness, bool * const is_highreso_screen);
+	template void HighResolutionFramebuffers::UpdateFrontBufferAndDisplayCapture<3>(u32 * const front_buffer, u32 * const master_brightness, bool * const is_highreso_screen);
+	template void HighResolutionFramebuffers::UpdateFrontBufferAndDisplayCapture<4>(u32 * const front_buffer, u32 * const master_brightness, bool * const is_highreso_screen);
+	
+	
+	//---------- HighResolutionFramebuffers RenderLine ----------
+	
+	void HighResolutionFramebuffers::UpdateRenderLineParams(const NDS_Screen * const screen, u32 y)
+	{
+		const bool is_maingpu = (screen->gpu->core == 0);
+		
+		renderLine_ScreenIndex = screen->offset ? 1 : 0;
+		
+		if( (y == 0) && is_maingpu )
+		{
+			currentRenderMagnification = GetCurrentRenderMagnification();
+			currentRenderWidth = 256 * currentRenderMagnification;
+			currentRenderHeight = 192 * currentRenderMagnification;
+			
+			if(currentRenderMagnification == 1)
+			{
+				skipHighResolutionRendering[0] = true;
+				skipHighResolutionRendering[1] = true;
+				
+				renderLine_SkipHighResolutionRendering = true;
+				return;
+			}
+			
+			UpdateGpuParams();
+			
+//			if(mainGpuBG03DEnabled)
+				gpu3D->NDS_3D_RenderFinish();			// GPU_RenderLine_Layer()の最初に実行しておく
+			
+			currentFrameRendered = true;
+		}
+		
+		renderLine_SkipHighResolutionRendering = skipHighResolutionRendering[renderLine_ScreenIndex];
+		
+		if(renderLine_SkipHighResolutionRendering) return;
+		
+		const u32 screenoffset_normal = renderLine_ScreenIndex * 256 * 192;
+		const u32 bufferoffset_normal = y * 256;
+		const u32 screenoffset_highreso = screenoffset_normal * currentRenderMagnification * currentRenderMagnification;
+		
+		renderLine_CurrentY = y;
+		renderLine_HighResolutionYBegin = y * currentRenderMagnification;
+		renderLine_HighResolutionYEnd = renderLine_HighResolutionYBegin + currentRenderMagnification;
+		
+		renderLine_BrightFactor = std::min<u8>(screen->gpu->BLDY_EVY, BLENDALPHA_MAX);
+		renderLine_BlendAlphaA = std::min<u8>(screen->gpu->BLDALPHA_EVA, BLENDALPHA_MAX2);
+		renderLine_BlendAlphaB = std::min<u8>(screen->gpu->BLDALPHA_EVB, BLENDALPHA_MAX2);
+		
+		renderLine_HighResolutionFinalBuffer = highResolutionBuffer_Final + screenoffset_highreso;
+		renderLine_BackgroundBuffer = backgroundBuffer + screenoffset_normal + bufferoffset_normal;
+		renderLine_HighResolutionFlagBuffer = highResolutionFlagBuffer + screenoffset_normal + bufferoffset_normal;
+		
+		#ifdef X432R_DISPCAPTURE_MAINMEMORYFIFO_TEST
+		renderLine_MainMemoryFIFOBuffer = MainMemoryFIFOBuffer + bufferoffset_normal;
+		#endif
+		
+		const u8 vramblock_bg = vramBlockBG[renderLine_ScreenIndex];
+		const u8 vramblock_obj = vramBlockOBJ[renderLine_ScreenIndex];
+		
+		if(vramblock_bg <= 3)
+		{
+			renderLine_HighResolutionBGNum = highResolutionBGNum[renderLine_ScreenIndex];
+			renderLine_VramBufferBG = highResolutionBuffer_Vram[vramblock_bg];
+			
+			#ifdef X432R_LAYERPOSITIONOFFSET_TEST2
+			renderLine_HighResolutionBGOffset = highResolutionBGOffset + renderLine_ScreenIndex;
+			#endif
+		}
+		else
+		{
+			renderLine_HighResolutionBGNum = 0xFF;
+			renderLine_VramBufferBG = NULL;
+			
+			#ifdef X432R_LAYERPOSITIONOFFSET_TEST2
+			renderLine_HighResolutionBGOffset = NULL;
+			#endif
+		}
+		
+		if(vramblock_obj <= 3)
+		{
+			renderLine_VramBufferOBJ = highResolutionBuffer_Vram[vramblock_obj];
+			
+			#ifdef X432R_LAYERPOSITIONOFFSET_TEST2
+			renderLine_HighResolutionOBJOffset = highResolutionOBJOffset + renderLine_ScreenIndex;
+			#endif
+		}
+		else
+		{
+			renderLine_VramBufferOBJ = NULL;
+			
+			#ifdef X432R_LAYERPOSITIONOFFSET_TEST2
+			renderLine_HighResolutionOBJOffset = NULL;
+			#endif
+		}
+	}
+	
+	void HighResolutionFramebuffers::SetBackdropColor(const u16 backdrop_rgb555)
+	{
+		if(renderLine_SkipHighResolutionRendering) return;
+		
+		const u32 backdrop_rgba8888 = (u32)RGB15TO24_REVERSE(backdrop_rgb555) | 0xFF000000;
+		u32 *background_buffer = renderLine_BackgroundBuffer;
+		bool *highresoflag_buffer = renderLine_HighResolutionFlagBuffer;
+		
+		for(u32 x = 0; x < 256; ++x, ++background_buffer, ++highresoflag_buffer)
+		{
+			*background_buffer = backdrop_rgba8888;
+			*highresoflag_buffer = false;
+		}
+	}
+	
+	
+	template <SOURCELAYER LAYER, BLENDMODE MODE, bool HIGHRESO, bool LAYER_OFFSET, bool USE_ALPHA>
+	inline void HighResolutionFramebuffers::SetFinalColor(const u32 dest_x, const u32 source_x, const u16 color_rgb555, u8 alpha, const u32 * const source_buffer)
+	{
+		const u32 x_begin = dest_x * currentRenderMagnification;
+		const u32 x_end = x_begin + currentRenderMagnification;
+		
+		const u32 background_rgba8888 = renderLine_BackgroundBuffer[dest_x];
+		
+		u32 *highreso_buffer;
+		u32 highreso_index;
+		u32 color_rgba8888;
+		
+		u32 x, y;
+		
+		s32 offset_x = 0;
+		s32 offset_y = 0;
+		s32 offseted_x, offseted_y;
+		
+		
+		#ifdef X432R_PROCESSTIME_CHECK
+		AutoStopTimeCounter timecounter(timeCounter_2DHighReso);
+		#endif
+		
+		
+		if( !HIGHRESO )
+		{
+			color_rgba8888 = (u32)RGB15TO24_REVERSE(color_rgb555) | 0xFF000000;
+			
+			#ifdef X432R_CUSTOMRENDERER_DEBUG2
+			if(debugModeEnabled2)
+				color_rgba8888 = RGBA8888::AlphaBlend(0xFFFF0000, color_rgba8888, 8).Color;
+			#endif
+		}
+		else
+		{
+			if(LAYER_OFFSET)
+			{
+				switch(LAYER)
+				{
+					#ifdef X432R_LAYERPOSITIONOFFSET_TEST
+					case SOURCELAYER_3D:
+						offset_x = (dest_x - source_x) * currentRenderMagnification;
+						break;
+					#endif
+					
+					#ifdef X432R_LAYERPOSITIONOFFSET_TEST2
+					case SOURCELAYER_BG:
+						#if 1
+						offset_x = highResolutionBGOffset[screen_index].BGxX * currentRenderMagnification;
+						offset_y = highResolutionBGOffset[screen_index].BGxY * currentRenderMagnification;
+						#else
+						offset_x = ( dest_x - ( (dest_x + highResolutionBGOffset[screen_index].BGxX) & 0x1FF ) ) * currentRenderMagnification;
+						offset_y = ( renderLine_CurrentY - ( (renderLine_CurrentY + highResolutionBGOffset[screen_index].BGxY) & 0xFF ) ) * currentRenderMagnification;
+						#endif
+						break;
+					
+					case SOURCELAYER_OBJ:
+						#if 1
+						offset_x = highResolutionOBJOffset[screen_index].BGxX * currentRenderMagnification;
+						offset_y = highResolutionOBJOffset[screen_index].BGxY * currentRenderMagnification;
+						#else
+						offset_x = ( dest_x - ( (dest_x + highResolutionOBJOffset.BGxX) & 0x1FF ) ) * currentRenderMagnification;
+						offset_y = ( renderLine_CurrentY - ( (renderLine_CurrentY + highResolutionOBJOffset.BGxY) & 0xFF ) ) * currentRenderMagnification;
+						#endif
+						
+/*						if(renderLine_CurrentHighResolutionOBJFlipX)
+							;
+						
+						if(renderLine_CurrentHighResolutionOBJFlipY)
+							;
+*/						
+						break;
+					#endif
+				}
+			}
+		}
+		
+		for( y = renderLine_HighResolutionYBegin; y < renderLine_HighResolutionYEnd; ++y )
+		{
+			highreso_index = y * currentRenderWidth;
+			highreso_buffer = renderLine_HighResolutionFinalBuffer + highreso_index + x_begin;
+			
+			if(LAYER_OFFSET)
+			{
+				if(LAYER == SOURCELAYER_3D)
+					offseted_y = highreso_index;
+				else
+				{
+					offseted_y = (s32)y - offset_y;
+					
+					if( (offseted_y < 0) || (offseted_y >= currentRenderHeight) ) continue;
+					
+					offseted_y *= currentRenderWidth;
+				}
+			}
+			
+			for(x = x_begin; x < x_end; ++x, ++highreso_buffer)
+			{
+				if( !HIGHRESO )
+				{
+/*					if(MODE != BLENDMODE_ENABLED)
+						*highreso_buffer = color_rgba8888;
+					else
+					{
+*/						if(USE_ALPHA)
+						{
+							if(*highreso_buffer == 0)
+								*highreso_buffer = RGBA8888::AlphaBlend(color_rgba8888, background_rgba8888, alpha).Color;
+							else
+								*highreso_buffer = RGBA8888::AlphaBlend(color_rgba8888, *highreso_buffer, alpha).Color;
+						}
+						else
+						{
+							if(*highreso_buffer == 0)
+								*highreso_buffer = RGBA8888::AlphaBlend(color_rgba8888, background_rgba8888, renderLine_BlendAlphaA, renderLine_BlendAlphaB).Color;
+							else
+								*highreso_buffer = RGBA8888::AlphaBlend(color_rgba8888, *highreso_buffer, renderLine_BlendAlphaA, renderLine_BlendAlphaB).Color;
+						}
+//					}
+					
+					continue;
+				}
+				
+				if( !LAYER_OFFSET )
+					color_rgba8888 = source_buffer[highreso_index + x];
+				else
+				{
+					offseted_x = (s32)x - offset_x;
+					
+					if( (offseted_x < 0) || (offseted_x >= currentRenderWidth) ) continue;
+					
+					color_rgba8888 = source_buffer[offseted_y + offseted_x];
+				}
+				
+				switch(MODE)
+				{
+					case BLENDMODE_BRIGHTUP:
+						if(color_rgba8888 == 0) continue;
+						
+						*highreso_buffer = RGBA8888::AlphaBlend(0xFFFFFFFF, color_rgba8888, renderLine_BrightFactor).Color;
+						break;
+					
+					case BLENDMODE_BRIGHTDOWN:
+						if(color_rgba8888 == 0) continue;
+						
+						*highreso_buffer = RGBA8888::AlphaBlend(0xFF000000, color_rgba8888, renderLine_BrightFactor).Color;
+						break;
+					
+					case BLENDMODE_ENABLED:
+						if(color_rgba8888 == 0) continue;
+						
+						if(*highreso_buffer == 0)
+							*highreso_buffer = RGBA8888::AlphaBlend(color_rgba8888, background_rgba8888).Color;
+						else
+							*highreso_buffer = RGBA8888::AlphaBlend(color_rgba8888, *highreso_buffer).Color;
+						
+						break;
+					
+					default:
+						if(color_rgba8888 == 0) continue;
+						
+						*highreso_buffer = color_rgba8888 | 0xFF000000;		// Enable Anti-Aliasing有効時に2Dと3Dの境界部分が汚くなる場合がある
+						break;
+				}
+			}
+		}
+	}
+	
+	inline void HighResolutionFramebuffers::SetBackgroundColor(const u32 x, const u16 color_rgb555)
+	{
+		renderLine_BackgroundBuffer[x] = (u32)RGB15TO24_REVERSE(color_rgb555) | 0xFF000000;
+	}
+	
+	template <SOURCELAYER LAYER, BLENDMODE MODE>
+	inline void HighResolutionFramebuffers::SetFinalColor(const u32 dest_x, const u32 source_x, const u16 blended_rgb555, const u16 original_rgb555, const u8 alpha, const u8 layer_num)
+	{
+		assert(layer_num <= 4);		// 0-3:BG, 4:OBJ, 5:Backdrop
+		
+		if(renderLine_SkipHighResolutionRendering) return;
+		
+		bool * const highresoflag_buffer = renderLine_HighResolutionFlagBuffer + dest_x;
+		
+		switch(LAYER)
+		{
+			case SOURCELAYER_3D:
+				#ifdef X432R_LOWQUALITYMODE_TEST
+				if(lowQualityAlphaBlendEnabled)
+				{
+					switch(MODE)
+					{
+						case BLENDMODE_BRIGHTUP:
+						case BLENDMODE_BRIGHTDOWN:
+							SetBackgroundColor(dest_x, blended_rgb555);
+							*highresoflag_buffer = false;
+							return;
+						
+//						case BLENDMODE_ENABLED:
+//							SetFinalColor<LAYER, BLENDMODE_DISABLED, true, false, false>(dest_x, 0, 0, 0, highResolutionBuffer_3D);
+//							return;
+					}
+				}
+				#endif
+				
+				#ifdef X432R_LAYERPOSITIONOFFSET_TEST
+				if(source_x != dest_x)
+					SetFinalColor<LAYER, MODE, true, true, false>(dest_x, source_x, 0, 0, highResolutionBuffer_3D);
+				else
+				#endif
+					SetFinalColor<LAYER, MODE, true, false, false>(dest_x, 0, 0, 0, highResolutionBuffer_3D);
+				
+				*highresoflag_buffer = true;
+				return;
+			
+			case SOURCELAYER_BG:
+				if( (renderLine_VramBufferBG == NULL) || (layer_num != renderLine_HighResolutionBGNum) ) break;
+				
+				#ifdef X432R_LOWQUALITYMODE_TEST
+				if(lowQualityAlphaBlendEnabled)
+				{
+					switch(MODE)
+					{
+						case BLENDMODE_BRIGHTUP:
+						case BLENDMODE_BRIGHTDOWN:
+							SetBackgroundColor(dest_x, blended_rgb555);
+							*highresoflag_buffer = false;
+							return;
+						
+//						case BLENDMODE_ENABLED:
+//							SetFinalColor<LAYER, BLENDMODE_DISABLED, true, false, false>(dest_x, 0, 0, 0, renderLine_VramBufferBG);
+//							return;
+					}
+				}
+				#endif
+				
+				#ifdef X432R_LAYERPOSITIONOFFSET_TEST2
+				if( ( renderLine_HighResolutionBGOffset.BGxX != 0 ) || ( renderLine_HighResolutionBGOffset.BGxY != 0 ) )
+					SetFinalColor<LAYER, MODE, true, true, false>(dest_x, 0, 0, 0, renderLine_VramBufferBG);
+				else
+				#endif
+					SetFinalColor<LAYER, MODE, true, false, false>(dest_x, 0, 0, 0, renderLine_VramBufferBG);
+				
+				*highresoflag_buffer = true;
+				return;
+			
+			case SOURCELAYER_OBJ:
+				if(renderLine_VramBufferOBJ == NULL) break;
+				
+				#ifdef X432R_LOWQUALITYMODE_TEST
+				if(lowQualityAlphaBlendEnabled)
+				{
+					switch(MODE)
+					{
+						case BLENDMODE_BRIGHTUP:
+						case BLENDMODE_BRIGHTDOWN:
+							SetBackgroundColor(dest_x, blended_rgb555);
+							*highresoflag_buffer = false;
+							return;
+						
+//						case BLENDMODE_ENABLED:
+//							SetFinalColor<LAYER, BLENDMODE_DISABLED, true, false, false>(dest_x, 0, 0, 0, renderLine_VramBufferOBJ);
+//							return;
+					}
+				}
+				#endif
+				
+				#ifdef X432R_LAYERPOSITIONOFFSET_TEST2
+				if( ( renderLine_HighResolutionOBJOffset.BGxX != 0 ) || ( renderLine_HighResolutionOBJOffset.BGxY != 0 ) )
+					SetFinalColor<LAYER, MODE, true, true, false>(dest_x, 0, 0, 0, renderLine_VramBufferOBJ);
+				else
+				#endif
+					SetFinalColor<LAYER, MODE, true, false, false>(dest_x, 0, 0, 0, renderLine_VramBufferOBJ);
+				
+				*highresoflag_buffer = true;
+				return;
+		}
+		
+		#ifndef X432R_LOWQUALITYMODE_TEST
+		if( (MODE != BLENDMODE_ENABLED) || !(*highresoflag_buffer) )
+		#else
+		if( (MODE != BLENDMODE_ENABLED) || !(*highresoflag_buffer) || lowQualityAlphaBlendEnabled )
+		#endif
+		{
+			SetBackgroundColor(dest_x, blended_rgb555);
+			*highresoflag_buffer = false;
+		}
+		else if( (LAYER != SOURCELAYER_OBJ) || (alpha == 255) )
+			SetFinalColor<LAYER, MODE, false, false, false>(dest_x, 0, original_rgb555, 0, NULL);
+		else
+			SetFinalColor<LAYER, MODE, false, false, true>(dest_x, 0, original_rgb555, alpha, NULL);
+	}
+	
+	
+	#ifdef X432R_RENDER3D_BILLBOARDCHECK_TEST
+	bool IsNativeResolution2DPolygon(const POLY *poly)
+	{
+//		if( poly->isWireFrame() || ) return false;
+		
+		const VERT * const vertlist = gfx3d.vertlist->list;
+		const u32 vert_count = ( (poly->vtxFormat == GFX3D_QUADS) || (poly->vtxFormat == GFX3D_QUAD_STRIP) ) ? 3 : poly->type;
+		const u16 * const indices = poly->vertIndexes;
+		
+		static const float threshold_xy = 1.0f;
+//		static const float threshold_xy = 0.5f;
+		static const float threshold_z = 0.001f;
+//		static const float threshold_z = 0.0001f;
+		
+		const VERT * vert = vertlist + indices[0];
+		float w = vert->w;
+		float x = (vert->x / vert->w) * (256.0f / 2.0f);
+		float y = (vert->y / vert->w) * (192.0f / 2.0f);
+		float z = (vert->z / vert->w);
+		
+		float x_min = x;
+		float y_min = y;
+		float u_min = vert->u;
+		float v_min = vert->v;
+		
+		float x_max = x;
+		float y_max = y;
+		float u_max = u_min;
+		float v_max = v_min;
+		
+		#if 1
+		for(u32 i = 1; i < vert_count; ++i)
+		{
+			vert = vertlist + indices[i];
+			
+			#if 1
+			if(vert->w != w) return false;
+//			if( abs( (vert->z / w) - z ) >= threshold_z ) return false;
+			
+			x = ( (vert->x) / w ) * (256.0f / 2.0f);
+			y = ( (vert->y) / w ) * (192.0f / 2.0f);
+			#else
+			if( abs( (vert->z / vert->w) - z ) >= threshold_z ) return false;
+			
+			x = ( (vert->x) / vert->w ) * (256.0f / 2.0f);
+			y = ( (vert->y) / vert->w ) * (192.0f / 2.0f);
+			#endif
+			
+			if( ( abs(x_min - x) >= threshold_xy ) && ( abs(x_max - x) >= threshold_xy ) && ( abs(y_min - y) >= threshold_xy ) && ( abs(y_max - y) >= threshold_xy ) ) return false;
+			
+			x_min = std::min(x, x_min);
+			y_min = std::min(y, y_min);
+			u_min = std::min(vert->u, u_min);
+			v_min = std::min(vert->v, v_min);
+			
+			x_max = std::max(x, x_max);
+			y_max = std::max(y, y_max);
+			u_max = std::max(vert->u, u_max);
+			v_max = std::max(vert->v, v_max);
+		}
+		
+		const float polygon_width = (x_max - x_min);
+		const float polygon_height = (y_max - y_min);
+		
+//		const float texture_width = ( 1 << ( ( (poly->texParam >> 20) & 0x07 ) + 3 ) );
+//		const float texture_height = ( 8 << ( (poly->texParam >> 23) & 0x07 ) );
+		const float texture_width = (u_max - u_min);
+		const float texture_height = (v_max - v_min);
+		
+		if( ( abs(polygon_width - texture_width) >= threshold_xy ) || ( abs(polygon_height - texture_height) >= threshold_xy ) ) return false;
+		#else
+		for(u32 i = 1; i < vert_count; ++i)
+		{
+			vert = vertlist + indices[i];
+			
+			#if 1
+			if(vert->w != w) return false;
+//			if( abs( (vert->z / w) - z ) >= threshold_z ) return false;
+			#else
+			if( abs( (vert->z / vert->w) - z ) >= threshold_z ) return false;
+			#endif
+			
+		}
+		#endif
+		
+		
+		// hack: correct vertex position
+		
+/*		for(u32 i = 1; i < vert_count; ++i)
+		{
+			
+		}
+*/		
+		
+		return true;
+	}
+	#endif
+}
+#endif
Index: GPU.h
===================================================================
--- GPU.h	(revision 5164)
+++ GPU.h	(working copy)
@@ -919,5 +919,324 @@
 //#undef FORCEINLINE
 //#define FORCEINLINE __forceinline
 
+
+//---CUSTOM--->
+#include "X432R_BuildSwitch.h"
+
+#ifdef X432R_CUSTOMRENDERER_ENABLED
+#include "MMU.h"
+
+namespace X432R
+{
+	static const u8 BLENDALPHA_MAX = 15;
+	static const u8 BLENDALPHA_MAX2 = 16;
+	
+	extern u8 blendColorTable[BLENDALPHA_MAX + 1][256][256];
+	extern u8 blendColorTable2[BLENDALPHA_MAX2 + 1][BLENDALPHA_MAX2 + 1][256][256];
+	
+	union RGBA8888
+	{
+		private:
+		
+		static inline u8 RGBA8888::GetBlendColor(const u8 color1, const u8 color2, const u8 alpha1)
+		{
+			assert(alpha1 <= BLENDALPHA_MAX);
+			
+			return blendColorTable[alpha1][color1][color2];
+		}
+		
+		static inline u8 RGBA8888::GetBlendColor(const u8 color1, const u8 color2, const u8 alpha1, const u8 alpha2)
+		{
+			assert( (alpha1 <= BLENDALPHA_MAX2) && (alpha2 <= BLENDALPHA_MAX2) );
+			
+			return blendColorTable2[alpha1][alpha2][color1][color2];
+		}
+		
+		
+		public:
+		
+		u32 Color;
+		
+		#ifdef WORDS_BIGENDIAN
+		// todo
+		#else
+		struct
+		{	u8 B, G, R, A;		};
+		#endif
+		
+		
+		RGBA8888()
+		{	Color = 0;			}
+		
+		RGBA8888(const u32 color)
+		{	Color = color;		}
+		
+		
+/*		static inline u16 ToRGB555(RGBA8888 color)
+		{
+			if(color.A == 0) return 0;
+				
+			#ifdef WORDS_BIGENDIAN
+			// todo
+			#else
+			return ( ( (u16)(color.B >> 3) << 10 ) | ( (u16)(color.G >> 3) << 5 ) | (u16)(color.R >> 3) );
+			#endif
+		}
+*/		
+		
+		static void InitBlendColorTable();
+		
+		
+		inline void AlphaBlend(const RGBA8888 foreground_color)
+		{
+			const u8 foreground_alpha = foreground_color.A >> 4;
+			
+			switch(foreground_alpha)
+			{
+				case 0:
+					return;
+				
+				case BLENDALPHA_MAX:
+					Color = foreground_color.Color;
+					return;
+				
+				default:
+//					if( (A >> 4) == 0 )
+					if(A <= 0x0F)
+					{
+						Color = foreground_color.Color;
+						return;
+					}
+					
+					R = GetBlendColor(foreground_color.R, R, foreground_alpha);
+					G = GetBlendColor(foreground_color.G, G, foreground_alpha);
+					B = GetBlendColor(foreground_color.B, B, foreground_alpha);
+					A = 0xFF;
+					
+					return;
+			}
+		}
+		
+		static inline RGBA8888 AlphaBlend(const RGBA8888 foreground_color, RGBA8888 background_color)
+		{
+			background_color.AlphaBlend(foreground_color);
+			
+			return background_color;
+		}
+		
+		static inline RGBA8888 AlphaBlend(const RGBA8888 color1, RGBA8888 color2, const u8 alpha1)
+		{
+			if( (alpha1 == BLENDALPHA_MAX) || (color2.A == 0) ) return color1;
+			if( (alpha1 == 0) || (color1.A == 0) ) return color2;
+			
+			color2.R = GetBlendColor(color1.R, color2.R, alpha1);
+			color2.G = GetBlendColor(color1.G, color2.G, alpha1);
+			color2.B = GetBlendColor(color1.B, color2.B, alpha1);
+			color2.A = 0xFF;
+			
+			return color2;
+		}
+		
+		static inline RGBA8888 AlphaBlend(const RGBA8888 color1, const RGBA8888 color2, const u8 alpha1, const u8 alpha2)
+		{
+			if(color2.A == 0) return color1;
+			if(color1.A == 0) return color2;
+			
+			RGBA8888 result;
+			
+			result.R = GetBlendColor(color1.R, color2.R, alpha1, alpha2);
+			result.G = GetBlendColor(color1.G, color2.G, alpha1, alpha2);
+			result.B = GetBlendColor(color1.B, color2.B, alpha1, alpha2);
+			result.A = 0xFF;
+		
+			return result;
+		}
+	};
+	
+	
+	static enum SOURCELAYER
+	{
+		SOURCELAYER_NONE, SOURCELAYER_BG, SOURCELAYER_3D, SOURCELAYER_OBJ
+	};
+	
+	static enum BLENDMODE
+	{
+		BLENDMODE_DISABLED, BLENDMODE_ENABLED, BLENDMODE_BRIGHTUP, BLENDMODE_BRIGHTDOWN
+	};
+	
+	class HighResolutionFramebuffers
+	{
+		public:
+		
+		HighResolutionFramebuffers();
+		void Clear();
+		
+		
+		inline bool IsCurrentFrameRendered()
+		{	return currentFrameRendered;								}
+		
+		inline bool IsHighResolutionRenderingDisabled()
+		{	return (currentRenderMagnification == 1);					}
+		
+		inline bool IsHighResolutionRenderingSkipped()
+		{	return renderLine_SkipHighResolutionRendering;				}
+		
+		inline u32 * GetHighResolution3DBuffer()
+		{	return highResolutionBuffer_3D;								}
+		
+		#ifdef X432R_DISPCAPTURE_MAINMEMORYFIFO_TEST
+		inline u32 * GetCurrentMainMemoryFIFOBuffer()
+		{	return renderLine_MainMemoryFIFOBuffer;						}
+		#endif
+		
+		
+		void UpdateGpuParams();
+		
+		template <u32 RENDER_MAGNIFICATION>
+		void UpdateFrontBufferAndDisplayCapture(u32 * const front_buffer, u32 * const master_brightness, bool * const is_highreso_screen);
+		
+		
+		void UpdateRenderLineParams(const NDS_Screen * const screen, u32 y);
+		void SetBackdropColor(const u16 backdrop_rgb555);
+		
+		template <SOURCELAYER LAYER, BLENDMODE MODE>
+		void SetFinalColor(const u32 dest_x, const u32 source_x, const u16 blended_rgb555, const u16 original_rgb555, const u8 alpha, const u8 layer_num);
+		
+		
+		//--------------------
+		
+		private:
+		
+		u32 highResolutionBuffer_3D[1024 * 768];
+		u32 highResolutionBuffer_Vram[4][1024 * 768];
+		
+		u32 highResolutionBuffer_Final[1024 * 768 * 2];
+		u32 backgroundBuffer[256 * 192 * 2];
+		bool highResolutionFlagBuffer[256 * 192 * 2];
+		
+		#ifdef X432R_DISPCAPTURE_MAINMEMORYFIFO_TEST
+		u32 MainMemoryFIFOBuffer[256 * 192];
+		#endif
+		
+		u32 currentRenderMagnification;
+		u32 currentRenderWidth;
+		u32 currentRenderHeight;
+		
+		u8 mainScreenIndex;
+		u8 subScreenIndex;
+		u8 mainGpuDisplayMode;
+		u8 subGpuDisplayMode;
+		
+		u8 displayCaptureWriteBlockIndex;
+		u8 displayCaptureReadBlockIndex;
+		u8 displayCaptureSourceA;
+		u8 displayCaptureSourceB;
+		u8 displayCaptureBlendingRatioA;
+		u8 displayCaptureBlendingRatioB;
+		u32 displayCaptureWriteOffset[4];
+		
+		u8 vramBlockMainScreen;
+		
+		u8 vramBlockBG[2];
+		u8 vramBlockOBJ[2];
+		u8 highResolutionBGNum[2];
+		
+		u32 masterBrightness[2];
+		
+		BGxPARMS highResolutionBGOffset[2];
+		BGxPARMS highResolutionOBJOffset[2];
+		bool highResolutionOBJFlipX[2];
+		bool highResolutionOBJFlipY[2];
+		
+		VramConfiguration::Purpose vramPurpose[4];
+		bool vramIsValid[4];
+		bool skipHighResolutionRendering[2];
+		bool mainGpuBG03DEnabled;
+		bool currentFrameRendered;
+		
+		#ifdef X432R_SAMPLEDVRAMDATACHECK_TEST
+		u16 vramSampledPixelData[4][9];
+		#endif
+		
+		#ifdef X432R_3D_REARPLANE_TEST
+		bool rearPlane3DEnabled;
+		bool vramBankControl_VramEnabled[4];
+		u8 vramBankControl_VramMST[4];
+		u8 vramBankControl_VramOffset[4];
+		#endif
+		
+		
+		void ClearVramBuffer(const u8 vram_block);
+		
+		void UpdateMasterBrightness();
+		
+		bool IsVramValid(const u8 vram_block);
+		#ifdef X432R_SAMPLEDVRAMDATACHECK_TEST
+		void GetSampledVramPixelData(u16 * const sampled_data, const u8 vram_block);		// temp
+		#endif
+		
+		bool CheckOBJParams(const GPU * const gpu, const _DISPCNT * const display_control, const u32 screen_index, const u32 dispcapture_offset);
+		bool CheckBGParams(const GPU * const gpu, const u32 layer_num);
+		bool UpdateHighResolutionBGNum(const GPU * const gpu, const _DISPCNT * const display_control, const u32 screen_index);
+		
+		#if !defined(X432R_LAYERPOSITIONOFFSET_TEST2) || !defined(X432R_HIGHRESO_BG_OBJ_ROTSCALE_TEST)
+		bool CheckBGOffset(const u32 screen_index);
+		bool CheckOBJOffset(const u32 screen_index);
+		#endif
+		
+		void UpdateDisplayCaptureParams(DISPCAPCNT params);
+		
+		template <u32 RENDER_MAGNIFICATION, bool HIGHRESO, u8 CAPTURESOURCE_A, u8 CAPTURESOURCE_B, u8 GPU_DISPLAYMODE>
+		void UpdateFrontBufferAndDisplayCapture(u32 * const front_buffer, const u32 screen_index);
+		
+		template <u32 RENDER_MAGNIFICATION>
+		void UpdateFrontBuffer(u32 *front_buffer, const u32 screen_index);
+		
+		
+		//--------------------
+		// RenderLine
+		
+		bool renderLine_SkipHighResolutionRendering;
+		u32 renderLine_ScreenIndex;
+		u32 renderLine_CurrentY;
+		u32 renderLine_HighResolutionYBegin;
+		u32 renderLine_HighResolutionYEnd;
+		
+		u8 renderLine_BrightFactor;
+		u8 renderLine_BlendAlphaA;
+		u8 renderLine_BlendAlphaB;
+		
+		u32 *renderLine_HighResolutionFinalBuffer;
+		u32 *renderLine_BackgroundBuffer;
+		bool *renderLine_HighResolutionFlagBuffer;
+		
+		u32 *renderLine_VramBufferBG;
+		u32 *renderLine_VramBufferOBJ;
+		u8 renderLine_HighResolutionBGNum;
+		
+		#ifdef X432R_DISPCAPTURE_MAINMEMORYFIFO_TEST
+		u32 *renderLine_MainMemoryFIFOBuffer;
+		#endif
+		
+		#if defined(X432R_LAYERPOSITIONOFFSET_TEST2) || defined(X432R_HIGHRESO_BG_OBJ_ROTSCALE_TEST)
+		BGxPARMS *renderLine_HighResolutionBGOffset;
+		BGxPARMS *renderLine_HighResolutionOBJOffset;
+		bool renderLine_HighResolutionOBJFlipX;
+		bool renderLine_HighResolutionOBJFlipY;
+		#endif
+		
+		
+		template <SOURCELAYER LAYER, BLENDMODE MODE, bool HIGHRESO, bool LAYER_OFFSET, bool USE_ALPHA>
+		void SetFinalColor(const u32 dest_x, const u32 source_x, const u16 color_rgb555, u8 alpha, const u32 * const source_buffer);
+		
+		void SetBackgroundColor(const u32 x, const u16 color_rgb555);
+	};
+	
+	extern HighResolutionFramebuffers backBuffer;
+}
 #endif
+//<---CUSTOM---
 
+
+#endif
+
Index: GPU_osd.h
===================================================================
--- GPU_osd.h	(revision 5164)
+++ GPU_osd.h	(working copy)
@@ -27,6 +27,12 @@
 
 #include "aggdraw.h"
 
+
+//---CUSTOM--->
+#include "X432R_BuildSwitch.h"
+//<---CUSTOM---
+
+
 #define OSD_MAX_LINES 4
 #define OSD_TIMER_SECS 2
 
@@ -120,6 +126,11 @@
 	void	addLine(const char *fmt, ...);
 	void	addFixed(u16 x, u16 y, const char *fmt, ...);
 	void	border(bool enabled);
+	
+	#ifdef X432R_CUSTOMRENDERER_ENABLED
+	inline u8 GetLineCount()
+	{	return lastLineText;			};
+	#endif
 };
 
 extern OSDCLASS	*osd;
Index: movie.cpp
===================================================================
--- movie.cpp	(revision 5164)
+++ movie.cpp	(working copy)
@@ -1025,6 +1025,10 @@
 			{
 			   osd->setLineColor(255, 0, 0);
 			   osd->addLine("Can't save movie file!");
+			
+				#ifdef X432R_MENUITEMMOD_ENABLED
+				osd->setLineColor(255, 255, 255);
+				#endif
 			}
 
 			//printf("DUMPING MOVIE: %d FRAMES\n",currMovieData.records.size());
Index: OGLRender.cpp
===================================================================
--- OGLRender.cpp	(revision 5164)
+++ OGLRender.cpp	(working copy)
@@ -148,6 +148,16 @@
 OGLEXT(PFNGLRENDERBUFFERSTORAGEMULTISAMPLEEXTPROC, glRenderbufferStorageMultisampleEXT)
 OGLEXT(PFNGLDELETERENDERBUFFERSEXTPROC, glDeleteRenderbuffersEXT)
 
+#ifdef X432R_CUSTOMRENDERER_ENABLED
+//OGLEXT(PFNGLGETBUFFERSUBDATAPROC, glGetBufferSubData)	// Core in v1.5 (for PBO: v2.1)
+#ifdef X432R_OPENGL_FOG_ENABLED
+OGLEXT(PFNGLUNIFORM1FVPROC, glUniform1fv)				// Core in v2.0
+#endif
+#ifdef X432R_OPENGL_CUSTOMFRAMEBUFFEROPERATION_TEST2
+OGLEXT(PFNGLCLEARBUFFERFVPROC, glClearBufferfv)		// v3.0
+#endif
+#endif
+
 static void OGLLoadEntryPoints_Legacy()
 {
 	// Textures
@@ -225,6 +235,16 @@
 	INITOGLEXT(PFNGLRENDERBUFFERSTORAGEEXTPROC, glRenderbufferStorageEXT)
 	INITOGLEXT(PFNGLRENDERBUFFERSTORAGEMULTISAMPLEEXTPROC, glRenderbufferStorageMultisampleEXT)
 	INITOGLEXT(PFNGLDELETERENDERBUFFERSEXTPROC, glDeleteRenderbuffersEXT)
+
+	#ifdef X432R_CUSTOMRENDERER_ENABLED
+//	INITOGLEXT(PFNGLGETBUFFERSUBDATAPROC, glGetBufferSubData)	// Core in v1.5 (for PBO: v2.1)
+	#ifdef X432R_OPENGL_FOG_ENABLED
+	INITOGLEXT(PFNGLUNIFORM1FVPROC, glUniform1fv)				// Core in v2.0
+	#endif
+	#ifdef X432R_OPENGL_CUSTOMFRAMEBUFFEROPERATION_TEST2
+	INITOGLEXT(PFNGLCLEARBUFFERFVPROC, glClearBufferfv)		// v3.0
+	#endif
+	#endif
 }
 
 // Vertex Shader GLSL 1.00
@@ -2920,3 +2940,2397 @@
 	
 	return OGLERROR_NOERR;
 }
+
+
+#ifdef X432R_CUSTOMRENDERER_ENABLED
+#include "GPU.h"
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1700)
+#ifdef X432R_PPL_TEST
+#include <ppl.h>
+#elif defined(X432R_CPP_AMP_TEST)
+#include <amp.h>
+#endif
+#endif
+
+namespace X432R
+{
+	#ifdef X432R_OPENGL_CUSTOMFRAMEBUFFEROPERATION_TEST
+	enum
+	{
+		OGLTextureUnitID_RenderTarget_Color = OGLTextureUnitID_ClearImage + 1,
+		OGLTextureUnitID_RenderTarget_DepthStencil,
+		OGLRequiredTextureUnitCount
+	};
+	#endif
+	
+	#ifdef X432R_RENDER3D_BILLBOARDCHECK_TEST
+	bool IsNativeResolution2DPolygon(const POLY *poly);
+	#endif
+	
+	
+/*	bool CheckOpenGLExtensionSupported(std::string extension_name)
+	{
+		if( (oglrender_init == NULL) || !oglrender_init() ) return false;
+		
+		static std::set<std::string> supportedOpenGLExtensions;
+		
+		if( supportedOpenGLExtensions.size() == 0 )
+		{
+			std::string oglExtensionString = std::string( (const char *)glGetString(GL_EXTENSIONS) );
+			
+			size_t start_location = 0;
+			size_t delimiter_location = oglExtensionString.find_first_of(' ', start_location);
+			std::string extension_name;
+			
+			while(delimiter_location != std::string::npos)
+			{
+				extension_name = oglExtensionString.substr(start_location, delimiter_location - start_location);
+				supportedOpenGLExtensions.insert(extension_name);
+				
+				start_location = delimiter_location + 1;
+				delimiter_location = oglExtensionString.find_first_of(' ', start_location);
+			}
+			
+			if( ( start_location - oglExtensionString.length() ) > 0 )
+			{
+				extension_name = oglExtensionString.substr( start_location, ( oglExtensionString.length() - start_location) );
+				supportedOpenGLExtensions.insert(extension_name);
+			}
+		}
+		
+		if( supportedOpenGLExtensions.size() == 0 )
+			return false;
+		
+		return ( supportedOpenGLExtensions.find(extension_name) != supportedOpenGLExtensions.end() );
+	}
+	
+	bool CheckOpenGLExtensionSupported_PBO()
+	{
+		#if	!defined(GL_ARB_pixel_buffer_object) && !defined(GL_EXT_pixel_buffer_object)
+		return false;
+		#else
+		return ( CheckOpenGLExtensionSupported("GL_ARB_vertex_buffer_object") || CheckOpenGLExtensionSupported("GL_ARB_pixel_buffer_object") || CheckOpenGLExtensionSupported("GL_EXT_pixel_buffer_object") );
+		#endif
+	}
+*/	
+	
+	
+	template <u32 RENDER_MAGNIFICATION>
+	static char OGLInit(void)
+	{
+		X432R_STATIC_RENDER_MAGNIFICATION_CHECK();
+		
+		ClearBuffers();
+		
+		
+		char result = 0;
+		Render3DError error = OGLERROR_NOERR;
+		
+		if( (oglrender_init == NULL) || !oglrender_init() )
+			return result;
+		
+		result = Default3D_Init();
+		
+		if(result == 0)
+			return result;
+		
+		if( !BEGINGL() )
+		{
+			INFO("OpenGL 2.1: Could not initialize -- BEGINGL() failed.\n");
+			result = 0;
+			return result;
+		}
+		
+		// Get OpenGL info
+		const char *oglVersionString = (const char *)glGetString(GL_VERSION);
+		const char *oglVendorString = (const char *)glGetString(GL_VENDOR);
+		const char *oglRendererString = (const char *)glGetString(GL_RENDERER);
+		
+		// Writing to gl_FragDepth causes the driver to fail miserably on systems equipped 
+		// with a Intel G965 graphic card. Warn the user and fail gracefully.
+		// http://forums.desmume.org/viewtopic.php?id=9286
+		if(!strcmp(oglVendorString,"Intel") && strstr(oglRendererString,"965")) 
+		{
+			INFO("Incompatible graphic card detected. Disabling OpenGL support.\n");
+			result = 0;
+			return result;
+		}
+		
+		// Check the driver's OpenGL version
+		OGLGetDriverVersion(oglVersionString, &_OGLDriverVersion.major, &_OGLDriverVersion.minor, &_OGLDriverVersion.revision);
+		
+		// If the renderer doesn't initialize with OpenGL v3.2 or higher, fall back
+		// to one of the lower versions.
+		OGLLoadEntryPoints_Legacy();
+		
+		OpenGLRenderer_X432 *renderer = NULL;
+		
+		if( IsVersionSupported(2, 1, 0) )
+		{
+			renderer = new OpenGLRenderer_X432();
+			renderer->SetVersion(2, 1, 0);
+			
+			_OGLRenderer = renderer;
+		}
+		
+		if(renderer == NULL)
+		{
+			INFO("OpenGL 2.1: Renderer did not initialize. Disabling 3D renderer.\n");
+			result = 0;
+			return result;
+		}
+		
+		// Initialize OpenGL extensions
+		error = renderer->InitExtensions<RENDER_MAGNIFICATION>();
+		
+		if(error != OGLERROR_NOERR)
+		{
+			if( IsVersionSupported(2, 0, 0) &&
+				( (error == OGLERROR_SHADER_CREATE_ERROR) ||
+				  (error == OGLERROR_VERTEX_SHADER_PROGRAM_LOAD_ERROR) ||
+				  (error == OGLERROR_FRAGMENT_SHADER_PROGRAM_LOAD_ERROR) ) )
+			{
+				INFO("OpenGL: Shaders are not working, even though they should be. Disabling 3D renderer.\n");
+				result = 0;
+				return result;
+			}
+			else if( IsVersionSupported(3, 0, 0) && (error == OGLERROR_FBO_CREATE_ERROR) && (OGLLoadEntryPoints_3_2_Func != NULL) )
+			{
+				INFO("OpenGL: FBOs are not working, even though they should be. Disabling 3D renderer.\n");
+				result = 0;
+				return result;
+			}
+		}
+		
+		// Initialization finished -- reset the renderer
+		renderer->Reset();
+		
+		ENDGL();
+		
+		INFO("OpenGL 2.1: Renderer initialized successfully\n");
+		
+		return result;
+	}
+	
+	template <u32 RENDER_MAGNIFICATION>
+	static void OGLRender()
+	{
+		X432R_STATIC_RENDER_MAGNIFICATION_CHECK();
+		
+		if( !BEGINGL() ) return;
+		
+		#ifdef X432R_PROCESSTIME_CHECK
+		AutoStopTimeCounter timecounter(timeCounter_3D);
+		#endif
+		
+		OpenGLRenderer_X432 *renderer = dynamic_cast<OpenGLRenderer_X432 *>(_OGLRenderer);
+		
+		if(renderer != NULL)
+			renderer->Render<RENDER_MAGNIFICATION>(&gfx3d.renderState, gfx3d.vertlist, gfx3d.polylist, &gfx3d.indexlist, gfx3d.frameCtr);
+		
+		ENDGL();
+	}
+	
+	template <u32 RENDER_MAGNIFICATION>
+	static void OGLRenderFinish()
+	{
+		X432R_STATIC_RENDER_MAGNIFICATION_CHECK();
+		
+		if( !BEGINGL() ) return;
+		
+		OpenGLRenderer_X432 *renderer = dynamic_cast<OpenGLRenderer_X432 *>(_OGLRenderer);
+		
+		if(renderer != NULL)
+			renderer->RenderFinish<RENDER_MAGNIFICATION>();
+		
+		ENDGL();
+	}
+	
+	
+	OpenGLRenderer_X432::OpenGLRenderer_X432()
+	{
+		highResolutionFramebuffer = 0;
+		highResolutionRenderbuffer_Color = 0;
+		highResolutionRenderbuffer_DepthStencil = 0;
+		
+		#ifdef X432R_OPENGL_FOG_ENABLED
+		uniformFogEnabled = 0;
+		uniformFogOffset = 0;
+		uniformFogStep = 0;
+		uniformFogDensity = 0;
+		#endif
+		
+		#ifdef X432R_OPENGL_CUSTOMFRAMEBUFFEROPERATION_TEST
+		uniformFogAlphaOnly = 0;
+		uniformAlphaBlendEnabled = 0;
+		
+		uniformIsNativeResolution2DPolygon = 0;
+		#endif
+		
+		#ifdef X432R_OPENGL_CUSTOMFRAMEBUFFEROPERATION_TEST2
+		uniformDepthComparisionThreshold = 0;
+		uniformAlphaDepthWriteEnabled = 0;
+		#endif
+	}
+	
+	template <u32 RENDER_MAGNIFICATION>
+	Render3DError OpenGLRenderer_X432::CreatePBOs()
+	{
+		OGLRenderRef &OGLRef = *this->ref;
+		
+		glGenBuffers(2, OGLRef.pboRenderDataID);
+		
+		for (unsigned int i = 0; i < 2; i++)
+		{
+			glBindBuffer( GL_PIXEL_PACK_BUFFER, OGLRef.pboRenderDataID[i] );
+			glBufferData( GL_PIXEL_PACK_BUFFER, sizeof(u32) * 256 * 192 * RENDER_MAGNIFICATION * RENDER_MAGNIFICATION, NULL, GL_STREAM_READ );
+		}
+		
+		glBindBuffer(GL_PIXEL_PACK_BUFFER, 0);
+		
+		return OGLERROR_NOERR;
+	}
+	
+	void OpenGLRenderer_X432::DestroyPBOs()
+	{
+//		if( !this->isPBOSupported ) return;
+		
+		glBindBuffer(GL_PIXEL_PACK_BUFFER, 0);
+		glDeleteBuffers(2, this->ref->pboRenderDataID);
+		
+		this->isPBOSupported = false;
+	}
+	
+	template <u32 RENDER_MAGNIFICATION>
+	Render3DError OpenGLRenderer_X432::CreateFBOs()
+	{
+		OGLRenderRef &OGLRef = *this->ref;
+		
+		
+		#ifdef X432R_CUSTOMRENDERER_CLEARIMAGE_ENABLED
+		// Set up FBO render targets
+		glGenTextures(1, &OGLRef.texClearImageColorID);
+		glGenTextures(1, &OGLRef.texClearImageDepthStencilID);
+		
+		glBindTexture(GL_TEXTURE_2D, OGLRef.texClearImageColorID);
+		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
+		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
+		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
+		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
+		glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, GFX3D_FRAMEBUFFER_WIDTH, GFX3D_FRAMEBUFFER_HEIGHT, 0, GL_RGBA, GL_UNSIGNED_INT_8_8_8_8_REV, NULL);
+		
+		glBindTexture(GL_TEXTURE_2D, OGLRef.texClearImageDepthStencilID);
+		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
+		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
+		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
+		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
+		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_COMPARE_MODE, GL_NONE);
+		glTexImage2D(GL_TEXTURE_2D, 0, GL_DEPTH24_STENCIL8_EXT, GFX3D_FRAMEBUFFER_WIDTH, GFX3D_FRAMEBUFFER_HEIGHT, 0, GL_DEPTH_STENCIL_EXT, GL_UNSIGNED_INT_24_8_EXT, NULL);
+		
+		glBindTexture(GL_TEXTURE_2D, 0);
+		
+		// Set up FBOs
+		glGenFramebuffersEXT(1, &OGLRef.fboClearImageID);
+		
+		glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, OGLRef.fboClearImageID);
+		glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT0_EXT, GL_TEXTURE_2D, OGLRef.texClearImageColorID, 0);
+		glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_DEPTH_ATTACHMENT_EXT, GL_TEXTURE_2D, OGLRef.texClearImageDepthStencilID, 0);
+		glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_STENCIL_ATTACHMENT_EXT, GL_TEXTURE_2D, OGLRef.texClearImageDepthStencilID, 0);
+		
+		if( glCheckFramebufferStatusEXT(GL_FRAMEBUFFER_EXT) != GL_FRAMEBUFFER_COMPLETE_EXT )
+		{
+			INFO("OpenGL: Failed to created FBOs. Some emulation features will be disabled.\n");
+			
+			glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0);
+			glDeleteFramebuffersEXT(1, &OGLRef.fboClearImageID);
+			glDeleteTextures(1, &OGLRef.texClearImageColorID);
+			glDeleteTextures(1, &OGLRef.texClearImageDepthStencilID);
+			
+			this->isFBOSupported = false;
+			return OGLERROR_FBO_CREATE_ERROR;
+		}
+		#endif
+		
+		
+		// 高解像度3Dレンダリング用FBO作成
+		#ifndef X432R_OPENGL_CUSTOMFRAMEBUFFEROPERATION_TEST
+		glGenRenderbuffersEXT(1, &highResolutionRenderbuffer_Color);
+		glBindRenderbufferEXT(GL_RENDERBUFFER_EXT, highResolutionRenderbuffer_Color);
+		glRenderbufferStorageEXT(GL_RENDERBUFFER_EXT, GL_RGBA, 256 * RENDER_MAGNIFICATION, 192 * RENDER_MAGNIFICATION);
+		
+		glBindRenderbufferEXT(GL_RENDERBUFFER_EXT, 0);
+		#else
+		glGenTextures(1, &highResolutionRenderbuffer_Color);
+		glBindTexture(GL_TEXTURE_2D, highResolutionRenderbuffer_Color);
+		glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, 256 * RENDER_MAGNIFICATION, 192 * RENDER_MAGNIFICATION, 0, GL_BGRA, GL_UNSIGNED_BYTE, NULL);
+		
+		glBindTexture(GL_TEXTURE_2D, 0);
+		#endif
+		
+		#ifndef X432R_OPENGL_CUSTOMFRAMEBUFFEROPERATION_TEST2
+		glGenRenderbuffersEXT(1, &highResolutionRenderbuffer_DepthStencil);
+		glBindRenderbufferEXT(GL_RENDERBUFFER_EXT, highResolutionRenderbuffer_DepthStencil);
+		glRenderbufferStorageEXT(GL_RENDERBUFFER_EXT, GL_DEPTH24_STENCIL8_EXT, 256 * RENDER_MAGNIFICATION, 192 * RENDER_MAGNIFICATION);
+		
+		glBindRenderbufferEXT(GL_RENDERBUFFER_EXT, 0);
+		#else
+		glGenTextures(1, &highResolutionRenderbuffer_DepthStencil);
+		glBindTexture(GL_TEXTURE_2D, highResolutionRenderbuffer_DepthStencil);
+		glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA32F, 256 * RENDER_MAGNIFICATION, 192 * RENDER_MAGNIFICATION, 0, GL_BGRA, GL_FLOAT, NULL);
+		
+		glBindTexture(GL_TEXTURE_2D, 0);
+		#endif
+		
+		
+		glGenFramebuffersEXT(1, &highResolutionFramebuffer);
+		
+		glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, highResolutionFramebuffer);
+		#ifndef X432R_OPENGL_CUSTOMFRAMEBUFFEROPERATION_TEST
+		glFramebufferRenderbufferEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT0_EXT, GL_RENDERBUFFER_EXT, highResolutionRenderbuffer_Color);
+		#else
+		glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT0_EXT, GL_TEXTURE_2D, highResolutionRenderbuffer_Color, 0);
+		#endif
+		#ifndef X432R_OPENGL_CUSTOMFRAMEBUFFEROPERATION_TEST2
+		glFramebufferRenderbufferEXT(GL_FRAMEBUFFER_EXT, GL_DEPTH_ATTACHMENT_EXT, GL_RENDERBUFFER_EXT, highResolutionRenderbuffer_DepthStencil);
+		glFramebufferRenderbufferEXT(GL_FRAMEBUFFER_EXT, GL_STENCIL_ATTACHMENT_EXT, GL_RENDERBUFFER_EXT, highResolutionRenderbuffer_DepthStencil);
+		#else
+		glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT1_EXT, GL_TEXTURE_2D, highResolutionRenderbuffer_DepthStencil, 0);
+		#endif
+		
+		
+		if( glCheckFramebufferStatusEXT(GL_FRAMEBUFFER_EXT) != GL_FRAMEBUFFER_COMPLETE_EXT )
+		{
+			INFO("OpenGL: Failed to created FBOs. Some emulation features will be disabled.\n");
+			
+			glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0);
+			
+			glDeleteFramebuffersEXT(1, &highResolutionFramebuffer);
+			
+			#ifndef X432R_OPENGL_CUSTOMFRAMEBUFFEROPERATION_TEST
+			glDeleteRenderbuffersEXT(1, &highResolutionRenderbuffer_Color);
+			#else
+			glDeleteTextures(1, &highResolutionRenderbuffer_Color);
+			#endif
+			#ifndef X432R_OPENGL_CUSTOMFRAMEBUFFEROPERATION_TEST2
+			glDeleteRenderbuffersEXT(1, &highResolutionRenderbuffer_DepthStencil);
+			#else
+			glDeleteTextures(1, &highResolutionRenderbuffer_DepthStencil);
+			#endif
+			
+			this->isFBOSupported = false;
+			return OGLERROR_FBO_CREATE_ERROR;
+		}
+		
+		
+		#ifdef X432R_OPENGL_CUSTOMFRAMEBUFFEROPERATION_TEST
+		glActiveTexture(GL_TEXTURE0 + OGLTextureUnitID_RenderTarget_Color);
+		glBindTexture(GL_TEXTURE_2D, highResolutionRenderbuffer_Color);
+		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
+		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
+		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
+		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
+		glUniform1i( glGetUniformLocation(OGLRef.shaderProgram, "renderTargetTexture_Color"), OGLTextureUnitID_RenderTarget_Color );
+		
+		#ifdef X432R_OPENGL_CUSTOMFRAMEBUFFEROPERATION_TEST2
+		glActiveTexture(GL_TEXTURE0 + OGLTextureUnitID_RenderTarget_DepthStencil);
+		glBindTexture(GL_TEXTURE_2D, highResolutionRenderbuffer_DepthStencil);
+		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
+		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
+		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
+		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
+		glUniform1i( glGetUniformLocation(OGLRef.shaderProgram, "renderTargetTexture_DepthStencil"), OGLTextureUnitID_RenderTarget_DepthStencil );
+		#endif
+		
+		glActiveTexture(GL_TEXTURE0);
+		#endif
+		
+		
+		// Set up final output FBO
+		OGLRef.fboRenderID = 0;
+		glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, OGLRef.fboRenderID);
+		
+		INFO("OpenGL: Successfully created FBOs.\n");
+		
+		return OGLERROR_NOERR;
+	}
+	
+	void OpenGLRenderer_X432::DestroyFBOs()
+	{
+		if( !this->isFBOSupported ) return;
+		
+		glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0);
+		
+		
+		#ifdef X432R_CUSTOMRENDERER_CLEARIMAGE_ENABLED
+		OGLRenderRef &OGLRef = *this->ref;
+		
+		glDeleteFramebuffersEXT(1, &OGLRef.fboClearImageID);
+		glDeleteTextures(1, &OGLRef.texClearImageColorID);
+		glDeleteTextures(1, &OGLRef.texClearImageDepthStencilID);
+		#endif
+		
+		
+		#ifndef X432R_OPENGL_CUSTOMFRAMEBUFFEROPERATION_TEST
+		glDeleteFramebuffersEXT(1, &highResolutionFramebuffer);
+		glDeleteRenderbuffersEXT(1, &highResolutionRenderbuffer_Color);
+		glDeleteRenderbuffersEXT(1, &highResolutionRenderbuffer_DepthStencil);
+		#else
+		glActiveTexture(GL_TEXTURE0 + OGLTextureUnitID_RenderTarget_Color);
+		glBindTexture(GL_TEXTURE_2D, 0);
+		
+		#ifdef X432R_OPENGL_CUSTOMFRAMEBUFFEROPERATION_TEST2
+		glActiveTexture(GL_TEXTURE0 + OGLTextureUnitID_RenderTarget_DepthStencil);
+		glBindTexture(GL_TEXTURE_2D, 0);
+		
+		glDeleteTextures(1, &highResolutionRenderbuffer_DepthStencil);
+		#endif
+		
+		glActiveTexture(GL_TEXTURE0);
+		
+		glDeleteFramebuffersEXT(1, &highResolutionFramebuffer);
+		glDeleteTextures(1, &highResolutionRenderbuffer_Color);
+		#endif
+		
+		highResolutionFramebuffer = 0;
+		highResolutionRenderbuffer_Color = 0;
+		highResolutionRenderbuffer_DepthStencil = 0;
+		
+		this->isFBOSupported = false;
+	}
+	
+	template <u32 RENDER_MAGNIFICATION>
+	Render3DError OpenGLRenderer_X432::CreateMultisampledFBO()
+	{
+		// Check the maximum number of samples that the driver supports and use that.
+		// Since our target resolution is only 256x192 pixels, using the most samples
+		// possible is the best thing to do.
+		GLint msaa_samples = 0;
+		
+		glGetIntegerv(GL_MAX_SAMPLES_EXT, &msaa_samples);
+		
+		if(msaa_samples < 2)
+		{
+			INFO("OpenGL: Driver does not support at least 2x multisampled FBOs. Multisample antialiasing will be disabled.\n");
+			return OGLERROR_FEATURE_UNSUPPORTED;
+		}
+		
+		#ifndef X432R_LOWQUALITYMODE_TEST
+		if(msaa_samples > OGLRENDER_MAX_MULTISAMPLES)
+			msaa_samples = OGLRENDER_MAX_MULTISAMPLES;
+		#else
+		#ifdef X432R_CUSTOMRENDERER_DEBUG
+		const u32 max_samples = msaa_samples;
+		#endif
+		
+		if(lowQualityMsaaEnabled)
+		{
+			if(msaa_samples > 4)
+				msaa_samples = 4;
+			
+			else if(msaa_samples > 2)
+				msaa_samples = 2;
+		}
+		else if(msaa_samples > OGLRENDER_MAX_MULTISAMPLES)
+			msaa_samples = OGLRENDER_MAX_MULTISAMPLES;
+		
+		#ifdef X432R_CUSTOMRENDERER_DEBUG
+		ShowDebugMessage( "MSAA Samples: " + std::to_string(msaa_samples) + " (max:" + std::to_string(max_samples) + ")" );
+		#endif
+		#endif
+		
+		OGLRenderRef &OGLRef = *this->ref;
+		
+		// Set up FBO render targets
+		glGenRenderbuffersEXT(1, &OGLRef.rboMSFragColorID);
+		glGenRenderbuffersEXT(1, &OGLRef.rboMSFragDepthStencilID);
+		
+		glBindRenderbufferEXT(GL_RENDERBUFFER_EXT, OGLRef.rboMSFragColorID);
+		glRenderbufferStorageMultisampleEXT(GL_RENDERBUFFER_EXT, msaa_samples, GL_RGBA, 256 * RENDER_MAGNIFICATION, 192 * RENDER_MAGNIFICATION);
+		glBindRenderbufferEXT(GL_RENDERBUFFER_EXT, OGLRef.rboMSFragDepthStencilID);
+		glRenderbufferStorageMultisampleEXT(GL_RENDERBUFFER_EXT, msaa_samples, GL_DEPTH24_STENCIL8_EXT, 256 * RENDER_MAGNIFICATION, 192 * RENDER_MAGNIFICATION);
+		
+		// Set up multisampled rendering FBO
+		glGenFramebuffersEXT(1, &OGLRef.fboMSIntermediateRenderID);
+		
+		glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, OGLRef.fboMSIntermediateRenderID);
+		glFramebufferRenderbufferEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT0_EXT, GL_RENDERBUFFER_EXT, OGLRef.rboMSFragColorID);
+		glFramebufferRenderbufferEXT(GL_FRAMEBUFFER_EXT, GL_DEPTH_ATTACHMENT_EXT, GL_RENDERBUFFER_EXT, OGLRef.rboMSFragDepthStencilID);
+		glFramebufferRenderbufferEXT(GL_FRAMEBUFFER_EXT, GL_STENCIL_ATTACHMENT_EXT, GL_RENDERBUFFER_EXT, OGLRef.rboMSFragDepthStencilID);
+		
+		if( glCheckFramebufferStatusEXT(GL_FRAMEBUFFER_EXT) != GL_FRAMEBUFFER_COMPLETE_EXT )
+		{
+			INFO("OpenGL: Failed to create multisampled FBO. Multisample antialiasing will be disabled.\n");
+			
+			glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0);
+			glDeleteFramebuffersEXT(1, &OGLRef.fboMSIntermediateRenderID);
+			glDeleteRenderbuffersEXT(1, &OGLRef.rboMSFragColorID);
+			glDeleteRenderbuffersEXT(1, &OGLRef.rboMSFragDepthStencilID);
+			
+			return OGLERROR_FBO_CREATE_ERROR;
+		}
+		
+		glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0);
+		INFO("OpenGL: Successfully created multisampled FBO.\n");
+		
+		return OGLERROR_NOERR;
+	}
+	
+	void OpenGLRenderer_X432::DestroyMultisampledFBO()
+	{
+		if( !this->isMultisampledFBOSupported ) return;
+		
+		OGLRenderRef &OGLRef = *this->ref;
+		
+		glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0);
+		glDeleteFramebuffersEXT(1, &OGLRef.fboMSIntermediateRenderID);
+		glDeleteRenderbuffersEXT(1, &OGLRef.rboMSFragColorID);
+		glDeleteRenderbuffersEXT(1, &OGLRef.rboMSFragDepthStencilID);
+		
+		this->isMultisampledFBOSupported = false;
+	}
+	
+	
+	Render3DError OpenGLRenderer_X432::SelectRenderingFramebuffer()
+	{
+		OGLRenderRef &OGLRef = *this->ref;
+		
+		#ifndef X432R_OPENGL_CUSTOMFRAMEBUFFEROPERATION_TEST
+		OGLRef.selectedRenderingFBO = (this->isMultisampledFBOSupported && CommonSettings.GFX3D_Renderer_Multisample) ? OGLRef.fboMSIntermediateRenderID : highResolutionFramebuffer;
+		#else
+		OGLRef.selectedRenderingFBO = highResolutionFramebuffer;
+		#endif
+		
+		glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, OGLRef.selectedRenderingFBO);
+		
+		return OGLERROR_NOERR;
+	}
+	
+	template <u32 RENDER_MAGNIFICATION>
+	Render3DError OpenGLRenderer_X432::DownsampleFBO()
+	{
+		OGLRenderRef &OGLRef = *this->ref;
+		
+		#ifndef X432R_OPENGL_CUSTOMFRAMEBUFFEROPERATION_TEST
+		if(OGLRef.selectedRenderingFBO == OGLRef.fboMSIntermediateRenderID)
+		{
+			glBindFramebufferEXT(GL_READ_FRAMEBUFFER_EXT, OGLRef.selectedRenderingFBO);
+			glBindFramebufferEXT(GL_DRAW_FRAMEBUFFER_EXT, highResolutionFramebuffer);
+			glBlitFramebufferEXT(0, 0, 256 * RENDER_MAGNIFICATION, 192 * RENDER_MAGNIFICATION, 0, 0, 256 * RENDER_MAGNIFICATION, 192 * RENDER_MAGNIFICATION, GL_COLOR_BUFFER_BIT, GL_NEAREST);
+			glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, highResolutionFramebuffer);
+		}
+		#endif
+		
+		return OGLERROR_NOERR;
+	}
+	
+	template <u32 RENDER_MAGNIFICATION>
+	Render3DError OpenGLRenderer_X432::ReadBackPixels()
+	{
+		const unsigned int i = this->doubleBufferIndex;
+		
+		this->DownsampleFBO<RENDER_MAGNIFICATION>();
+		
+		glBindBuffer( GL_PIXEL_PACK_BUFFER, this->ref->pboRenderDataID[i] );
+		#ifdef X432R_OPENGL_CUSTOMFRAMEBUFFEROPERATION_TEST2
+		glReadBuffer(GL_COLOR_ATTACHMENT0_EXT);
+		#endif
+		glReadPixels(0, 0, 256 * RENDER_MAGNIFICATION, 192 * RENDER_MAGNIFICATION, GL_BGRA, GL_UNSIGNED_BYTE, 0);
+		glBindBuffer(GL_PIXEL_PACK_BUFFER, 0);
+		
+		this->gpuScreen3DHasNewData[i] = true;
+		
+		return OGLERROR_NOERR;
+	}
+	
+	
+	template <u32 RENDER_MAGNIFICATION>
+	Render3DError OpenGLRenderer_X432::Render(const GFX3D_State *renderState, const VERTLIST *vertList, const POLYLIST *polyList, const INDEXLIST *indexList, const u64 frameCount)
+	{
+		Render3DError error = RENDER3DERROR_NOERR;
+		
+		error = this->BeginRender(renderState);
+		
+		if(error != RENDER3DERROR_NOERR) return error;
+		
+		this->UpdateToonTable(renderState->u16ToonTable);
+		this->ClearFramebuffer<RENDER_MAGNIFICATION>(renderState);
+		
+		this->PreRender(renderState, vertList, polyList, indexList);
+		this->DoRender<RENDER_MAGNIFICATION>(renderState, vertList, polyList, indexList);
+		this->PostRender();
+		
+		this->EndRender<RENDER_MAGNIFICATION>(frameCount);
+		
+		return error;
+	}
+	
+	Render3DError OpenGLRenderer_X432::BeginRender(const GFX3D_State *renderState)
+	{
+		OpenGLRenderer_2_0::BeginRender(renderState);
+		
+		
+		#ifdef X432R_OPENGL_FOG_ENABLED
+		const u8 * const fog_density_pointer = MMU.MMU_MEM[ARMCPU_ARM9][0x40] + 0x360;
+		
+		if( !renderState->enableFog || ( ( fog_density_pointer[0] == 0 ) && ( fog_density_pointer[31] == 0 ) ) )
+		{
+			glFogEnabled = false;
+//			glDisable(GL_FOG);
+			glUniform1i(uniformFogEnabled, GL_FALSE);
+		}
+		else
+		{
+			const float fog_offset = (float)renderState->fogOffset / 32768.0f;
+			const float fog_step = (float)(0x0400 >> renderState->fogShift) / 32768.0f;
+			
+			const bool alpha_only = renderState->enableFogAlphaOnly;
+			const u32 color = renderState->fogColor;
+			
+			#ifndef X432R_OPENGL_CUSTOMFRAMEBUFFEROPERATION_TEST
+			#if 0
+			const float fog_color[4] = 
+			{
+				(float)(color & 0x1F) / (float)0x1F,
+				(float)( (color >> 5) & 0x1F ) / (float)0x1F,
+				(float)( (color >> 10) & 0x1F ) / (float)0x1F,
+				(float)( (color >> 16) & 0x1F ) / (float)0x1F
+			};
+			#elif 0
+			const u32 clearcolor = renderState->clearColor;
+			
+			const float fog_color[4] = 
+			{
+				alpha_only ? ( (float)(clearcolor & 0x1F) / (float)0x1F ) : ( (float)(color & 0x1F) / (float)0x1F ),
+				alpha_only ? ( (float)( (clearcolor >> 5) & 0x1F ) / (float)0x1F ) : ( (float)( (color >> 5) & 0x1F ) / (float)0x1F ),
+				alpha_only ? ( (float)( (clearcolor >> 10) & 0x1F ) / (float)0x1F ) : ( (float)( (color >> 10) & 0x1F ) / (float)0x1F ),
+				alpha_only ? ( (float)( (clearcolor >> 16) & 0x1F ) / (float)0x1F ) : ( (float)( (color >> 16) & 0x1F ) / (float)0x1F ),
+			};
+			#else
+			const u32 clearcolor = renderState->clearColor;
+			
+			const float fog_color[4] = 
+			{
+				alpha_only ? ( (float)(clearcolor & 0x1F) / (float)0x1F ) : ( (float)(color & 0x1F) / (float)0x1F ),
+				alpha_only ? ( (float)( (clearcolor >> 5) & 0x1F ) / (float)0x1F ) : ( (float)( (color >> 5) & 0x1F ) / (float)0x1F ),
+				alpha_only ? ( (float)( (clearcolor >> 10) & 0x1F ) / (float)0x1F ) : ( (float)( (color >> 10) & 0x1F ) / (float)0x1F ),
+				1.0f
+			};
+			#endif
+			#else
+			const float fog_color[4] = 
+			{
+				(float)(color & 0x1F) / (float)0x1F,
+				(float)( (color >> 5) & 0x1F ) / (float)0x1F,
+				(float)( (color >> 10) & 0x1F ) / (float)0x1F,
+				(float)( (color >> 16) & 0x1F ) / (float)0x1F
+			};
+			
+			glUniform1i(uniformFogAlphaOnly, alpha_only ? GL_TRUE : GL_FALSE);
+			#endif
+			
+			float fog_density[32];
+			
+			for(u32 i = 0; i < 32; ++i)
+			{
+				fog_density[i] = 1.0f - ( (float)fog_density_pointer[i] / 128.0f );
+			}
+			
+			glFogEnabled = true;
+			
+//			glEnable(GL_FOG);
+			glUniform1i(uniformFogEnabled, GL_TRUE);
+			
+			glUniform1f(uniformFogOffset, fog_offset);
+			glUniform1f(uniformFogStep, fog_step);
+			glUniform1fv(uniformFogDensity, 32, fog_density);
+			
+			glFogfv(GL_FOG_COLOR, fog_color);
+		}
+		#endif
+		
+		
+		#ifdef X432R_OPENGL_CUSTOMFRAMEBUFFEROPERATION_TEST
+//		glBlendFuncSeparate(GL_ONE, GL_ZERO, GL_ONE, GL_ZERO);
+//		glBlendEquationSeparate(GL_FUNC_ADD, GL_FUNC_ADD);
+		glDisable(GL_BLEND);
+		glUniform1f(uniformAlphaBlendEnabled, renderState->enableAlphaBlending ? GL_TRUE : GL_FALSE);
+		#endif
+		
+		
+		return OGLERROR_NOERR;
+	}
+	
+	template <u32 RENDER_MAGNIFICATION>
+	Render3DError OpenGLRenderer_X432::DoRender(const GFX3D_State *renderState, const VERTLIST *vertList, const POLYLIST *polyList, const INDEXLIST *indexList)
+	{
+		OGLRenderRef &OGLRef = *this->ref;
+		u32 lastTexParams = 0;
+		u32 lastTexPalette = 0;
+		u32 lastPolyAttr = 0;
+		u32 lastViewport = 0xFFFFFFFF;
+		const size_t polyCount = polyList->count;
+		GLsizei vertIndexCount = 0;
+		GLushort *indexBufferPtr = (this->isVBOSupported) ? 0 : OGLRef.vertIndexBuffer;
+		
+		// Map GFX3D_QUADS and GFX3D_QUAD_STRIP to GL_TRIANGLES since we will convert them.
+		//
+		// Also map GFX3D_TRIANGLE_STRIP to GL_TRIANGLES. This is okay since this is actually
+		// how the POLY struct stores triangle strip vertices, which is in sets of 3 vertices
+		// each. This redefinition is necessary since uploading more than 3 indices at a time
+		// will cause glDrawElements() to draw the triangle strip incorrectly.
+		static const GLenum oglPrimitiveType[]	= {GL_TRIANGLES, GL_TRIANGLES, GL_TRIANGLES, GL_TRIANGLES,
+												   GL_LINE_LOOP, GL_LINE_LOOP, GL_LINE_STRIP, GL_LINE_STRIP};
+		
+		static const GLsizei indexIncrementLUT[] = {3, 6, 3, 6, 3, 4, 3, 4};
+		
+		// Set up initial states, but only if there are polygons to draw
+		if(polyCount > 0)
+		{
+			#if defined(X432R_OPENGL_CUSTOMSTENCILTEST) && ( !defined(X432R_OPENGL_2PASSSHADOW_TEST) || defined(X432R_CUSTOMRENDERER_DEBUG) )
+			#ifdef X432R_CUSTOMRENDERER_DEBUG
+			u32 shadow_count = 0;
+			u32 shadow_group_count = 0;
+//			bool alphaDepthWriteDisabled = false;
+			#endif
+			
+			const POLY *poly;
+			u8 poly_id;
+			
+			shadowPolygonIDs.clear();
+			
+			for(u32 i = 0; i < polyCount; ++i)
+			{
+				poly = &polyList->list[i];
+				
+//				if( !alphaDepthWriteDisabled && !poly->getAttributeEnableAlphaDepthWrite() )
+//					alphaDepthWriteDisabled = true;
+				
+				if( poly->getAttributePolygonMode() != 3 ) continue;
+				
+				poly_id = poly->getAttributePolygonID();
+				
+				if(poly_id == 0) continue;
+				
+				#ifdef X432R_CUSTOMRENDERER_DEBUG
+				++shadow_count;
+				#endif
+				
+				if( std::find( shadowPolygonIDs.begin(), shadowPolygonIDs.end(), poly_id ) != shadowPolygonIDs.end() ) continue;
+				
+				shadowPolygonIDs.push_back(poly_id);
+			}
+			
+			#ifdef X432R_CUSTOMRENDERER_DEBUG
+			shadow_group_count = shadowPolygonIDs.size();
+			
+			if(shadow_count > 0)
+				ShowDebugMessage( "ShadowPolygon:" + std::to_string(shadow_count) + "/" + std::to_string(shadow_group_count) );
+			
+//			if(alphaDepthWriteDisabled)
+//				ShowDebugMessage("OpenGL AlphaDepthWrite: Disabled");
+			#endif
+			#endif
+			
+			#if defined(X432R_OPENGL_CUSTOMSTENCILTEST) && defined(X432R_OPENGL_2PASSSHADOW_TEST)
+			bool is_shadow;
+			#endif
+			
+			
+			const POLY *firstPoly = &polyList->list[ indexList->list[0] ];
+			
+			lastPolyAttr = firstPoly->polyAttr;
+			this->SetupPolygon(firstPoly);
+			
+			lastTexParams = firstPoly->texParam;
+			lastTexPalette = firstPoly->texPalette;
+			this->SetupTexture(firstPoly, renderState->enableTexturing);
+			
+			lastViewport = firstPoly->viewport;
+			this->SetupViewport<RENDER_MAGNIFICATION>(firstPoly->viewport);
+			
+			// Enumerate through all polygons and render
+			for(size_t i = 0; i < polyCount; ++i)
+			{
+				const POLY *poly = &polyList->list[ indexList->list[i] ];
+				
+				#if defined(X432R_OPENGL_CUSTOMSTENCILTEST) && defined(X432R_OPENGL_2PASSSHADOW_TEST)
+				is_shadow = ( poly->getAttributePolygonMode() == 3 );
+				#endif
+				
+				// Set up the polygon if it changed
+				if(lastPolyAttr != poly->polyAttr)
+				{
+					lastPolyAttr = poly->polyAttr;
+					#ifndef X432R_OPENGL_2PASSSHADOW_TEST
+					this->SetupPolygon(poly);
+					#else
+					if(is_shadow)
+						this->SetupShadowPolygon(poly, true);
+					else
+						this->SetupPolygon(poly);
+					#endif
+				}
+				
+				// Set up the texture if it changed
+				if( (lastTexParams != poly->texParam) || (lastTexPalette != poly->texPalette) )
+				{
+					lastTexParams = poly->texParam;
+					lastTexPalette = poly->texPalette;
+					this->SetupTexture(poly, renderState->enableTexturing);
+				}
+				
+				// Set up the viewport if it changed
+				if(lastViewport != poly->viewport)
+				{
+					lastViewport = poly->viewport;
+					this->SetupViewport<RENDER_MAGNIFICATION>(poly->viewport);
+				}
+				
+				// In wireframe mode, redefine all primitives as GL_LINE_LOOP rather than
+				// setting the polygon mode to GL_LINE though glPolygonMode(). Not only is
+				// drawing more accurate this way, but it also allows GFX3D_QUADS and
+				// GFX3D_QUAD_STRIP primitives to properly draw as wireframe without the
+				// extra diagonal line.
+				const GLenum polyPrimitive = !poly->isWireframe() ? oglPrimitiveType[poly->vtxFormat] : GL_LINE_LOOP;
+				
+				// Increment the vertex count
+				vertIndexCount += indexIncrementLUT[poly->vtxFormat];
+				
+				// Look ahead to the next polygon to see if we can simply buffer the indices
+				// instead of uploading them now. We can buffer if all polygon states remain
+				// the same and we're not drawing a line loop or line strip.
+				if (i+1 < polyCount)
+				{
+					const POLY *nextPoly = &polyList->list[indexList->list[i+1]];
+					
+					if (lastPolyAttr == nextPoly->polyAttr &&
+						lastTexParams == nextPoly->texParam &&
+						lastTexPalette == nextPoly->texPalette &&
+						lastViewport == nextPoly->viewport &&
+						polyPrimitive == oglPrimitiveType[nextPoly->vtxFormat] &&
+						polyPrimitive != GL_LINE_LOOP &&
+						polyPrimitive != GL_LINE_STRIP &&
+						oglPrimitiveType[nextPoly->vtxFormat] != GL_LINE_LOOP &&
+						oglPrimitiveType[nextPoly->vtxFormat] != GL_LINE_STRIP)
+					{
+						continue;
+					}
+				}
+				
+				// Render the polygons
+				glDrawElements(polyPrimitive, vertIndexCount, GL_UNSIGNED_SHORT, indexBufferPtr);
+				
+				#if defined(X432R_OPENGL_CUSTOMSTENCILTEST) && defined(X432R_OPENGL_2PASSSHADOW_TEST)
+				if( is_shadow && ( poly->getAttributePolygonID() != 0 ) )
+				{
+					this->SetupShadowPolygon(poly, false);
+				
+					glDrawElements(polyPrimitive, vertIndexCount, GL_UNSIGNED_SHORT, indexBufferPtr);
+				}
+				#endif
+			
+				indexBufferPtr += vertIndexCount;
+				vertIndexCount = 0;
+			}
+		}
+		
+		return OGLERROR_NOERR;
+	}
+	
+	template <u32 RENDER_MAGNIFICATION>
+	Render3DError OpenGLRenderer_X432::EndRender(const u64 frameCount)
+	{
+		//needs to happen before endgl because it could free some textureids for expired cache items
+		TexCache_EvictFrame();
+		
+		this->ReadBackPixels<RENDER_MAGNIFICATION>();
+		
+		return OGLERROR_NOERR;
+	}
+	
+	
+	template <u32 RENDER_MAGNIFICATION>
+	Render3DError OpenGLRenderer_X432::ClearFramebuffer(const GFX3D_State *renderState)
+	{
+		Render3DError error = RENDER3DERROR_NOERR;
+		
+/*		struct GFX3D_ClearColor
+		{
+			u8 r;
+			u8 g;
+			u8 b;
+			u8 a;
+		} clearColor;
+		
+		clearColor.r = renderState->clearColor & 0x1F;
+		clearColor.g = (renderState->clearColor >> 5) & 0x1F;
+		clearColor.b = (renderState->clearColor >> 10) & 0x1F;
+		clearColor.a = (renderState->clearColor >> 16) & 0x1F;
+*/		
+		const u8 r = renderState->clearColor & 0x1F;
+		const u8 g = (renderState->clearColor >> 5) & 0x1F;
+		const u8 b = (renderState->clearColor >> 10) & 0x1F;
+		const u8 a = (renderState->clearColor >> 16) & 0x1F;
+		
+		const u8 polyID = (renderState->clearColor >> 24) & 0x3F;
+		
+		
+		#ifdef X432R_OPENGL_FOG_ENABLED
+/*		const bool fog_enabled = glFogEnabled && BIT15(gfx3d.renderState.clearColor);
+		
+		if(fog_enabled)
+		{
+			
+		}
+*/		#endif
+		
+		
+		#ifndef X432R_OPENGL_CUSTOMFRAMEBUFFEROPERATION_TEST2
+		
+		#ifdef X432R_CUSTOMRENDERER_CLEARIMAGE_ENABLED
+		if(renderState->enableClearImage)
+		{
+			const u16 *__restrict clearColorBuffer = (u16 *__restrict)MMU.texInfo.textureSlotAddr[2];
+			const u16 *__restrict clearDepthBuffer = (u16 *__restrict)MMU.texInfo.textureSlotAddr[3];
+			const u16 scrollBits = T1ReadWord(MMU.ARM9_REG, 0x356); //CLRIMAGE_OFFSET
+			const u8 xScroll = scrollBits & 0xFF;
+			const u8 yScroll = (scrollBits >> 8) & 0xFF;
+			
+			size_t dd = (GFX3D_FRAMEBUFFER_WIDTH * GFX3D_FRAMEBUFFER_HEIGHT) - GFX3D_FRAMEBUFFER_WIDTH;
+			
+			for (size_t iy = 0; iy < GFX3D_FRAMEBUFFER_HEIGHT; iy++)
+			{
+				const size_t y = ((iy + yScroll) & 0xFF) << 8;
+				
+				for (size_t ix = 0; ix < GFX3D_FRAMEBUFFER_WIDTH; ix++)
+				{
+					const size_t x = (ix + xScroll) & 0xFF;
+					const size_t adr = y + x;
+					
+					clearImageColor16Buffer[dd] = clearColorBuffer[adr];
+					clearImageDepthStencilBuffer[dd] = ( (u32)DS_DEPTH15TO24( clearDepthBuffer[adr] ) << 8 ) | polyID;
+					
+					dd++;
+				}
+				
+				dd -= GFX3D_FRAMEBUFFER_WIDTH * 2;
+			}
+			
+			error = UpdateClearImage(clearImageColor16Buffer, clearImageDepthStencilBuffer);
+			
+			if(error == RENDER3DERROR_NOERR)
+				error = ClearUsingImage<RENDER_MAGNIFICATION>();
+			else
+				error = ClearUsingValues(r, g, b, a, renderState->clearDepth, polyID);
+		}
+		else
+		#endif
+			error = this->ClearUsingValues(r, g, b, a, renderState->clearDepth, polyID);
+		
+		#else
+		
+		static const GLenum buffers[] = {GL_COLOR_ATTACHMENT0_EXT, GL_COLOR_ATTACHMENT1_EXT};
+		float clear_depth = (float)renderState->clearDepth / (float)0x00FFFFFF;
+		
+		#if 1
+		glDrawBuffers(2, buffers);
+		
+		float clearcolor[4];
+		clearcolor[0] = divide5bitBy31_LUT[r];
+		clearcolor[1] = divide5bitBy31_LUT[g];
+		clearcolor[2] = divide5bitBy31_LUT[b];
+		clearcolor[3] = divide5bitBy31_LUT[a];
+		glClearBufferfv(GL_COLOR, 0, clearcolor);		// OpenGL 3.0
+		
+		clearcolor[0] = clear_depth;
+		clearcolor[1] = (float)polyID;
+		clearcolor[2] = 0.0f;
+		clearcolor[3] = 0.0f;
+		glClearBufferfv(GL_COLOR, 1, clearcolor);
+		
+		
+//		glColorMaski(0, true, true, true, true);
+//		glColorMaski(1, true, true, true, true);
+		#else
+		glDrawBuffer(GL_COLOR_ATTACHMENT0_EXT);
+		
+		if(a == 0)
+			glClearColor(0.0f, 0.0f, 0.0f, 0.0f);
+		else
+			glClearColor( divide5bitBy31_LUT[r], divide5bitBy31_LUT[g], divide5bitBy31_LUT[b], divide5bitBy31_LUT[a] );
+		
+		glClear(GL_COLOR);
+		
+		
+		glDrawBuffer(GL_COLOR_ATTACHMENT1_EXT);
+		glClearColor( clear_depth, (float)polyID, 0.0f, 0.0f );
+		glClear(GL_COLOR);
+		
+		
+		glDrawBuffers(2, buffers);
+		#endif
+		
+		#endif
+		
+		#ifdef X432R_CUSTOMRENDERER_DEBUG
+		if(renderState->enableClearImage)
+			X432R::ShowDebugMessage("OpenGL ClearImage");
+		#endif
+		
+		
+		return error;
+	}
+	
+	#ifdef X432R_CUSTOMRENDERER_CLEARIMAGE_ENABLED
+	template <u32 RENDER_MAGNIFICATION>
+	Render3DError OpenGLRenderer_X432::ClearUsingImage() const
+	{
+		if( !this->isFBOSupported )
+			return OGLERROR_FEATURE_UNSUPPORTED;
+		
+		OGLRenderRef &OGLRef = *this->ref;
+		
+		glBindFramebufferEXT(GL_READ_FRAMEBUFFER_EXT, OGLRef.fboClearImageID);
+		glBindFramebufferEXT(GL_DRAW_FRAMEBUFFER_EXT, OGLRef.selectedRenderingFBO);
+		glBlitFramebufferEXT(0, 0, 256, 192, 0, 0, 256 * RENDER_MAGNIFICATION, 192 * RENDER_MAGNIFICATION, GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT, GL_NEAREST);
+		glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, OGLRef.selectedRenderingFBO);
+		
+		// It might seem wasteful to be doing a separate glClear(GL_STENCIL_BUFFER_BIT) instead
+		// of simply blitting the stencil buffer with everything else.
+		//
+		// We do this because glBlitFramebufferEXT() for GL_STENCIL_BUFFER_BIT has been tested
+		// to be unsupported on ATI/AMD GPUs running in compatibility mode. So we do the separate
+		// glClear() for GL_STENCIL_BUFFER_BIT to keep these GPUs working.
+		glClearStencil(this->clearImageStencilValue);
+		glClear(GL_STENCIL_BUFFER_BIT);
+		
+		return OGLERROR_NOERR;
+	}
+	#endif
+	
+	Render3DError OpenGLRenderer_X432::ClearUsingValues(const u8 r, const u8 g, const u8 b, const u8 a, const u32 clearDepth, const u8 clearStencil) const
+	{
+		#ifdef X432R_OPENGL_FOG_ENABLED
+/*		const bool clear_fogged = BIT15(gfx3d.renderState.clearColor);
+		const u32 clear_depth = clearDepth;
+		
+		u32 fog_color = ;
+		
+		r = ;
+		g = ;
+		b = ;
+		a = ;
+*/		#endif
+		
+		if(a == 0)
+			glClearColor(0.0f, 0.0f, 0.0f, 0.0f);
+		else
+			glClearColor( divide5bitBy31_LUT[r], divide5bitBy31_LUT[g], divide5bitBy31_LUT[b], divide5bitBy31_LUT[a] );
+		
+		glClearDepth( (GLclampd)clearDepth / (GLclampd)0x00FFFFFF );
+		
+		#ifndef X432R_OPENGL_CUSTOMSTENCILTEST
+		glClearStencil(clearStencil);
+		#elif !defined(X432R_OPENGL_2PASSSHADOW_TEST)
+		glClearStencil(0xFF);
+		#else
+		glClearStencil(clearStencil << 2);
+		#endif
+		
+		glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);
+		
+		return OGLERROR_NOERR;
+	}
+	
+	
+	Render3DError OpenGLRenderer_X432::SetupPolygon(const POLY *thePoly)
+	{
+		OGLRenderRef &OGLRef = *this->ref;
+		const PolygonAttributes attr = thePoly->getAttributes();
+		
+		// Set up polygon attributes
+		glUniform1i(OGLRef.uniformPolyMode, attr.polygonMode);
+		glUniform1f(OGLRef.uniformPolyAlpha, (!attr.isWireframe && attr.isTranslucent) ? divide5bitBy31_LUT[attr.alpha] : 1.0f);
+		glUniform1i(OGLRef.uniformPolyID, attr.polygonID);
+		
+		// Set up depth test mode
+		static const GLenum oglDepthFunc[2] = {GL_LESS, GL_EQUAL};
+		glDepthFunc( oglDepthFunc[attr.enableDepthTest] );
+		
+		// Set up culling mode
+		static const GLenum oglCullingMode[4] = {GL_FRONT_AND_BACK, GL_FRONT, GL_BACK, 0};
+		GLenum cullingMode = oglCullingMode[attr.surfaceCullingMode];
+		
+		if(cullingMode == 0)
+		{
+			glDisable(GL_CULL_FACE);
+		}
+		else
+		{
+			glEnable(GL_CULL_FACE);
+			glCullFace(cullingMode);
+		}
+		
+		
+		#ifndef X432R_OPENGL_CUSTOMFRAMEBUFFEROPERATION_TEST2
+		#ifndef X432R_OPENGL_CUSTOMSTENCILTEST
+		// Set up depth write
+		GLboolean enableDepthWrite = GL_TRUE;
+		
+		// Handle shadow polys. Do this after checking for depth write, since shadow polys
+		// can change this too.
+		if(attr.polygonMode == 3)
+		{
+			glEnable(GL_STENCIL_TEST);
+			if(attr.polygonID == 0)
+			{
+				//when the polyID is zero, we are writing the shadow mask.
+				//set stencilbuf = 1 where the shadow volume is obstructed by geometry.
+				//do not write color or depth information.
+				glStencilFunc(GL_ALWAYS, 65, 255);
+				glStencilOp(GL_KEEP, GL_REPLACE, GL_KEEP);
+				glColorMask(GL_FALSE, GL_FALSE, GL_FALSE, GL_FALSE);
+				enableDepthWrite = GL_FALSE;
+			}
+			else
+			{
+				//when the polyid is nonzero, we are drawing the shadow poly.
+				//only draw the shadow poly where the stencilbuf==1.
+				//I am not sure whether to update the depth buffer here--so I chose not to.
+				glStencilFunc(GL_EQUAL, 65, 255);
+				glStencilOp(GL_KEEP, GL_KEEP, GL_KEEP);
+				glColorMask(GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE);
+				enableDepthWrite = GL_TRUE;
+			}
+		}
+		else
+		{
+			glEnable(GL_STENCIL_TEST);
+			if(attr.isTranslucent)
+			{
+				glStencilFunc(GL_NOTEQUAL, attr.polygonID, 255);
+				glStencilOp(GL_KEEP, GL_KEEP, GL_REPLACE);
+				glColorMask(GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE);
+			}
+			else
+			{
+				glStencilFunc(GL_ALWAYS, 64, 255);
+				glStencilOp(GL_REPLACE, GL_REPLACE, GL_REPLACE);
+				glColorMask(GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE);
+			}
+		}
+		
+		if(attr.isTranslucent && !attr.enableAlphaDepthWrite)
+		{
+			enableDepthWrite = GL_FALSE;
+		}
+		
+		glDepthMask(enableDepthWrite);
+		
+		#elif !defined(X432R_OPENGL_2PASSSHADOW_TEST)
+		// memo: SoftRastでは5つのステンシルバッファが使用されている
+		// 
+		// Fragment.polyid.opaque
+		// 初期値: (renderState->clearColor >> 24) & 0x3F
+		// 不透明ポリゴン描画時にpolyIDをセット
+		// 
+		// Fragment.polyid.translucent
+		// 初期値: 0xFF
+		// 半透明ポリゴン描画時にpolyIDをセット, 同一IDなら描画をskip
+		// 
+		// Fragment.stencil
+		// 初期値: 0
+		// shadow用
+		// (ID == 0) 描画時に+1
+		// (ID != 0) 描画時に-1 (ただしFragment.polyid.opaqueに同一IDがセットされている場合は描画をskip)
+		// 
+		// Fragment.fogged
+		// 初期値: BIT15(gfx3d.renderState.clearColor)
+		// フォグ描画フラグ
+		// SoftRastでは全ポリゴンを描画後、フレームバッファのFragment.depthとFragment.foggedを用いてフォグを合成する
+		// OpenGLのフラグメントシェーダはポリゴン毎に処理を行うため、フォグのalpha値をポリゴンに反映させると正しく描画できない
+		// フォグを完全に再現するには
+		// 
+		// Fragment.isTranslucentPoly
+		// 初期値: 0
+		// EdgeMarking用？
+		// 半透明ポリゴンならEdgeMarkingの処理をskip
+		
+		if(attr.polygonMode == 3)		// polygonMode 0:modulate 1:decal 3:toon/highlight(gfx3d.renderState.shadingでtoon/highlight選択) 3:shadow
+		{
+			glEnable(GL_STENCIL_TEST);
+			
+			if(attr.polygonID == 0)
+			{
+				glStencilFunc(GL_NOTEQUAL, 0x80, 0xFF);
+				glStencilOp(GL_KEEP, GL_ZERO, GL_KEEP);						// デプステストfail時のみステンシル値に0をセット(clearStencilは0xFFに固定してしまう)
+				glColorMask(GL_FALSE, GL_FALSE, GL_FALSE, GL_FALSE);
+				glDepthMask(GL_FALSE);
+			}
+			else
+			{
+				glStencilFunc(GL_EQUAL, 0, 0xFF);							// ステンシル値に0がセットされている部分のみシャドウを描画
+//				glStencilOp(GL_KEEP, GL_KEEP, GL_INVERT);					// 1回シャドウを描画したらステンシル値をリセット(0 → 0xFF)
+				glStencilOp(GL_KEEP, GL_KEEP, GL_KEEP);						// ステンシル値をリセットしない(複数回シャドウを描画可能)
+				glColorMask(GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE);
+				glDepthMask(GL_TRUE);
+			}
+		}
+		else if( attr.isTranslucent || ( std::find( shadowPolygonIDs.begin(), shadowPolygonIDs.end(), attr.polygonID ) == shadowPolygonIDs.end() ) )
+		{
+			glDisable(GL_STENCIL_TEST);
+			glColorMask(GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE);
+			
+			#if 1
+			if( !attr.isTranslucent || ( (attr.polygonMode == 1) && attr.isOpaque ) || attr.enableAlphaDepthWrite )		// modeがdecalの場合はテクスチャのアルファ値が無視されるため attr.isTranslucent && attr.isOpaque ならisTranslucentを無視
+				glDepthMask(GL_TRUE);
+			else
+				glDepthMask(GL_FALSE);
+			#else
+			if(attr.isOpaque || attr.enableAlphaDepthWrite)		// 一部のポリゴンが正常に描画されない問題が改善するが、副作用あり
+				glDepthMask(GL_TRUE);							// SoftRastではフラグメント毎のポリゴン・テクスチャ色の合成結果を見てDepth値書き込みの可否を判定しているが、OpenGLではポリゴン毎にON/OFFしているため完全に再現できていない
+			else
+				glDepthMask(GL_FALSE);
+			#endif
+		}
+		else
+		{
+			// shadowポリゴンと同一IDグループの場合はステンシル値に0x80をセット（shadowポリゴンが複数ある場合、正常に描画されない可能性あり）
+			glEnable(GL_STENCIL_TEST);
+			glStencilFunc(GL_ALWAYS, 0x80, 0xFF);
+//			glStencilOp(GL_REPLACE, GL_REPLACE, GL_REPLACE);
+			glStencilOp(GL_KEEP, GL_KEEP, GL_REPLACE);
+			glColorMask(GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE);
+			glDepthMask(GL_TRUE);
+		}
+		#else
+		// OpenGL用：ステンシルバッファ8bit
+		// 1111 1100	bit2-7: polygonID 0〜3F				func:GL_ALWAYS		ref:(polygonID << 2)		mask:0xFF
+		// 000 00011	bit0-1: shadowフラグ
+		
+		if( attr.isTranslucent && ( (attr.polygonMode != 1) || !attr.isOpaque ) )		// modeがdecalの場合はテクスチャのアルファ値が無視されるため attr.isTranslucent && attr.isOpaque ならisTranslucentを無視
+		{
+			glDisable(GL_STENCIL_TEST);
+			
+			glColorMask(GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE);
+			glDepthMask(attr.enableAlphaDepthWrite ? GL_TRUE : GL_FALSE);
+		}
+		else
+		{
+			glEnable(GL_STENCIL_TEST);
+			
+			glStencilFunc( GL_ALWAYS, (attr.polygonID << 2), 0xFF );
+			glStencilOp(GL_KEEP, GL_KEEP, GL_REPLACE);
+			
+			glColorMask(GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE);
+			glDepthMask(GL_TRUE);
+		}
+		#endif
+		#else
+		if( !attr.enableDepthTest )
+			glUniform1f(uniformDepthComparisionThreshold, 0.0f);
+		else
+			glUniform1f( uniformDepthComparisionThreshold, (CommonSettings.GFX3D_Zelda_Shadow_Depth_Hack <= 0) ? 0.00003f : ( (float)CommonSettings.GFX3D_Zelda_Shadow_Depth_Hack / 32768.0f ) );
+		
+		glUniform1i(uniformAlphaDepthWriteEnabled, attr.enableAlphaDepthWrite ? GL_TRUE : GL_FALSE);
+		
+		
+		glDisable(GL_DEPTH_TEST);				// depth, stencilテストをshaderで行う
+		glDisable(GL_STENCIL_TEST);
+		
+		
+		
+		#endif
+		
+		
+		#ifdef X432R_OPENGL_FOG_ENABLED
+		if( !glFogEnabled || !attr.enableRenderFog || (attr.alpha == 0) || ( (attr.polygonMode == 3) && (attr.polygonID == 0) ) )
+		{
+//			glDisable(GL_FOG);
+			glUniform1i(uniformFogEnabled, GL_FALSE);
+		}
+		else
+		{
+//			glEnable(GL_FOG);
+			glUniform1i(uniformFogEnabled, GL_TRUE);
+		}
+		#endif
+		
+		
+//		#ifdef X432R_RENDER3D_BILLBOARDCHECK_TEST
+		#if defined(X432R_OPENGL_CUSTOMFRAMEBUFFEROPERATION_TEST) && defined(X432R_RENDER3D_BILLBOARDCHECK_TEST)
+		glUniform1i( uniformIsNativeResolution2DPolygon, IsNativeResolution2DPolygon(thePoly) ? GL_TRUE : GL_FALSE );
+		#endif
+		
+		
+		return OGLERROR_NOERR;
+	}
+	
+	#ifdef X432R_OPENGL_2PASSSHADOW_TEST
+	void OpenGLRenderer_X432::SetupShadowPolygon(const POLY *thePoly, bool first_pass)
+	{
+		OGLRenderRef &OGLRef = *this->ref;
+		const PolygonAttributes attr = thePoly->getAttributes();
+		
+		
+		if(first_pass)
+		{
+			// Set up polygon ID
+			glUniform1i(OGLRef.uniformPolyID, 0);
+			
+			
+			// Set up alpha value
+			const GLfloat thePolyAlpha = ( !attr.isWireframe && attr.isTranslucent ) ? divide5bitBy31_LUT[attr.alpha] : 1.0f;
+			glUniform1f(OGLRef.uniformPolyAlpha, thePolyAlpha);
+			
+			
+			// Set up depth test mode
+			static const GLenum oglDepthFunc[2] = {GL_LESS, GL_EQUAL};
+			glDepthFunc( oglDepthFunc[attr.enableDepthTest] );
+			
+			
+			// Set up culling mode
+			static const GLenum oglCullingMode[4] = {GL_FRONT_AND_BACK, GL_FRONT, GL_BACK, 0};
+			GLenum cullingMode = oglCullingMode[attr.surfaceCullingMode];
+		
+			if(cullingMode == 0)
+			{
+				glDisable(GL_CULL_FACE);
+			}
+			else
+			{
+				glEnable(GL_CULL_FACE);
+				glCullFace(cullingMode);
+			}
+			
+			
+			glEnable(GL_STENCIL_TEST);
+			
+			if(attr.polygonID == 0)
+			{
+//				glStencilFunc(GL_ALWAYS, 0, 0);
+				glStencilFunc(GL_NOTEQUAL, 1, 0x01);						// shadowフラグがOFFの場合のみ反映
+				glStencilOp(GL_KEEP, GL_INCR, GL_KEEP);						// デプステストfail時にステンシル値を+1してbit0のshadowフラグをON
+			}
+			else
+			{
+				glStencilFunc(GL_EQUAL, (attr.polygonID << 2) + 1, 0xFF);
+				glStencilOp(GL_KEEP, GL_KEEP, GL_DECR);						// IDグループが同一のポリゴンが存在する場合はshadowフラグをOFF
+				// 同一箇所にシャドウを複数回描画した場合に問題が出るかも
+			}
+			
+			glColorMask(GL_FALSE, GL_FALSE, GL_FALSE, GL_FALSE);			// Color／Depthバッファへの書き込みを無効化
+			glDepthMask(GL_FALSE);
+			
+			
+			// Set up texture blending mode
+			glUniform1i(OGLRef.uniformPolyMode, attr.polygonMode);
+		}
+		else
+		{
+			// Set up polygon ID
+			glUniform1i(OGLRef.uniformPolyID, attr.polygonID);
+			
+			
+			glEnable(GL_STENCIL_TEST);
+			
+//			if(attr.polygonID != 0)
+//			{
+				glStencilFunc(GL_EQUAL, 1, 0x01);
+//				glStencilOp(GL_KEEP, GL_KEEP, GL_KEEP);
+				glStencilOp(GL_KEEP, GL_KEEP, GL_DECR);
+				
+				glColorMask(GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE);
+				glDepthMask(GL_TRUE);
+//			}
+		}
+	}
+	#endif
+	
+	
+	template <u32 RENDER_MAGNIFICATION>
+	Render3DError OpenGLRenderer_X432::SetupViewport(const u32 viewportValue)
+	{
+		if(viewportValue == 0xBFFF0000)		// x == 0, y == 0, width == 256, height == 192
+		{
+			glViewport(0, 0, 256 * RENDER_MAGNIFICATION, 192 * RENDER_MAGNIFICATION);
+			return OGLERROR_NOERR;
+		}
+		
+		VIEWPORT viewport;
+		
+		viewport.decode(viewportValue);
+		
+		glViewport(viewport.x * RENDER_MAGNIFICATION, viewport.y * RENDER_MAGNIFICATION,
+					viewport.width * RENDER_MAGNIFICATION, viewport.height * RENDER_MAGNIFICATION);
+		
+		return OGLERROR_NOERR;
+	}
+	
+	
+	#if !defined(_MSC_VER) || (_MSC_VER < 1700) || ( !defined(X432R_PPL_TEST) && !defined(X432R_CPP_AMP_TEST) )
+	template <u32 RENDER_MAGNIFICATION>
+	void OpenGLRenderer_X432::DownscaleFramebuffer(const u32 * const sourcebuffer_begin)
+	{
+		u32 * const highresobuffer_begin = backBuffer.GetHighResolution3DBuffer();
+		u32 *highreso_buffer = highresobuffer_begin;
+		u32 * const gfx3d_buffer = (u32 *)gfx3d_convertedScreen;
+		const u32 *source_buffer;
+		
+		u32 x, y, remainder_x, remainder_y, downscaled_index;
+		RGBA8888 color_rgba8888, color_tiletopleft, color_tiletopright, color_tilebottomleft;
+		u32 tiletop_index, tilebottom_index, tileleft_x;
+		
+		
+		#ifdef X432R_PROCESSTIME_CHECK
+		AutoStopTimeCounter timecounter(timeCounter_3DFinish1);
+		#endif
+		
+		
+		for( y = 0; y < (192 * RENDER_MAGNIFICATION); ++y )
+		{
+			remainder_y = (y % RENDER_MAGNIFICATION);
+			downscaled_index = (y / RENDER_MAGNIFICATION) * 256;
+			
+			source_buffer = sourcebuffer_begin + ( ( ( (192 * RENDER_MAGNIFICATION) - 1 ) - y ) * (256 * RENDER_MAGNIFICATION) );		// Y軸を反転
+			
+			for( x = 0; x < (256 * RENDER_MAGNIFICATION); ++x, ++source_buffer, ++highreso_buffer )
+			{
+				remainder_x = (x % RENDER_MAGNIFICATION);
+				
+				color_rgba8888 = *source_buffer;
+				
+				if(color_rgba8888.A == 0)
+					color_rgba8888 = 0;
+				
+				*highreso_buffer = color_rgba8888.Color;
+				
+				// Bilinear
+				if( ( remainder_y != (RENDER_MAGNIFICATION - 1) ) || ( remainder_x != (RENDER_MAGNIFICATION - 1) ) ) continue;
+				
+				tiletop_index = ( y - (RENDER_MAGNIFICATION - 1) ) * (256 * RENDER_MAGNIFICATION);
+				tilebottom_index = y * (256 * RENDER_MAGNIFICATION);
+				tileleft_x = x - (RENDER_MAGNIFICATION - 1);
+				
+				color_tiletopleft = highresobuffer_begin[tiletop_index + tileleft_x];
+				color_tiletopright = highresobuffer_begin[tiletop_index + x];
+				color_tilebottomleft = highresobuffer_begin[tilebottom_index + tileleft_x];
+				
+				color_rgba8888.R = (u8)( ( (u32)color_tiletopleft.R + (u32)color_tiletopright.R + (u32)color_tilebottomleft.R + (u32)color_rgba8888.R ) >> 2 );
+				color_rgba8888.G = (u8)( ( (u32)color_tiletopleft.G + (u32)color_tiletopright.G + (u32)color_tilebottomleft.G + (u32)color_rgba8888.G ) >> 2 );
+				color_rgba8888.B = (u8)( ( (u32)color_tiletopleft.B + (u32)color_tiletopright.B + (u32)color_tilebottomleft.B + (u32)color_rgba8888.B ) >> 2 );
+				color_rgba8888.A = (u8)( ( (u32)color_tiletopleft.A + (u32)color_tiletopright.A + (u32)color_tilebottomleft.A + (u32)color_rgba8888.A ) >> 2 );
+				
+				#ifdef WORDS_BIGENDIAN
+				gfx3d_buffer[ downscaled_index + (x / RENDER_MAGNIFICATION) ] = BGRA8888_32_To_RGBA6665_32(color_rgba8888.Color);
+				#else
+				gfx3d_buffer[ downscaled_index + (x / RENDER_MAGNIFICATION) ] = BGRA8888_32Rev_To_RGBA6665_32Rev(color_rgba8888.Color);		// ピクセルフォーマットをRGBA6665に変換して値を保存
+				#endif
+			}
+		}
+	}
+	#elif defined(X432R_PPL_TEST)
+	template <u32 RENDER_MAGNIFICATION>
+	void OpenGLRenderer_X432::DownscaleFramebuffer(const u32 * const sourcebuffer_begin)
+	{
+		u32 * const highresobuffer_begin = backBuffer.GetHighResolution3DBuffer();
+		u32 * const gfx3d_buffer = (u32 *)gfx3d_convertedScreen;
+		
+		
+		#ifdef X432R_PROCESSTIME_CHECK
+		AutoStopTimeCounter timecounter(timeCounter_3DFinish1);
+		#endif
+		
+		
+		concurrency::parallel_for( (u32)0, RENDER_MAGNIFICATION, [&](const u32 offset)
+		{
+			const u32 y_begin = 192 * offset;
+			const u32 y_end = y_begin + 192;
+			
+			u32 *highreso_buffer = highresobuffer_begin + (y_begin * 256 * RENDER_MAGNIFICATION);
+			const u32 *source_buffer;
+			
+			u32 x, y, remainder_x, remainder_y, downscaled_index;
+			RGBA8888 color_rgba8888, color_tiletopleft, color_tiletopright, color_tilebottomleft;
+			u32 tiletop_index, tilebottom_index, tileleft_x;
+			
+			for(y = y_begin; y < y_end; ++y)
+			{
+				remainder_y = (y % RENDER_MAGNIFICATION);
+				downscaled_index = (y / RENDER_MAGNIFICATION) * 256;
+				
+				source_buffer = sourcebuffer_begin + ( ( ( (192 * RENDER_MAGNIFICATION) - 1 ) - y ) * (256 * RENDER_MAGNIFICATION) );		// Y軸を反転
+				
+				for( x = 0; x < (256 * RENDER_MAGNIFICATION); ++x, ++source_buffer, ++highreso_buffer )
+				{
+					remainder_x = (x % RENDER_MAGNIFICATION);
+					
+					color_rgba8888 = *source_buffer;
+					
+					if(color_rgba8888.A == 0)
+						color_rgba8888 = 0;
+					
+					*highreso_buffer = color_rgba8888.Color;
+					
+					// Bilinear
+					if( ( remainder_y != (RENDER_MAGNIFICATION - 1) ) || ( remainder_x != (RENDER_MAGNIFICATION - 1) ) ) continue;
+					
+					tiletop_index = ( y - (RENDER_MAGNIFICATION - 1) ) * (256 * RENDER_MAGNIFICATION);
+					tilebottom_index = y * (256 * RENDER_MAGNIFICATION);
+					tileleft_x = x - (RENDER_MAGNIFICATION - 1);
+					
+					color_tiletopleft = highresobuffer_begin[tiletop_index + tileleft_x];
+					color_tiletopright = highresobuffer_begin[tiletop_index + x];
+					color_tilebottomleft = highresobuffer_begin[tilebottom_index + tileleft_x];
+					
+					color_rgba8888.R = (u8)( ( (u32)color_tiletopleft.R + (u32)color_tiletopright.R + (u32)color_tilebottomleft.R + (u32)color_rgba8888.R ) >> 2 );
+					color_rgba8888.G = (u8)( ( (u32)color_tiletopleft.G + (u32)color_tiletopright.G + (u32)color_tilebottomleft.G + (u32)color_rgba8888.G ) >> 2 );
+					color_rgba8888.B = (u8)( ( (u32)color_tiletopleft.B + (u32)color_tiletopright.B + (u32)color_tilebottomleft.B + (u32)color_rgba8888.B ) >> 2 );
+					color_rgba8888.A = (u8)( ( (u32)color_tiletopleft.A + (u32)color_tiletopright.A + (u32)color_tilebottomleft.A + (u32)color_rgba8888.A ) >> 2 );
+					
+					#ifdef WORDS_BIGENDIAN
+					gfx3d_buffer[ downscaled_index + (x / RENDER_MAGNIFICATION) ] = BGRA8888_32_To_RGBA6665_32(color_rgba8888.Color);
+					#else
+					gfx3d_buffer[ downscaled_index + (x / RENDER_MAGNIFICATION) ] = BGRA8888_32Rev_To_RGBA6665_32Rev(color_rgba8888.Color);		// ピクセルフォーマットをRGBA6665に変換して値を保存
+					#endif
+				}
+			}
+		});
+	}
+	#else
+	static concurrency::array<u32, 2> ampTestBuffer1(768, 1024);
+	static concurrency::array<u32, 2> ampTestBuffer2(768, 1024);
+	static concurrency::array<u32, 2> ampTestBuffer3(192, 256);
+	
+	template <u32 RENDER_MAGNIFICATION>
+	void OpenGLRenderer_X432::DownscaleFramebuffer(const u32 *source_buffer)
+	{
+		#ifdef X432R_PROCESSTIME_CHECK
+		AutoStopTimeCounter timecounter(timeCounter_3DFinish1);
+		#endif
+		
+		const concurrency::array_view<u32, 2> highreso_buffer = ampTestBuffer1.section(0, 0, 192 * RENDER_MAGNIFICATION, 256 * RENDER_MAGNIFICATION);
+		const concurrency::array_view<u32, 2> highreso_buffer2( 192 * RENDER_MAGNIFICATION, 256 * RENDER_MAGNIFICATION, backBuffer.GetHighResolution3DBuffer() );
+		
+		const concurrency::array_view<u32, 2> source_buffer2 = ampTestBuffer2.section(0, 0, 192 * RENDER_MAGNIFICATION, 256 * RENDER_MAGNIFICATION);
+		const concurrency::array_view<u32, 2> downscaled_buffer = ampTestBuffer3.section(0, 0, 192, 256);
+		
+		const concurrency::array_view<u32, 2> source_buffer3( 192 * RENDER_MAGNIFICATION, 256 * RENDER_MAGNIFICATION, (u32 *)source_buffer );
+		const concurrency::array_view<u32, 2> downscaled_buffer2( 192, 256, (u32 *)gfx3d_convertedScreen );
+		
+		source_buffer3.copy_to(source_buffer2);
+		
+/*		const concurrency::array_view<u32, 2> highreso_buffer( 192 * RENDER_MAGNIFICATION, 256 * RENDER_MAGNIFICATION, backBuffer.GetHighResolution3DBuffer() );
+		const concurrency::array_view<const u32, 2> source_buffer2(192 * RENDER_MAGNIFICATION, 256 * RENDER_MAGNIFICATION, source_buffer);
+		const concurrency::array_view<u32, 2> downscaled_buffer( 192, 256, (u32 *)gfx3d_convertedScreen );
+*/		
+		
+		highreso_buffer.discard_data();		// バッファを書き込み専用に設定
+		downscaled_buffer.discard_data();
+		
+		concurrency::parallel_for_each
+		(
+			highreso_buffer.extent.tile<RENDER_MAGNIFICATION, RENDER_MAGNIFICATION>(),
+			[=](concurrency::tiled_index<RENDER_MAGNIFICATION, RENDER_MAGNIFICATION> index) restrict(amp)
+			{
+				u32 source_color = source_buffer2[index.global];
+				
+				highreso_buffer[ ( (192 * RENDER_MAGNIFICATION) - 1 ) - index.global[0] ][ index.global[1] ] = source_color;
+				
+				
+				// Bilinear縮小処理
+				tile_static u32 colors[4];
+				const u32 combined_index = ( index.local[0] << 16 ) | index.local[1];
+				
+				switch(combined_index)
+				{
+					case 0:
+						colors[0] = source_color;
+						break;
+					
+					case (RENDER_MAGNIFICATION - 1):
+						colors[1] = source_color;
+						break;
+					
+					case ( (RENDER_MAGNIFICATION - 1) << 16 ):
+						colors[2] = source_color;
+						break;
+					
+					case ( ( (RENDER_MAGNIFICATION - 1) << 16 ) | (RENDER_MAGNIFICATION - 1) ):
+						colors[3] = source_color;
+						break;
+				}
+				
+				index.barrier.wait();				// 処理範囲のデータ抽出が終わるのを待つ
+				
+				if(combined_index != 0) return;
+				
+				u32 a = 0;
+				u32 r = 0;
+				u32 g = 0;
+				u32 b = 0;
+				
+				for each(u32 color in colors)
+				{
+					a += color >> 24;
+					r += (color >> 16) & 0xFF;
+					g += (color >> 8) & 0xFF;
+					b += color & 0xFF;
+				}
+				
+				// RGBA8888 → RGBA6665
+				a >>= 5;		// (a / 4) >> 3
+				r >>= 4;		// (a / 4) >> 2
+				g >>= 4;
+				b >>= 4;
+				
+				downscaled_buffer[ 191 - index.tile[0] ][ index.tile[1] ] = (a << 24) | (b << 16) | (g << 8) | r;
+			}
+		);
+		
+/*		highreso_buffer.synchronize();
+		downscaled_buffer.synchronize();
+*/		
+/*		highreso_buffer.synchronize_async();
+		downscaled_buffer.synchronize_async();
+*/		
+		downscaled_buffer.copy_to(downscaled_buffer2);
+		highreso_buffer.copy_to(highreso_buffer2);
+	}
+	#endif
+	
+	
+	#if 1
+	template <u32 RENDER_MAGNIFICATION>
+	Render3DError OpenGLRenderer_X432::RenderFinish()
+	{
+		const unsigned int i = this->doubleBufferIndex;
+		
+		if( !this->gpuScreen3DHasNewData[i] )
+			return OGLERROR_NOERR;
+		
+		
+		// PBO + glMapBuffer
+		#ifdef X432R_PROCESSTIME_CHECK
+		timeCounter_3DFinish2.Start();
+		#endif
+		
+//		glBindBuffer( GL_PIXEL_PACK_BUFFER, this->ref->pboRenderDataID[i] );
+//		const u32 * const mapped_buffer = (u32 *)glMapBuffer(GL_PIXEL_PACK_BUFFER, GL_READ_ONLY);
+		glBindBuffer( GL_PIXEL_UNPACK_BUFFER, this->ref->pboRenderDataID[i] );
+		const u32 * const mapped_buffer = (u32 *)glMapBuffer(GL_PIXEL_UNPACK_BUFFER, GL_READ_ONLY);
+		
+		#ifdef X432R_PROCESSTIME_CHECK
+		timeCounter_3DFinish2.Stop();
+		#endif
+		
+		if(mapped_buffer != NULL)
+			DownscaleFramebuffer<RENDER_MAGNIFICATION>(mapped_buffer);
+		
+//		glUnmapBuffer(GL_PIXEL_PACK_BUFFER);
+//		glBindBuffer(GL_PIXEL_PACK_BUFFER, 0);
+		glUnmapBuffer(GL_PIXEL_UNPACK_BUFFER);
+		glBindBuffer(GL_PIXEL_UNPACK_BUFFER, 0);
+		
+		
+		glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0);
+		
+		this->gpuScreen3DHasNewData[i] = false;
+		
+		
+		#ifdef X432R_CUSTOMRENDERER_DEBUG
+		if(glFogEnabled && gfx3d.renderState.enableFogAlphaOnly)
+			X432R::ShowDebugMessage("OpenGL FogAlphaOnly");
+		
+//		if(gfx3d.renderState.wbuffer)
+//			ShowDebugMessage("OpenGL Depth: W-value");
+		#endif
+		
+		
+		return OGLERROR_NOERR;
+	}
+	#else
+	static u32 temp3DBuffer[1024 * 768];
+	
+	template <u32 RENDER_MAGNIFICATION>
+	Render3DError OpenGLRenderer_X432::RenderFinish()
+	{
+		const unsigned int i = this->doubleBufferIndex;
+		
+		if( !this->gpuScreen3DHasNewData[i] )
+			return OGLERROR_NOERR;
+		
+		
+		// PBO + glGetBufferSubData
+		#ifdef X432R_PROCESSTIME_CHECK
+		timeCounter_3DFinish2.Start();
+		#endif
+		
+//		glBindBuffer( GL_PIXEL_PACK_BUFFER, this->ref->pboRenderDataID[i] );
+		glBindBuffer( GL_PIXEL_UNPACK_BUFFER, this->ref->pboRenderDataID[i] );
+		
+		glGetBufferSubData(GL_PIXEL_UNPACK_BUFFER, 0, sizeof(u32) * 256 * 192 * RENDER_MAGNIFICATION * RENDER_MAGNIFICATION, temp3DBuffer);
+		
+		#ifdef X432R_PROCESSTIME_CHECK
+		timeCounter_3DFinish2.Stop();
+		#endif
+		
+		DownscaleFramebuffer<RENDER_MAGNIFICATION>(temp3DBuffer);
+		
+//		glBindBuffer(GL_PIXEL_PACK_BUFFER, 0);
+		glBindBuffer(GL_PIXEL_UNPACK_BUFFER, 0);
+		
+		glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0);
+		
+		
+		this->gpuScreen3DHasNewData[i] = false;
+		
+		
+		#ifdef X432R_CUSTOMRENDERER_DEBUG
+		if(glFogEnabled && gfx3d.renderState.enableFogAlphaOnly)
+			X432R::ShowDebugMessage("OpenGL FogAlphaOnly");
+		
+//		if(gfx3d.renderState.wbuffer)
+//			ShowDebugMessage("OpenGL Depth: W-value");
+		#endif
+		
+		
+		return OGLERROR_NOERR;
+	}
+	#endif
+	
+	#ifdef X432R_OPENGL_FOG_ENABLED
+	#ifndef X432R_OPENGL_CUSTOMFRAMEBUFFEROPERATION_TEST
+	// Fragment Shader GLSL 1.00
+	static const char *fragmentShader_X432 =
+	{"\
+		varying vec4 vtxPosition; \n\
+		varying vec2 vtxTexCoord; \n\
+		varying vec4 vtxColor; \n\
+		\n\
+		uniform sampler2D texMainRender; \n\
+		uniform sampler1D texToonTable; \n\
+		\n\
+		uniform int stateToonShadingMode; \n\
+		uniform bool stateEnableAlphaTest; \n\
+		uniform bool stateUseWDepth; \n\
+		uniform float stateAlphaTestRef; \n\
+		\n\
+		uniform int polyMode; \n\
+		uniform int polyID; \n\
+		uniform bool polyEnableTexture; \n\
+		\n\
+		uniform bool fogEnabled; \n\
+//		uniform bool fogAlphaOnly; \n\
+		uniform float fogOffset; \n\
+		uniform float fogStep; \n\
+		uniform float fogDensity[32]; \n\
+		\n\
+		void main() \n\
+		{ \n\
+			vec4 mainTexColor = (polyEnableTexture) ? texture2D(texMainRender, vtxTexCoord) : vec4(1.0, 1.0, 1.0, 1.0); \n\
+			vec4 tempFragColor = mainTexColor; \n\
+			\n\
+			if(polyMode == 0) \n\
+			{ \n\
+				tempFragColor = vtxColor * mainTexColor; \n\
+			} \n\
+			else if(polyMode == 1) \n\
+			{ \n\
+				tempFragColor.rgb = polyEnableTexture ? ( (mainTexColor.rgb * mainTexColor.a) + ( vtxColor.rgb * (1.0 - mainTexColor.a) ) ) : vtxColor.rgb; \n\
+				tempFragColor.a = vtxColor.a; \n\
+			} \n\
+			else if(polyMode == 2) \n\
+			{ \n\
+				vec3 toonColor = vec3( texture1D(texToonTable, vtxColor.r).rgb ); \n\
+				tempFragColor.rgb = (stateToonShadingMode == 0) ? (mainTexColor.rgb * toonColor.rgb) : min( (mainTexColor.rgb * vtxColor.rgb) + toonColor.rgb, 1.0 ); \n\
+				tempFragColor.a = mainTexColor.a * vtxColor.a; \n\
+			} \n\
+			else if(polyMode == 3) \n\
+			{ \n\
+				if(polyID != 0) \n\
+				{ \n\
+					tempFragColor = vtxColor; \n\
+				} \n\
+			} \n\
+			\n\
+			if( (tempFragColor.a == 0.0) || ( stateEnableAlphaTest && (tempFragColor.a < stateAlphaTestRef) ) ) \n\
+			{ \n\
+				discard; \n\
+			} \n\
+			\n\
+			float z; \n\
+			if(stateUseWDepth) \n\
+			{ \n\
+				z = vtxPosition.w / 4096.0; \n\
+			} \n\
+			else if(vtxPosition.w == 0.0) \n\
+			{ \n\
+//				z = ( (vtxPosition.z / 0.00000001) * 0.5 ) + 0.5; \n\
+				z = ( vtxPosition.z / (0.00000001 * 2.0) ) + 0.5; \n\
+			} \n\
+			else \n\
+			{ \n\
+//				z = ( (vtxPosition.z / vtxPosition.w) * 0.5 ) + 0.5; \n\
+				z = ( vtxPosition.z / (vtxPosition.w * 2.0) ) + 0.5; \n\
+			} \n\
+			z = clamp(z, 0.0, 1.0); \n\
+			gl_FragDepth = z; \n\
+			\n\
+			\n\
+			if( !fogEnabled ) \n\
+			{ \n\
+				gl_FragColor = tempFragColor; \n\
+			} \n\
+			else \n\
+			{ \n\
+				float fog_factor; \n\
+				\n\
+				if(z <= fogOffset) \n\
+				{ \n\
+					fog_factor = fogDensity[0]; \n\
+				} \n\
+				else if(fogStep == 0.0) \n\
+				{ \n\
+					fog_factor = fogDensity[31]; \n\
+				} \n\
+				else \n\
+				{ \n\
+					float fog_index = (z - fogOffset) / fogStep; \n\
+					fog_index = clamp(fog_index, 0.0, 31.0); \n\
+					fog_factor = fogDensity[ int(fog_index) ]; \n\
+				} \n\
+				\n\
+				if(fog_factor >= 1.0) \n\
+				{ \n\
+					gl_FragColor = tempFragColor; \n\
+				} \n\
+/*				else if(fogAlphaOnly) \n\
+				{ \n\
+					gl_FragColor.rgb = tempFragColor.rgb; \n\
+					gl_FragColor.a = mix(gl_Fog.color.a, tempFragColor.a, fog_factor); \n\
+				} \n\
+*/				else \n\
+				{ \n\
+//					gl_FragColor = mix(gl_Fog.color, tempFragColor, fog_factor); \n\
+					gl_FragColor.rgb = mix(gl_Fog.color.rgb, tempFragColor.rgb, fog_factor); \n\
+					gl_FragColor.a = tempFragColor.a; \n\
+				} \n\
+			} \n\
+		} \n\
+	"};
+	#elif !defined(X432R_OPENGL_CUSTOMFRAMEBUFFEROPERATION_TEST2)
+	// debug
+	static const char *fragmentShader_X432 =
+	{"\
+		varying vec4 vtxPosition; \n\
+		varying vec2 vtxTexCoord; \n\
+		varying vec4 vtxColor; \n\
+		\n\
+		uniform sampler2D texMainRender; \n\
+		uniform sampler1D texToonTable; \n\
+		\n\
+		uniform int stateToonShadingMode; \n\
+		uniform bool stateEnableAlphaTest; \n\
+		uniform bool stateUseWDepth; \n\
+		uniform float stateAlphaTestRef; \n\
+		\n\
+		uniform int polyMode; \n\
+		uniform int polyID; \n\
+		uniform bool polyEnableTexture; \n\
+		\n\
+		uniform bool fogEnabled; \n\
+		uniform bool fogAlphaOnly; \n\
+		uniform float fogOffset; \n\
+		uniform float fogStep; \n\
+		uniform float fogDensity[32]; \n\
+		\n\
+		uniform sampler2D renderTargetTexture_Color; \n\
+		uniform bool alphaBlendEnabled; \n\
+		uniform bool isNativeResolution2DPolygon; \n\
+		\n\
+		void main() \n\
+		{ \n\
+			vec2 texcoord_rendertarget = ( vtxPosition.xy / (vtxPosition.w * 2.0) ) + 0.5; \n\
+			vec4 last_color = texture2D(renderTargetTexture_Color, texcoord_rendertarget); \n\
+			\n\
+			vec4 mainTexColor = (polyEnableTexture) ? texture2D(texMainRender, vtxTexCoord) : vec4(1.0, 1.0, 1.0, 1.0); \n\
+			vec4 tempFragColor = mainTexColor; \n\
+			\n\
+			if(polyMode == 0) \n\
+			{ \n\
+				tempFragColor = vtxColor * mainTexColor; \n\
+			} \n\
+			else if(polyMode == 1) \n\
+			{ \n\
+				tempFragColor.rgb = polyEnableTexture ? ( (mainTexColor.rgb * mainTexColor.a) + ( vtxColor.rgb * (1.0 - mainTexColor.a) ) ) : vtxColor.rgb; \n\
+				tempFragColor.a = vtxColor.a; \n\
+			} \n\
+			else if(polyMode == 2) \n\
+			{ \n\
+				vec3 toonColor = vec3( texture1D(texToonTable, vtxColor.r).rgb ); \n\
+				tempFragColor.rgb = (stateToonShadingMode == 0) ? (mainTexColor.rgb * toonColor.rgb) : min( (mainTexColor.rgb * vtxColor.rgb) + toonColor.rgb, 1.0 ); \n\
+				tempFragColor.a = mainTexColor.a * vtxColor.a; \n\
+			} \n\
+			else if(polyMode == 3) \n\
+			{ \n\
+				if(polyID != 0) \n\
+				{ \n\
+					tempFragColor = vtxColor; \n\
+				} \n\
+			} \n\
+			\n\
+			if( (tempFragColor.a == 0.0) || ( stateEnableAlphaTest && (tempFragColor.a < stateAlphaTestRef) ) ) \n\
+			{ \n\
+				discard; \n\
+			} \n\
+			\n\
+			float z; \n\
+			if(stateUseWDepth) \n\
+			{ \n\
+				z = vtxPosition.w / 4096.0; \n\
+			} \n\
+			else if(vtxPosition.w == 0.0) \n\
+			{ \n\
+//				z = ( (vtxPosition.z / 0.00000001) * 0.5 ) + 0.5; \n\
+				z = ( vtxPosition.z / (0.00000001 * 2.0) ) + 0.5; \n\
+			} \n\
+			else \n\
+			{ \n\
+//				z = ( (vtxPosition.z / vtxPosition.w) * 0.5 ) + 0.5; \n\
+				z = ( vtxPosition.z / (vtxPosition.w * 2.0) ) + 0.5; \n\
+			} \n\
+			z = clamp(z, 0.0, 1.0); \n\
+			\n\
+			//--- fog --- \n\
+			float fog_factor = 1.0; \n\
+			if(fogEnabled) \n\
+			{ \n\
+				if(z <= fogOffset) \n\
+				{ \n\
+					fog_factor = fogDensity[0]; \n\
+				} \n\
+				else if(fogStep == 0.0) \n\
+				{ \n\
+					fog_factor = fogDensity[31]; \n\
+				} \n\
+				else \n\
+				{ \n\
+					float fog_index = (z - fogOffset) / fogStep; \n\
+					fog_index = clamp(fog_index, 0.0, 31.0); \n\
+					fog_factor = fogDensity[ int(fog_index) ]; \n\
+				} \n\
+				\n\
+				if( (fog_factor < 1.0) && !fogAlphaOnly ) \n\
+				{ \n\
+					tempFragColor.rgb = mix(gl_Fog.color.rgb, tempFragColor.rgb, fog_factor); \n\
+				} \n\
+			} \n\
+			\n\
+			//--- output --- \n\
+			vec4 final_color; \n\
+			if( (last_color.a == 0.0) || (tempFragColor.a >= 1.0) || !alphaBlendEnabled ) \n\
+			{ \n\
+				final_color = tempFragColor; \n\
+			} \n\
+			else \n\
+			{ \n\
+				final_color = mix(last_color, tempFragColor, tempFragColor.a); \n\
+			} \n\
+			\n\
+//			if( (fog_factor < 1.0) && (gl_Fog.color.a < 1.0) ) \n\
+			if( (fog_factor < 1.0) && fogAlphaOnly && (gl_Fog.color.a < 1.0) ) \n\
+			{ \n\
+				final_color.a = mix(gl_Fog.color.a, tempFragColor.a, fog_factor); \n\
+			} \n\
+			\n\
+			gl_FragColor = final_color; \n\
+			gl_FragDepth = z; \n\
+			\n\
+			//--- debug ---> \n\
+//			gl_FragColor = mix( final_color, ( (texcoord_rendertarget.x < 0.0) || (texcoord_rendertarget.x > 1.0) || (texcoord_rendertarget.y < 0.0) || (texcoord_rendertarget.y > 1.0) ) ? vec4(1.0, 0.0, 0.0, 1.0) : vec4(0.0, texcoord_rendertarget.x, texcoord_rendertarget.y, 1.0), 0.5 ); \n\
+//			if( !isNativeResolution2DPolygon ) gl_FragColor = mix( final_color, vec4(1.0, 0.0, 0.0, 1.0), 0.5 ); \n\
+			if( !isNativeResolution2DPolygon || (tempFragColor.a <= 0.95) ) gl_FragColor = mix( final_color, vec4(1.0, 0.0, 0.0, 1.0), 0.5 ); \n\
+			//<--- debug --- \n\
+		} \n\
+	"};
+	#else
+	// Fragment Shader GLSL 1.00
+	static const char *fragmentShader_X432 =
+	{"\
+		varying vec4 vtxPosition; \n\
+		varying vec2 vtxTexCoord; \n\
+		varying vec4 vtxColor; \n\
+		\n\
+		uniform sampler2D texMainRender; \n\
+		uniform sampler1D texToonTable; \n\
+		\n\
+		uniform int stateToonShadingMode; \n\
+		uniform bool stateEnableAlphaTest; \n\
+		uniform bool stateUseWDepth; \n\
+		uniform float stateAlphaTestRef; \n\
+		\n\
+		uniform int polyMode; \n\
+		uniform int polyID; \n\
+		uniform bool polyEnableTexture; \n\
+		\n\
+		uniform bool fogEnabled; \n\
+		uniform bool fogAlphaOnly; \n\
+		uniform float fogOffset; \n\
+		uniform float fogStep; \n\
+		uniform float fogDensity[32]; \n\
+		\n\
+		uniform sampler2D renderTargetTexture_Color; \n\
+		uniform sampler2D renderTargetTexture_DepthStencil; \n\
+		uniform float depthComparisionThreshold; \n\
+		uniform bool alphaDepthWriteEnabled; \n\
+		uniform float brightFactor; \n\
+		uniform bool isNativeResolution2DPolygon; \n\
+		\n\
+		void main() \n\
+		{ \n\
+			vec2 texcoord_rendertarget = ( vtxPosition.xy / (vtxPosition.w * 2.0) ) + 0.5; \n\
+			vec4 last_color = texture2D(renderTargetTexture_Color, texcoord_rendertarget); \n\
+			vec4 last_depthstencil = texture2D(renderTargetTexture_DepthStencil, texcoord_rendertarget); \n\
+			float last_depth = last_depthstencil[0]; \n\
+			float last_polygonid = last_depthstencil[1]; \n\
+			float last_shadow = last_depthstencil[2]; \n\
+			\n\
+			vec4 mainTexColor = (polyEnableTexture) ? texture2D(texMainRender, vtxTexCoord) : vec4(1.0, 1.0, 1.0, 1.0); \n\
+			vec4 tempFragColor = mainTexColor; \n\
+			\n\
+			if(polyMode == 0) \n\
+			{ \n\
+				tempFragColor = vtxColor * mainTexColor; \n\
+			} \n\
+			else if(polyMode == 1) \n\
+			{ \n\
+				tempFragColor.rgb = polyEnableTexture ? ( (mainTexColor.rgb * mainTexColor.a) + ( vtxColor.rgb * (1.0 - mainTexColor.a) ) ) : vtxColor.rgb; \n\
+				tempFragColor.a = vtxColor.a; \n\
+			} \n\
+			else if(polyMode == 2) \n\
+			{ \n\
+				vec3 toonColor = vec3( texture1D(texToonTable, vtxColor.r).rgb ); \n\
+				tempFragColor.rgb = (stateToonShadingMode == 0) ? (mainTexColor.rgb * toonColor.rgb) : min( (mainTexColor.rgb * vtxColor.rgb) + toonColor.rgb, 1.0 ); \n\
+				tempFragColor.a = mainTexColor.a * vtxColor.a; \n\
+			} \n\
+			else if(polyMode == 3) \n\
+			{ \n\
+				if(polyID != 0) \n\
+				{ \n\
+					tempFragColor = vtxColor; \n\
+				} \n\
+			} \n\
+			\n\
+			if( (tempFragColor.a == 0.0) || ( stateEnableAlphaTest && (tempFragColor.a < stateAlphaTestRef) ) ) \n\
+			{ \n\
+				discard; \n\
+			} \n\
+			\n\
+			float z; \n\
+			if(stateUseWDepth) \n\
+			{ \n\
+				z = vtxPosition.w / 4096.0; \n\
+			} \n\
+			else if(vtxPosition.w == 0.0) \n\
+			{ \n\
+//				z = ( (vtxPosition.z / 0.00000001) * 0.5 ) + 0.5; \n\
+				z = ( vtxPosition.z / (0.00000001 * 2.0) ) + 0.5; \n\
+			} \n\
+			else \n\
+			{ \n\
+//				z = ( (vtxPosition.z / vtxPosition.w) * 0.5 ) + 0.5; \n\
+				z = ( vtxPosition.z / (vtxPosition.w * 2.0) ) + 0.5; \n\
+			} \n\
+			z = clamp(z, 0.0, 1.0); \n\
+			\n\
+			//--- custom depth test --- \n\
+			bool depthtest_failed = false; \n\
+			if( (depthComparisionThreshold > 0.0) )		// DepthFunc: GL_EQUAL \n\
+			{ \n\
+				if( abs(z - last_depth) > depthComparisionThreshold ) \n\
+					depthtest_failed = true; \n\
+				else \n\
+					z = last_depth; \n\
+			} \n\
+			else if(z >= last_depth)					// DepthFunc: GL_LESS \n\
+			{ \n\
+				depthtest_failed = true; \n\
+			} \n\
+			if( (tempFragColor.a < 1.0) && !alphaDepthWriteEnabled ) \n\
+			{ \n\
+				z = last_depth; \n\
+			} \n\
+			\n\
+			//--- custom stencil test --- \n\
+			float polygon_id = float(polyID); \n\
+			float shadow_flag = last_shadowflag; \n\
+/*			if(polygon_id == last_polygonid) \n\
+			{ \n\
+				discard; \n\
+			}\n\
+*/			if(depthtest_failed) \n\
+			{ \n\
+				if( (polyMode != 3) || (polyID != 0) ) \n\
+					discard; \n\
+				else \n\
+				{ \n\
+					tempFragColor = last_color; \n\
+					shadow_flag = shadow_flag + 1.0; \n\
+				} \n\
+			}\n\
+			if( (polyMode == 3) && (polyID != 0) ) \n\
+			{ \n\
+				if(shadow_flag == 0.0) \n\
+					discard; \n\
+				else \n\
+					shadow_flag = shadow_flag - 1.0; \n\
+			} \n\
+			\n\
+			//--- fog --- \n\
+			float fog_factor = 1.0; \n\
+			if(fogEnabled) \n\
+			{ \n\
+				if(z <= fogOffset) \n\
+				{ \n\
+					fog_factor = fogDensity[0]; \n\
+				} \n\
+				else if(fogStep == 0.0) \n\
+				{ \n\
+					fog_factor = fogDensity[31]; \n\
+				} \n\
+				else \n\
+				{ \n\
+					float fog_index = (z - fogOffset) / fogStep; \n\
+					fog_index = clamp(fog_index, 0.0, 31.0); \n\
+					fog_factor = fogDensity[ int(fog_index) ]; \n\
+				} \n\
+				\n\
+				if( (fog_factor < 1.0) && !fogAlphaOnly ) \n\
+				{ \n\
+					tempFragColor.rgb = mix(gl_Fog.color.rgb, tempFragColor.rgb, fog_factor); \n\
+				} \n\
+			} \n\
+			\n\
+			//--- output --- \n\
+			vec4 final_color; \n\
+			if( (tempFragColor.a == 1.0) || (last_color.a == 0.0) ) \n\
+			{ \n\
+				final_color = tempFragColor; \n\
+			} \n\
+			else \n\
+			{ \n\
+				final_color = mix(last_color, tempFragColor, tempFragColor.a); \n\
+			} \n\
+			\n\
+//			if( (fog_factor < 1.0) && (gl_Fog.color.a < 1.0) ) \n\
+			if( (fog_factor < 1.0) && fogAlphaOnly && (gl_Fog.color.a < 1.0) ) \n\
+			{ \n\
+				final_color.a = mix(gl_Fog.color.a, tempFragColor.a, fog_factor); \n\
+			} \n\
+			\n\
+			gl_FragData[0] = final_color; \n\
+			gl_FragData[1] = vec4(z, polygon_id, shadow_flag, 0.0); \n\
+		} \n\
+	"};
+	#endif
+	#endif
+	
+	
+	template <u32 RENDER_MAGNIFICATION>
+	Render3DError OpenGLRenderer_X432::InitExtensions()
+	{
+		Render3DError error = OGLERROR_NOERR;
+		OGLRenderRef &OGLRef = *this->ref;
+		
+		// Get OpenGL extensions
+		std::set<std::string> oglExtensionSet;
+		this->GetExtensionSet(&oglExtensionSet);
+		
+		// Initialize OpenGL
+		this->InitTables();
+		
+		// Load and create shaders. Return on any error, since a v2.0 driver will assume that shaders are available.
+		this->isShaderSupported	= true;
+		
+		std::string vertexShaderProgram;
+		std::string fragmentShaderProgram;
+		
+		
+		#ifndef X432R_OPENGL_FOG_ENABLED
+		error = this->LoadShaderPrograms(&vertexShaderProgram, &fragmentShaderProgram);
+		#else
+		vertexShaderProgram = vertexShader_100;
+		fragmentShaderProgram = fragmentShader_X432;
+		#endif
+		
+		
+/*		if(error != OGLERROR_NOERR)
+		{
+			this->isShaderSupported = false;
+			return error;
+		}
+*/		
+		error = this->CreateShaders(&vertexShaderProgram, &fragmentShaderProgram);
+		
+		if(error != OGLERROR_NOERR)
+		{
+			this->isShaderSupported = false;
+			return error;
+		}
+		
+		
+		#ifdef X432R_OPENGL_FOG_ENABLED
+		uniformFogEnabled = glGetUniformLocation(OGLRef.shaderProgram, "fogEnabled");
+		uniformFogOffset = glGetUniformLocation(OGLRef.shaderProgram, "fogOffset");
+		uniformFogStep = glGetUniformLocation(OGLRef.shaderProgram, "fogStep");
+		uniformFogDensity = glGetUniformLocation(OGLRef.shaderProgram, "fogDensity");
+		#endif
+		
+		#ifdef X432R_OPENGL_CUSTOMFRAMEBUFFEROPERATION_TEST
+		GLint max_texture_units, max_color_attachments;
+		
+		glGetIntegerv(GL_MAX_TEXTURE_IMAGE_UNITS, &max_texture_units);
+		if(max_texture_units < OGLRequiredTextureUnitCount) return OGLERROR_FEATURE_UNSUPPORTED;
+		
+		uniformFogAlphaOnly = glGetUniformLocation(OGLRef.shaderProgram, "fogAlphaOnly");
+		uniformAlphaBlendEnabled = glGetUniformLocation(OGLRef.shaderProgram, "alphaBlendEnabled");
+		
+		uniformIsNativeResolution2DPolygon = glGetUniformLocation(OGLRef.shaderProgram, "isNativeResolution2DPolygon");
+		
+		
+		#ifdef X432R_OPENGL_CUSTOMFRAMEBUFFEROPERATION_TEST2
+		if(glClearBufferfv == NULL) return OGLERROR_FEATURE_UNSUPPORTED;		// OpenGL 3.0
+		
+		
+		glGetIntegerv(GL_MAX_COLOR_ATTACHMENTS, &max_color_attachments);
+		if(max_color_attachments < 2) return OGLERROR_FEATURE_UNSUPPORTED;
+		
+		uniformDepthComparisionThreshold = glGetUniformLocation(OGLRef.shaderProgram, "depthComparisionThreshold");
+		uniformAlphaDepthWriteEnabled = glGetUniformLocation(OGLRef.shaderProgram, "alphaDepthWriteEnabled");
+		#endif
+		#endif
+		
+		
+		this->CreateToonTable();
+		
+		this->isVBOSupported = true;
+		this->CreateVBOs();
+		
+		this->isPBOSupported	= this->IsExtensionPresent(&oglExtensionSet, "GL_ARB_vertex_buffer_object") &&
+								 (this->IsExtensionPresent(&oglExtensionSet, "GL_ARB_pixel_buffer_object") ||
+								  this->IsExtensionPresent(&oglExtensionSet, "GL_EXT_pixel_buffer_object"));
+		if(this->isPBOSupported)
+		{
+			this->CreatePBOs<RENDER_MAGNIFICATION>();
+		}
+	
+		this->isVAOSupported	= this->isShaderSupported &&
+								  this->isVBOSupported &&
+								 (this->IsExtensionPresent(&oglExtensionSet, "GL_ARB_vertex_array_object") ||
+								  this->IsExtensionPresent(&oglExtensionSet, "GL_APPLE_vertex_array_object"));
+		if(this->isVAOSupported)
+		{
+			this->CreateVAOs();
+		}
+	
+		// Don't use ARB versions since we're using the EXT versions for backwards compatibility.
+		this->isFBOSupported	= this->IsExtensionPresent(&oglExtensionSet, "GL_EXT_framebuffer_object") &&
+								  this->IsExtensionPresent(&oglExtensionSet, "GL_EXT_framebuffer_blit") &&
+								  this->IsExtensionPresent(&oglExtensionSet, "GL_EXT_packed_depth_stencil");
+		if(this->isFBOSupported)
+		{
+			error = this->CreateFBOs<RENDER_MAGNIFICATION>();
+			if(error != OGLERROR_NOERR)
+			{
+				OGLRef.fboRenderID = 0;
+				this->isFBOSupported = false;
+			}
+		}
+		else
+		{
+			OGLRef.fboRenderID = 0;
+			INFO("OpenGL: FBOs are unsupported. Some emulation features will be disabled.\n");
+		}
+		
+		// Don't use ARB versions since we're using the EXT versions for backwards compatibility.
+		this->isMultisampledFBOSupported	= this->IsExtensionPresent(&oglExtensionSet, "GL_EXT_framebuffer_object") &&
+											  this->IsExtensionPresent(&oglExtensionSet, "GL_EXT_framebuffer_blit") &&
+											  this->IsExtensionPresent(&oglExtensionSet, "GL_EXT_packed_depth_stencil") &&
+											  this->IsExtensionPresent(&oglExtensionSet, "GL_EXT_framebuffer_multisample");
+		
+		
+		#ifndef X432R_OPENGL_CUSTOMFRAMEBUFFEROPERATION_TEST
+		if(this->isMultisampledFBOSupported)
+		{
+			error = this->CreateMultisampledFBO<RENDER_MAGNIFICATION>();
+			
+			if(error != OGLERROR_NOERR)
+			{
+				OGLRef.selectedRenderingFBO = 0;
+				this->isMultisampledFBOSupported = false;
+			}
+		}
+		else
+		{
+			OGLRef.selectedRenderingFBO = 0;
+			INFO("OpenGL: Multisampled FBOs are unsupported. Multisample antialiasing will be disabled.\n");
+		}
+		
+		if( !isMultisampledFBOSupported )
+		{
+			CommonSettings.GFX3D_Renderer_Multisample = false;
+			#ifdef X432R_LOWQUALITYMODE_TEST
+			lowQualityMsaaEnabled = false;
+			#endif
+		}
+		#else
+		OGLRef.selectedRenderingFBO = 0;
+		this->isMultisampledFBOSupported = false;
+		#endif
+		
+		
+		this->InitTextures();
+		this->InitFinalRenderStates(&oglExtensionSet); // This must be done last
+		
+		
+		return OGLERROR_NOERR;
+	}
+	
+	
+	GPU3DInterface gpu3Dgl_X2 =
+	{
+		"OpenGL X2 (512x384)",
+		X432R::OGLInit<2>,
+		OGLReset,
+		OGLClose,
+		X432R::OGLRender<2>,
+		X432R::OGLRenderFinish<2>,
+		OGLVramReconfigureSignal
+	};
+	
+	GPU3DInterface gpu3Dgl_X3 =
+	{
+		"OpenGL X3 (768x576)",
+		X432R::OGLInit<3>,
+		OGLReset,
+		OGLClose,
+		X432R::OGLRender<3>,
+		X432R::OGLRenderFinish<3>,
+		OGLVramReconfigureSignal
+	};
+	
+	GPU3DInterface gpu3Dgl_X4 =
+	{
+		"OpenGL X4 (1024x768)",
+		X432R::OGLInit<4>,
+		OGLReset,
+		OGLClose,
+		X432R::OGLRender<4>,
+		X432R::OGLRenderFinish<4>,
+		OGLVramReconfigureSignal
+	};
+}
+
+#endif
Index: OGLRender.h
===================================================================
--- OGLRender.h	(revision 5164)
+++ OGLRender.h	(working copy)
@@ -607,4 +607,108 @@
 	virtual Render3DError RenderFinish();
 };
 
+
+//---CUSTOM--->
+#include "X432R_BuildSwitch.h"
+
+/*
+#ifdef X432R_MENUITEMMOD_ENABLED
+namespace X432R
+{
+	void ChangeOpenGLTextureFilter(bool enable);
+	bool IsOpenGLTextureFilterEnabled();
+	void ToggleOpenGLTextureFilter();
+}
 #endif
+*/
+
+#ifdef X432R_CUSTOMRENDERER_ENABLED
+namespace X432R
+{
+//	bool CheckOpenGLExtensionSupported(std::string extension_name);
+//	bool CheckOpenGLExtensionSupported_PBO();
+	
+	
+	class OpenGLRenderer_X432 : public OpenGLRenderer_2_1
+	{
+		protected:
+		GLuint highResolutionFramebuffer;
+		GLuint highResolutionRenderbuffer_Color;
+		GLuint highResolutionRenderbuffer_DepthStencil;
+		
+		#ifdef X432R_OPENGL_FOG_ENABLED
+		GLuint uniformFogEnabled;
+		GLuint uniformFogOffset;
+		GLuint uniformFogStep;
+		GLuint uniformFogDensity;
+		
+		bool glFogEnabled;
+		#endif
+		
+		#ifdef X432R_OPENGL_CUSTOMFRAMEBUFFEROPERATION_TEST
+		GLuint uniformFogAlphaOnly;
+		GLuint uniformAlphaBlendEnabled;
+		
+		GLuint uniformIsNativeResolution2DPolygon;
+		#endif
+		
+		#ifdef X432R_OPENGL_CUSTOMFRAMEBUFFEROPERATION_TEST2
+		GLuint uniformDepthComparisionThreshold;
+		GLuint uniformAlphaDepthWriteEnabled;
+		#endif
+		
+		#if defined(X432R_OPENGL_CUSTOMSTENCILTEST) && ( !defined(X432R_OPENGL_2PASSSHADOW_TEST) || defined(X432R_CUSTOMRENDERER_DEBUG) )
+		std::vector<u8> shadowPolygonIDs;
+		#endif
+		
+		template <u32 RENDER_MAGNIFICATION> void DownscaleFramebuffer(const u32 * const sourcebuffer_begin);
+		
+		#ifdef X432R_OPENGL_2PASSSHADOW_TEST
+		void SetupShadowPolygon(const POLY *thePoly, bool first_pass);
+		#endif
+		
+		
+		template <u32 RENDER_MAGNIFICATION> Render3DError CreatePBOs();
+		virtual void DestroyPBOs();
+		template <u32 RENDER_MAGNIFICATION> Render3DError CreateFBOs();
+		virtual void DestroyFBOs();
+		template <u32 RENDER_MAGNIFICATION> Render3DError CreateMultisampledFBO();
+		virtual void DestroyMultisampledFBO();
+		
+		virtual Render3DError SelectRenderingFramebuffer();
+		template <u32 RENDER_MAGNIFICATION> Render3DError DownsampleFBO();
+		template <u32 RENDER_MAGNIFICATION> Render3DError ReadBackPixels();
+		
+		virtual Render3DError BeginRender(const GFX3D_State *renderState);
+		template <u32 RENDER_MAGNIFICATION> Render3DError DoRender(const GFX3D_State *renderState, const VERTLIST *vertList, const POLYLIST *polyList, const INDEXLIST *indexList);
+		template <u32 RENDER_MAGNIFICATION> Render3DError EndRender(const u64 frameCount);
+		
+		template <u32 RENDER_MAGNIFICATION> Render3DError ClearFramebuffer(const GFX3D_State *renderState);
+		#ifdef X432R_CUSTOMRENDERER_CLEARIMAGE_ENABLED
+		template <u32 RENDER_MAGNIFICATION> Render3DError ClearUsingImage() const;
+		#endif
+		virtual Render3DError ClearUsingValues(const u8 r, const u8 g, const u8 b, const u8 a, const u32 clearDepth, const u8 clearStencil) const;
+		
+		virtual Render3DError SetupPolygon(const POLY *thePoly);
+		template <u32 RENDER_MAGNIFICATION> Render3DError SetupViewport(const u32 viewportValue);
+		
+		
+		public:
+		
+		OpenGLRenderer_X432();
+		template <u32 RENDER_MAGNIFICATION> Render3DError InitExtensions();
+		
+		template <u32 RENDER_MAGNIFICATION> Render3DError Render(const GFX3D_State *renderState, const VERTLIST *vertList, const POLYLIST *polyList, const INDEXLIST *indexList, const u64 frameCount);
+		template <u32 RENDER_MAGNIFICATION> Render3DError RenderFinish();
+	};
+	
+	
+	extern GPU3DInterface gpu3Dgl_X2;
+	extern GPU3DInterface gpu3Dgl_X3;
+	extern GPU3DInterface gpu3Dgl_X4;
+}
+#endif
+//<---CUSTOM---
+
+
+#endif
Index: path.cpp
===================================================================
--- path.cpp	(revision 5164)
+++ path.cpp	(working copy)
@@ -58,30 +58,46 @@
 
 std::string Path::GetFileDirectoryPath(std::string filePath)
 {
-	if (filePath.empty()) {
-		return "";
-	}
+	if( filePath.empty() ) return "";
 	
+	#if !defined(X432R_FILEPATHMOD_ENABLED) || !defined(HOST_WINDOWS)
 	size_t i = filePath.find_last_of(ALL_DIRECTORY_DELIMITER_STRING);
-	if (i == std::string::npos) {
-		return filePath;
-	}
+	if(i == std::string::npos) return filePath;
 	
 	return filePath.substr(0, i);
+	#else
+	char path[MAX_PATH] = {0};
+	strncpy( path, filePath.c_str(), sizeof(path) );
+	
+	if( filePath.length() >= MAX_PATH )
+		path[MAX_PATH - 1] = '\0';
+	
+	PathRemoveFileSpec(path);
+	
+	return std::string(path);
+	#endif
 }
 
 std::string Path::GetFileNameFromPath(std::string filePath)
 {
-	if (filePath.empty()) {
-		return "";
-	}
+	if( filePath.empty() ) return "";
 	
+	#if !defined(X432R_FILEPATHMOD_ENABLED) || !defined(HOST_WINDOWS)
 	size_t i = filePath.find_last_of(ALL_DIRECTORY_DELIMITER_STRING);
-	if (i == std::string::npos) {
-		return filePath;
-	}
+	if(i == std::string::npos) return filePath;
 	
 	return filePath.substr(i + 1);
+	#else
+	char path[MAX_PATH] = {0};
+	strncpy( path, filePath.c_str(), sizeof(path) );
+	
+	if( filePath.length() >= MAX_PATH )
+		path[MAX_PATH - 1] = '\0';
+	
+	PathStripPath(path);
+	
+	return std::string(path);
+	#endif
 }
 
 std::string Path::GetFileNameWithoutExt(std::string fileName)
@@ -90,6 +106,7 @@
 		return "";
 	}
 	
+	#if !defined(X432R_FILEPATHMOD_ENABLED) || !defined(HOST_WINDOWS)
 	size_t i = fileName.find_last_of(FILE_EXT_DELIMITER_CHAR);
 	if (i == std::string::npos) {
 		return fileName;
@@ -96,10 +113,22 @@
 	}
 	
 	return fileName.substr(0, i);
+	#else
+	char path[MAX_PATH] = {0};
+	strncpy( path, fileName.c_str(), sizeof(path) );
+	
+	if( fileName.length() >= MAX_PATH )
+		path[MAX_PATH - 1] = '\0';
+	
+	PathRemoveExtension(path);
+	
+	return std::string(path);
+	#endif
 }
 
 std::string Path::ScrubInvalid(std::string str)
 {
+	#if !defined(X432R_FILEPATHMOD_ENABLED) || !defined(HOST_WINDOWS)
 	for (std::string::iterator it(str.begin()); it != str.end(); ++it)
 	{
 		bool ok = true;
@@ -117,6 +146,40 @@
 	}
 
 	return str;
+	#else
+	const char length = str.length();
+	char buffer[1024];
+	char *c;
+	u32 size;
+	u32 i, j;
+	
+	strncpy( buffer, str.c_str(), 1024 );
+	
+	if(length >= 1024)
+		buffer[1024 - 1] = '\0';
+	
+	for(i = 0; i < length; i += size)
+	{
+		c = buffer + i;
+		
+		if(*c == '\0') break;
+		
+		size = _mbclen( (unsigned char *)c );		// 文字のバイト数を取得
+		
+		if(size <= 0) break;
+		if(size != 1) continue;
+		
+		for( j = 0; j < ARRAY_SIZE(InvalidPathChars); ++j )
+		{
+			if( InvalidPathChars[j] != *c ) continue;
+			
+			*c = '*';
+			break;
+		}
+	}
+	
+	return (std::string)buffer;
+	#endif
 }
 
 std::string Path::GetFileNameFromPathWithoutExt(std::string filePath)
@@ -136,6 +199,7 @@
 		return "";
 	}
 	
+	#if !defined(X432R_FILEPATHMOD_ENABLED) || !defined(HOST_WINDOWS)
 	size_t i = fileName.find_last_of(FILE_EXT_DELIMITER_CHAR);
 	if (i == std::string::npos) {
 		return fileName;
@@ -142,6 +206,18 @@
 	}
 	
 	return fileName.substr(i + 1);
+	#else
+	char path[MAX_PATH] = {0};
+	char *extension;
+	strncpy( path, fileName.c_str(), sizeof(path) );
+	
+	if( fileName.length() >= MAX_PATH )
+		path[MAX_PATH - 1] = '\0';
+	
+	extension = PathFindExtension(path);
+	
+	return std::string(extension);
+	#endif
 }
 
 //-----------------------------------
Index: path.h
===================================================================
--- path.h	(revision 5164)
+++ path.h	(working copy)
@@ -35,6 +35,17 @@
 #include "time.h"
 #include "utils/xstring.h"
 
+
+//---CUSTOM--->
+#include "X432R_BuildSwitch.h"
+
+#if defined(X432R_FILEPATHMOD_ENABLED) && defined(HOST_WINDOWS)
+#include <shlwapi.h>
+#include <mbstring.h>
+#endif
+//<---CUSTOM---
+
+
 #ifdef HOST_WINDOWS
 	#define FILE_EXT_DELIMITER_CHAR		'.'
 	#define DIRECTORY_DELIMITER_CHAR	'\\'
@@ -123,8 +134,14 @@
 		path = std::string(filename);
 
 		//extract the internal part of the logical rom name
+		#if !defined(X432R_FILEPATHMOD_ENABLED) || !defined(HOST_WINDOWS)
 		std::vector<std::string> parts = tokenize_str(filename,"|");
 		SetRomName(parts[parts.size()-1].c_str());
+		#else
+		const char * const name = (char *)_mbschr( (unsigned char *)filename, '|' );
+		
+		SetRomName( (name == NULL) ? filename : (name + 1) );
+		#endif
 		LoadModulePath();
 #if !defined(WIN32) && !defined(DESMUME_COCOA)
 		ReadPathSettings();
Index: rasterize.cpp
===================================================================
--- rasterize.cpp	(revision 5164)
+++ rasterize.cpp	(working copy)
@@ -124,8 +124,13 @@
 //	verts[vert_index] = &rawvert;
 //}
 
+#ifndef X432R_CUSTOMRENDERER_ENABLED
 static Fragment _screen[GFX3D_FRAMEBUFFER_WIDTH*GFX3D_FRAMEBUFFER_HEIGHT];
 static FragmentColor _screenColor[GFX3D_FRAMEBUFFER_WIDTH*GFX3D_FRAMEBUFFER_HEIGHT];
+#else
+static Fragment _screen[1024 * 768];
+static FragmentColor _screenColor[1024 * 768];
+#endif
 
 static FORCEINLINE int iround(float f) {
 	return (int)f; //lol
@@ -754,8 +759,17 @@
 	}
 
 	//draws a single scanline
+	#ifndef X432R_SOFTRAST_OPTIMIZE_TEST
 	FORCEINLINE void drawscanline(edge_fx_fl *pLeft, edge_fx_fl *pRight, bool lineHack)
 	{
+	#else
+	template<u32 RENDER_MAGNIFICATION>
+	FORCEINLINE void drawscanline(edge_fx_fl *pLeft, edge_fx_fl *pRight, bool lineHack)
+	{
+		static const u32 ENGINE_WIDTH = 256 * RENDER_MAGNIFICATION;
+		static const u32 ENGINE_HEIGHT = 192 * RENDER_MAGNIFICATION;
+	#endif
+		
 		int XStart = pLeft->X;
 		int width = pRight->X - XStart;
 
@@ -792,10 +806,15 @@
 			(pRight->color[1].curr - color[1]) * invWidth,
 			(pRight->color[2].curr - color[2]) * invWidth };
 
+		#ifndef X432R_SOFTRAST_OPTIMIZE_TEST
 		int adr = (pLeft->Y*engine->width)+XStart;
+		#else
+		int adr = (pLeft->Y * ENGINE_WIDTH) + XStart;
+		#endif
 
 		//CONSIDER: in case some other math is wrong (shouldve been clipped OK), we might go out of bounds here.
 		//better check the Y value.
+		#ifndef X432R_CUSTOMRENDERER_ENABLED
 		if(RENDERER && (pLeft->Y<0 || pLeft->Y>191)) {
 			printf("rasterizer rendering at y=%d! oops!\n",pLeft->Y);
 			return;
@@ -804,6 +823,19 @@
 			printf("rasterizer rendering at y=%d! oops!\n",pLeft->Y);
 			return;
 		}
+		#elif !defined(X432R_SOFTRAST_OPTIMIZE_TEST)
+		if( (pLeft->Y < 0) || (pLeft->Y >= engine->height) )
+		{
+			printf("rasterizer rendering at y=%d! oops!\n", pLeft->Y);
+			return;
+		}
+		#else
+		if( (pLeft->Y < 0) || (pLeft->Y >= ENGINE_HEIGHT) )
+		{
+			printf("rasterizer rendering at y=%d! oops!\n", pLeft->Y);
+			return;
+		}
+		#endif
 
 		int x = XStart;
 
@@ -825,6 +857,8 @@
 			width -= -x;
 			x = 0;
 		}
+		
+		#ifndef X432R_CUSTOMRENDERER_ENABLED
 		if(x+width > (RENDERER?GFX3D_FRAMEBUFFER_WIDTH:engine->width))
 		{
 			if(RENDERER && !lineHack)
@@ -834,6 +868,29 @@
 			}
 			width = (RENDERER?GFX3D_FRAMEBUFFER_WIDTH:engine->width)-x;
 		}
+		#elif !defined(X432R_SOFTRAST_OPTIMIZE_TEST)
+		if( (x + width) > engine->width )
+		{
+			if(RENDERER && !lineHack)
+			{
+				printf("rasterizer rendering at x=%d! oops!\n", x + width - 1);
+				return;
+			}
+			
+			width = engine->width - x;
+		}
+		#else
+		if( (x + width) > ENGINE_WIDTH )
+		{
+			if(RENDERER && !lineHack)
+			{
+				printf("rasterizer rendering at x=%d! oops!\n", x + width - 1);
+				return;
+			}
+			
+			width = ENGINE_WIDTH - x;
+		}
+		#endif
 
 		while(width-- > 0)
 		{
@@ -852,6 +909,7 @@
 	}
 
 	//runs several scanlines, until an edge is finished
+	#ifndef X432R_SOFTRAST_OPTIMIZE_TEST
 	template<bool SLI>
 	void runscanlines(edge_fx_fl *left, edge_fx_fl *right, bool horizontal, bool lineHack)
 	{
@@ -862,7 +920,11 @@
 		bool first=true;
 
 		//HACK: special handling for horizontal line poly
+		#ifndef X432R_CUSTOMRENDERER_ENABLED
 		if (lineHack && left->Height == 0 && right->Height == 0 && left->Y<GFX3D_FRAMEBUFFER_HEIGHT && left->Y>=0)
+		#else
+		if( lineHack && (left->Height == 0) && (right->Height == 0) && (left->Y < engine->height) && (left->Y >= 0) )
+		#endif
 		{
 			bool draw = (!SLI || (left->Y & SLI_MASK) == SLI_VALUE);
 			if(draw) drawscanline(left,right,lineHack);
@@ -932,6 +994,79 @@
 			}
 		}
 	}
+	#else
+	template<bool SLI, u32 RENDER_MAGNIFICATION>
+	void runscanlines(edge_fx_fl *left, edge_fx_fl *right, bool horizontal, bool lineHack)
+	{
+		static const u32 ENGINE_WIDTH = 256 * RENDER_MAGNIFICATION;
+		static const u32 ENGINE_HEIGHT = 192 * RENDER_MAGNIFICATION;
+		
+		bool draw = !SLI || ( (left->Y & SLI_MASK) == SLI_VALUE );
+		
+		
+		//oh lord, hack city for edge drawing
+		
+		//do not overstep either of the edges
+		int height = min(left->Height, right->Height);
+		bool first = true;
+		
+		//HACK: special handling for horizontal line poly
+		if( lineHack && (left->Height == 0) && (right->Height == 0) && (left->Y < ENGINE_HEIGHT) && (left->Y >= 0) && draw )
+			drawscanline<RENDER_MAGNIFICATION>(left, right, lineHack);
+		
+		while(height--)
+		{
+			draw = !SLI || ( (left->Y & SLI_MASK) == SLI_VALUE );
+			
+			if(draw)
+				drawscanline<RENDER_MAGNIFICATION>(left, right, lineHack);
+			
+			left->Step();
+			right->Step();
+			
+/*			if( !RENDERER && _debug_thisPoly )
+			{
+				//debug drawing
+				const bool top = (horizontal && first);
+				const bool bottom = ( !height && horizontal );
+				
+				FragmentColor * const dest_line = engine->screenColor + (left->Y * ENGINE_WIDTH);
+				
+				if( (height || top || bottom) && draw )
+				{
+					const int xl = left->X;
+					const int xr = right->X;
+					
+					#define X432R_DRAW_SOFTRAST_DEBUG_COLOR(begin,end) \
+						for(int x = begin; x <= end; ++x) \
+						{ \
+							FragmentColor * const dest_fragment = dest_line + x; \
+							dest_fragment->r = 63; \
+							dest_fragment->g = 0; \
+							dest_fragment->b = 0; \
+						}
+					
+					if(top || bottom)
+					{
+						X432R_DRAW_SOFTRAST_DEBUG_COLOR( min(xl, xr), max(xl, xr) )
+					}
+					else
+					{
+						const int nxl = left->X;
+						const int nxr = right->X;
+						
+						X432R_DRAW_SOFTRAST_DEBUG_COLOR( min(xl, nxl), max(xl, nxl) )
+						X432R_DRAW_SOFTRAST_DEBUG_COLOR( min(xr, nxr), max(xr, nxr) )
+					}
+					
+					#undef X432R_DRAW_SOFTRAST_DEBUG_COLOR
+				}
+				
+				first = false;
+			}
+*/		}
+	}
+	#endif
 
 	
 	//rotates verts counterclockwise
@@ -1019,7 +1154,29 @@
 				return;
 
 			bool horizontal = left.Y == right.Y;
+			
+			#ifndef X432R_SOFTRAST_OPTIMIZE_TEST
 			runscanlines<SLI>(&left,&right,horizontal, lineHack);
+			#else
+			switch(engine->width)
+			{
+				case (256 * 4):
+					runscanlines<SLI, 4>(&left,&right,horizontal, lineHack);
+					break;
+				
+				case (256 * 3):
+					runscanlines<SLI, 3>(&left,&right,horizontal, lineHack);
+					break;
+				
+				case (256 * 2):
+					runscanlines<SLI, 2>(&left,&right,horizontal, lineHack);
+					break;
+				
+				default:
+					runscanlines<SLI, 1>(&left,&right,horizontal, lineHack);
+					break;
+			}
+			#endif
 
 			//if we ran out of an edge, step to the next one
 			if(right.Height == 0) {
@@ -1742,3 +1899,870 @@
 	SoftRastVramReconfigureSignal
 };
 
+
+#ifdef X432R_CUSTOMRENDERER_ENABLED
+#include "GPU.h"
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1700)
+#ifdef X432R_PPL_TEST
+#include <ppl.h>
+#endif
+#endif
+
+#ifdef X432R_CUSTOMSOFTRASTENGINE_ENABLED
+
+#ifndef X432R_SOFTRAST_OPTIMIZE_TEST
+template<bool CUSTOM>
+void SoftRasterizerEngine::ProcessClippedPolygons(const u32 width, const u32 height)
+{
+	const float xfactor = (float)width / 256.0f;
+	const float yfactor = (float)height / 192.0f;
+	const float xmax = (256.0f * xfactor) - (CUSTOM ? 0.001f : 0.0f);		//fudge factor to keep from overrunning render buffers
+	const float ymax = (192.0f * yfactor) - (CUSTOM ? 0.001f : 0.0f);
+#else
+template<u32 RENDER_MAGNIFICATION>
+void SoftRasterizerEngine::ProcessClippedPolygons()
+{
+	static const float xfactor = (float)RENDER_MAGNIFICATION;
+	static const float yfactor = (float)RENDER_MAGNIFICATION;
+	static const float xmax = (256.0f * xfactor) - ( (RENDER_MAGNIFICATION != 1) ? 0.001f : 0.0f );		//fudge factor to keep from overrunning render buffers
+	static const float ymax = (192.0f * yfactor) - ( (RENDER_MAGNIFICATION != 1) ? 0.001f : 0.0f );
+#endif
+	
+	TexCacheItem* last_texture_key = NULL;
+	u32 last_texture_format = 0, last_texture_palette = 0;
+	bool need_init_texture = true;
+	
+	u32 i, j;
+	
+	for(i = 0; i < clippedPolyCounter; ++i)			// ループを1つにまとめて高速化のつもり
+	{
+		GFX3D_Clipper::TClippedPoly& clipped_poly = clippedPolys[i];
+		POLY *poly = clipped_poly.poly;
+		int type = clipped_poly.type;
+		VERT* verts = &clipped_poly.clipVerts[0];
+		
+		
+		//--- performViewportTransforms ---
+		
+		//viewport transforms
+		for(j = 0; j < type; ++j)
+		{
+			VERT &vert = verts[j];
+			float coord0 = vert.coord[0];
+			float coord1 = vert.coord[1];
+			float coord2 = vert.coord[2];
+			float coord3 = vert.coord[3];
+			float coord3x2 = coord3 * 2.0f;
+			
+			//homogeneous divide
+			coord0 = ( (coord0 + coord3) / coord3x2 );
+			coord1 = ( (coord1 + coord3) / coord3x2 );
+			coord2 = ( (coord2 + coord3) / coord3x2 );
+			
+			vert.texcoord[0] = vert.texcoord[0] / coord3;
+			vert.texcoord[1] = vert.texcoord[1] / coord3;
+			
+			//CONSIDER: do we need to guarantee that these are in bounds? perhaps not.
+			//coord0 = max( 0.0, min(1.0, coord0) );
+			//coord1 = max( 0.0, min(1.0, coord1) );
+			//coord2 = max( 0.0, min(1.0, coord2) );
+			
+			//perspective-correct the colors
+			vert.fcolor[0] = vert.fcolor[0] / coord3;
+			vert.fcolor[1] = vert.fcolor[1] / coord3;
+			vert.fcolor[2] = vert.fcolor[2] / coord3;
+			
+			//viewport transformation
+			VIEWPORT viewport;
+			viewport.decode(poly->viewport);
+			
+			coord0 *= (float)viewport.width * xfactor;
+			coord0 += (float)viewport.x * xfactor;
+			
+			coord1 *= (float)viewport.height * yfactor;
+			coord1 += (float)viewport.y * yfactor;
+			
+			coord1 = ymax - coord1;
+			
+			//well, i guess we need to do this to keep Princess Debut from rendering huge polys.
+			//there must be something strange going on
+			coord0 = max( 0.0f, min(xmax, coord0) );
+			coord1 = max( 0.0f, min(ymax, coord1) );
+			
+			
+			//--- performCoordAdjustment ---
+			
+			//here is a hack which needs to be removed.
+			//at some point our shape engine needs these to be converted to "fixed point"
+			//which is currently just a float
+			vert.coord[0] = (float)( (int)(16.0f * coord0) );
+			vert.coord[1] = (float)( (int)(16.0f * coord1) );
+			vert.coord[2] = coord2;
+		}
+		
+		
+		//--- performBackfaceTests ---
+		{
+			PolyAttr poly_attr;
+			poly_attr.setup(poly->polyAttr);
+		
+			//HACK: backface culling
+			//this should be moved to gfx3d, but first we need to redo the way the lists are built
+			//because it is too convoluted right now.
+			//(must we throw out verts if a poly gets backface culled? if not, then it might be easier)
+		
+			//an older approach
+			//(not good enough for quads and other shapes)
+			//float ab[2], ac[2]; Vector2Copy(ab, verts[1].coord); Vector2Copy(ac, verts[2].coord); Vector2Subtract(ab, verts[0].coord); 
+			//Vector2Subtract(ac, verts[0].coord); float cross = Vector2Cross(ab, ac); polyAttr.backfacing = (cross>0); 
+		
+			//a better approach
+			// we have to support somewhat non-convex polygons (see NSMB world map 1st screen).
+			// this version should handle those cases better.
+			int n = type - 1;
+		
+			float facing = (verts[0].y + verts[n].y) * (verts[0].x - verts[n].x)
+							+ (verts[1].y + verts[0].y) * (verts[1].x - verts[0].x)
+							+ (verts[2].y + verts[1].y) * (verts[2].x - verts[1].x);
+		
+			for(j = 2; j < n; j++)
+				facing += (verts[j+1].y + verts[j].y) * (verts[j+1].x - verts[j].x);
+	
+			poly_attr.backfacing = (facing < 0);
+			polyBackfacing[i] = poly_attr.backfacing;
+			polyVisible[i] = poly_attr.isVisible(poly_attr.backfacing);
+		}
+		
+		
+		//--- setupTextures ---
+		{
+			//make sure all the textures we'll need are cached
+			//(otherwise on a multithreaded system there will be multiple writers-- 
+			//this SHOULD be read-only, although some day the texcache may collect statistics or something
+			//and then it won't be safe.
+			if( need_init_texture || (last_texture_format != poly->texParam) || (last_texture_palette != poly->texPalette) )
+			{
+				last_texture_key = TexCache_SetTexture(TexFormat_15bpp, poly->texParam, poly->texPalette);
+				last_texture_format = poly->texParam;
+				last_texture_palette = poly->texPalette;
+				need_init_texture = false;
+			}
+		
+			//printf("%08X %d\n",poly->texParam,rasterizerUnit[0].textures.currentNum);
+			polyTexKeys[i] = last_texture_key;
+		}
+	}
+}
+
+namespace X432R
+{
+	static FragmentColor softRast_TempClearImageColor[256 * 192];
+	static Fragment softRast_TempClearImageDepthStencil[256 * 192];
+}
+
+#ifndef X432R_SOFTRAST_OPTIMIZE_TEST
+template <u32 RENDER_MAGNIFICATION>
+void SoftRasterizerEngine::InitFramebuffer(const u32 width, const u32 height, const bool clear_image)
+{
+	const u32 fragment_count = width * height;
+#else
+template <u32 RENDER_MAGNIFICATION>
+void SoftRasterizerEngine::InitFramebuffer(const bool clear_image)
+{
+	static const u32 width = 256 * RENDER_MAGNIFICATION;
+	static const u32 height = 192 * RENDER_MAGNIFICATION;
+	static const u32 fragment_count = width * height;
+#endif
+	
+	Fragment clearFragment;
+	FragmentColor clearFragmentColor;
+	
+	clearFragment.isTranslucentPoly = 0;
+	clearFragmentColor.r = GFX3D_5TO6(gfx3d.renderState.clearColor & 0x1F);
+	clearFragmentColor.g = GFX3D_5TO6( (gfx3d.renderState.clearColor >> 5) & 0x1F );
+	clearFragmentColor.b = GFX3D_5TO6( (gfx3d.renderState.clearColor >> 10) & 0x1F );
+	clearFragmentColor.a = ( (gfx3d.renderState.clearColor >> 16) & 0x1F );
+	clearFragment.polyid.opaque = (gfx3d.renderState.clearColor >> 24) & 0x3F;
+	
+	//special value for uninitialized translucent polyid. without this, fires in spiderman2 dont display
+	//I am not sure whether it is right, though. previously this was cleared to 0, as a guess,
+	//but in spiderman2 some fires with polyid 0 try to render on top of the background
+	clearFragment.polyid.translucent = kUnsetTranslucentPolyID; 
+	clearFragment.depth = gfx3d.renderState.clearDepth;
+	clearFragment.stencil = 0;
+	clearFragment.isTranslucentPoly = 0;
+	clearFragment.fogged = BIT15(gfx3d.renderState.clearColor);
+	
+	#ifdef X432R_CUSTOMRENDERER_CLEARIMAGE_ENABLED
+	if(clear_image)
+	{
+		assert( (width <= 1024) && (height <= 768) && ( (width / 256) == RENDER_MAGNIFICATION ) && ( (height / 192) == RENDER_MAGNIFICATION ) );
+		
+		u16* clearImage = (u16*)MMU.texInfo.textureSlotAddr[2];
+		u16* clearDepth = (u16*)MMU.texInfo.textureSlotAddr[3];
+		
+		//the lion, the witch, and the wardrobe (thats book 1, suck it you new-school numberers)
+		//uses the scroll registers in the main game engine
+		u16 scroll = T1ReadWord(MMU.ARM9_REG,0x356); //CLRIMAGE_OFFSET
+		u16 xscroll = scroll&0xFF;
+		u16 yscroll = (scroll>>8)&0xFF;
+		
+		FragmentColor *dest_fragmentcolor = X432R::softRast_TempClearImageColor;
+		Fragment *dest_fragment = X432R::softRast_TempClearImageDepthStencil;
+		
+		for(int iy = 0; iy < GFX3D_FRAMEBUFFER_HEIGHT; ++iy)
+		{
+			int y = ( (iy + yscroll) & 255 ) << 8;
+			
+			for(int ix = 0; ix < GFX3D_FRAMEBUFFER_WIDTH; ++ix, ++dest_fragmentcolor, ++dest_fragment)
+			{
+				int x = (ix + xscroll) & 255;
+				int adr = y + x;
+				
+				//this is tested by harry potter and the order of the phoenix.
+				//TODO (optimization) dont do this if we are mapped to blank memory (such as in sonic chronicles)
+				//(or use a special zero fill in the bulk clearing above)
+				u16 col = clearImage[adr];
+				dest_fragmentcolor->color = RGB15TO6665( col, 31 * (col >> 15) );
+				
+				//this is tested quite well in the sonic chronicles main map mode
+				//where depth values are used for trees etc you can walk behind
+				u16 depth = clearDepth[adr];
+				dest_fragment->fogged = BIT15(depth);
+				dest_fragment->depth = DS_DEPTH15TO24(depth);
+			}
+		}
+		
+		const FragmentColor *source_fragmentcolor;
+		const Fragment *source_fragment;
+		u32 x, y, downscaled_index;
+		
+		dest_fragmentcolor = screenColor;
+		dest_fragment = screen;
+		
+		for(y = 0; y < height; ++y)
+		{
+			if( (y % RENDER_MAGNIFICATION) == 0 )
+				downscaled_index = y * 256;
+			
+			source_fragmentcolor = X432R::softRast_TempClearImageColor + downscaled_index;
+			source_fragment = X432R::softRast_TempClearImageDepthStencil + downscaled_index;
+			
+			for(x = 0; x < width; ++x, ++dest_fragmentcolor, ++dest_fragment)
+			{
+				*dest_fragmentcolor = *source_fragmentcolor;
+				*dest_fragment = *source_fragment;
+				
+				if( (y % RENDER_MAGNIFICATION) == (RENDER_MAGNIFICATION - 1) )
+				{
+					++source_fragmentcolor;
+					++source_fragment;
+				}
+			}
+		}
+	}
+	else
+	#endif
+	{
+		FragmentColor *dstColor = screenColor;
+		Fragment *dst = screen;
+		
+		for(u32 i = 0; i < fragment_count; ++i, ++dstColor, ++dst)
+		{
+			*dst = clearFragment;
+			*dstColor = clearFragmentColor;
+		}
+	}
+	
+	
+	#ifdef X432R_CUSTOMRENDERER_DEBUG
+	if(clear_image)
+		X432R::ShowDebugMessage("SoftRast ClearImage");
+	#endif
+}
+#endif
+
+namespace X432R
+{
+	template <u32 RENDER_MAGNIFICATION>
+	static char SoftRastInit()
+	{
+		X432R_STATIC_RENDER_MAGNIFICATION_CHECK();
+		
+		ClearBuffers();
+		
+		return ::SoftRastInit();
+	}
+	
+	template <u32 RENDER_MAGNIFICATION>
+	static void SoftRastRender()
+	{
+		X432R_STATIC_RENDER_MAGNIFICATION_CHECK();
+		
+		#ifdef X432R_PROCESSTIME_CHECK
+		AutoStopTimeCounter timecounter(timeCounter_3D);
+		#endif
+		
+		// Force threads to finish before rendering with new data
+		if(rasterizerCores > 1)
+		{
+			for(u32 i = 0; i < rasterizerCores; ++i)
+			{
+				rasterizerUnitTask[i].finish();
+			}
+		}
+		
+		mainSoftRasterizer.polylist = gfx3d.polylist;
+		mainSoftRasterizer.vertlist = gfx3d.vertlist;
+		mainSoftRasterizer.indexlist = &gfx3d.indexlist;
+		mainSoftRasterizer.screen = _screen;
+		mainSoftRasterizer.screenColor = _screenColor;
+		
+		mainSoftRasterizer.width = 256 * RENDER_MAGNIFICATION;
+		mainSoftRasterizer.height = 192 * RENDER_MAGNIFICATION;
+		
+		//setup fog variables (but only if fog is enabled)
+		if(gfx3d.renderState.enableFog)
+			mainSoftRasterizer.updateFogTable();
+		
+		#ifndef X432R_CUSTOMSOFTRASTENGINE_ENABLED
+		mainSoftRasterizer.initFramebuffer(mainSoftRasterizer.width, mainSoftRasterizer.height, gfx3d.renderState.enableClearImage ? true : false);
+		#elif !defined(X432R_SOFTRAST_OPTIMIZE_TEST)
+		mainSoftRasterizer.InitFramebuffer<RENDER_MAGNIFICATION>(mainSoftRasterizer.width, mainSoftRasterizer.height, gfx3d.renderState.enableClearImage);
+		#else
+		mainSoftRasterizer.InitFramebuffer<RENDER_MAGNIFICATION>(gfx3d.renderState.enableClearImage);
+		#endif
+		
+		mainSoftRasterizer.updateToonTable();
+		mainSoftRasterizer.updateFloatColors();
+		mainSoftRasterizer.performClipping(CommonSettings.GFX3D_HighResolutionInterpolateColor);
+		
+		#ifndef X432R_CUSTOMSOFTRASTENGINE_ENABLED
+		mainSoftRasterizer.performViewportTransforms<true>(mainSoftRasterizer.width, mainSoftRasterizer.height);
+		mainSoftRasterizer.performBackfaceTests();
+		mainSoftRasterizer.performCoordAdjustment(true);
+		mainSoftRasterizer.setupTextures(true);
+		#elif !defined(X432R_SOFTRAST_OPTIMIZE_TEST)
+		mainSoftRasterizer.ProcessClippedPolygons<true>(mainSoftRasterizer.width, mainSoftRasterizer.height);
+		#else
+		mainSoftRasterizer.ProcessClippedPolygons<RENDER_MAGNIFICATION>();
+		#endif
+		
+		softRastHasNewData = true;
+		
+		if(rasterizerCores > 1)
+		{
+			for(u32 i = 0; i < rasterizerCores; ++i)
+			{
+				rasterizerUnitTask[i].execute( &execRasterizerUnit, (void *)i );
+			}
+		}
+		else
+			rasterizerUnit[0].mainLoop<false>(&mainSoftRasterizer);
+	}
+	
+	
+	static inline RGBA8888 FragmentColorToRGBA8888(const FragmentColor color)
+	{
+		RGBA8888 result;
+		
+		if(color.a == 0)
+			return result;		// RGBA8888は生成時に0で初期化されている
+		
+		// RGBA6665 → BGRA8888
+		result.R = color.r << 2;
+		result.G = color.g << 2;
+		result.B = color.b << 2;
+//		result.A = (color.a << 3) + 7;	// 0x1Fを3ビット左シフトしても不透明にならないため値をオフセット
+		result.A = color.a << 3;
+		
+		return result;
+	}
+	
+	static inline FragmentColor RGBA8888ToFragmentColor(const RGBA8888 color)
+	{
+		FragmentColor result;
+		
+		if(color.A == 0)
+		{
+			result.color = 0;
+			return result;
+		}
+		
+		result.r = color.R >> 2;
+		result.g = color.G >> 2;
+		result.b = color.B >> 2;
+		result.a = color.A >> 3;
+		
+		return result;
+	}
+	
+	
+	static u8 softRast_FogColorR = 0;
+	static u8 softRast_FogColorG = 0;
+	static u8 softRast_FogColorB = 0;
+	static u8 softRast_FogColorA = 0;
+	
+	static inline void SoftRast_UpdateFogParams()
+	{
+		softRast_FogColorR = GFX3D_5TO6(gfx3d.renderState.fogColor & 0x1F);
+		softRast_FogColorG = GFX3D_5TO6( (gfx3d.renderState.fogColor >> 5) & 0x1F );
+		softRast_FogColorB = GFX3D_5TO6( (gfx3d.renderState.fogColor >> 10) & 0x1F );
+		softRast_FogColorA = (gfx3d.renderState.fogColor>>16) & 0x1F;
+	}
+	
+	template <u32 RENDER_MAGNIFICATION>
+	static inline void SoftRast_DrawFog(const Fragment * const dest_fragment, FragmentColor * const dest_color)
+	{
+		if( !dest_fragment->fogged ) return;
+		
+		const u8 fog = mainSoftRasterizer.fogTable[ clamp<u32>(dest_fragment->depth >> 9, 0, 32767) ];
+		
+		if(fog == 0) return;
+		
+		#if 0
+		if(fog == 127)
+		{
+			dest_color->a = (softRast_FogColorA * 128) >> 7;
+			
+			if( !gfx3d.renderState.enableFogAlphaOnly )
+			{
+				dest_color->r = (softRast_FogColorR * 128) >> 7;
+				dest_color->g = (softRast_FogColorG * 128) >> 7;
+				dest_color->b = (softRast_FogColorB * 128) >> 7;
+			}
+		}
+		else
+		{
+			const u8 fog2 = 128 - fog;
+			
+			dest_color->a = ( (fog2 * dest_color->a) + (softRast_FogColorA * fog) ) >> 7;
+			
+			if( !gfx3d.renderState.enableFogAlphaOnly )
+			{
+				dest_color->r = ( (fog2 * dest_color->r) + (softRast_FogColorR * fog) ) >> 7;
+				dest_color->g = ( (fog2 * dest_color->g) + (softRast_FogColorG * fog) ) >> 7;
+				dest_color->b = ( (fog2 * dest_color->b) + (softRast_FogColorB * fog) ) >> 7;
+			}
+		}
+		#else
+		// フォグの描画結果を標準SoftRasterizerと同じにするためにフォグのalphaを無視
+		if(fog == 127)
+		{
+			if(gfx3d.renderState.enableFogAlphaOnly)
+				dest_color->a = (softRast_FogColorA * 128) >> 7;
+			else
+			{
+				dest_color->r = (softRast_FogColorR * 128) >> 7;
+				dest_color->g = (softRast_FogColorG * 128) >> 7;
+				dest_color->b = (softRast_FogColorB * 128) >> 7;
+			}
+		}
+		else
+		{
+			const u8 fog2 = 128 - fog;
+			
+			if(gfx3d.renderState.enableFogAlphaOnly)
+				dest_color->a = ( (fog2 * dest_color->a) + (softRast_FogColorA * fog) ) >> 7;
+			else
+			{
+				dest_color->r = ( (fog2 * dest_color->r) + (softRast_FogColorR * fog) ) >> 7;
+				dest_color->g = ( (fog2 * dest_color->g) + (softRast_FogColorG * fog) ) >> 7;
+				dest_color->b = ( (fog2 * dest_color->b) + (softRast_FogColorB * fog) ) >> 7;
+			}
+		}
+		#endif
+	}
+	
+	
+	static FragmentColor softRast_EdgeMarkingColors[8];
+//	static int softRast_EdgeMarkingDisabled[8];
+	
+	static inline void SoftRast_UpdateEdgeMarkingParams()
+	{
+		const u16 alpha = gfx3d.state.enableAntialiasing ? 0x0F : 0x1F;
+		FragmentColor color;
+		
+		//TODO - need to test and find out whether these get grabbed at flush time, or at render time
+		//we can do this by rendering a 3d frame and then freezing the system, but only changing the edge mark colors
+		for(int i = 0; i < 8; ++i)
+		{
+			color.color = RGB15TO5555( T1ReadWord( MMU.MMU_MEM[ARMCPU_ARM9][0x40], 0x330 + (i * 2) ), alpha );
+			color.r = GFX3D_5TO6(color.r);
+			color.g = GFX3D_5TO6(color.g);
+			color.b = GFX3D_5TO6(color.b);
+			
+			softRast_EdgeMarkingColors[i] = color;
+			
+			//zero 20-jun-2013 - this doesnt make any sense. at least, it should be related to the 0x8000 bit. if this is undocumented behaviour, lets write about which scenario proves it here, or which scenario is requiring this code.
+			//// this seems to be the only thing that selectively disables edge marking
+			//edgeMarkDisabled[i] = (col == 0x7FFF);
+//			softRast_EdgeMarkingDisabled[i] = 0;
+		}
+	}
+	
+/*	template <u32 RENDER_MAGNIFICATION>
+	static inline void SoftRast_DrawEdgeMarking()
+	{
+		static const u32 RENDER_WIDTH = 256 * RENDER_MAGNIFICATION;
+		static const u32 RENDER_HEIGHT = 192 * RENDER_MAGNIFICATION;
+		
+		
+		int x, y, i;
+		Fragment dest_fragment;
+		u8 self_polygonid;
+		FragmentColor edge_color;
+		
+//		for(i = 0, y = 0; y < RENDER_HEIGHT; ++y)
+		for(y = 1; y < (RENDER_HEIGHT - 1); ++y)
+		{
+			i = (y * RENDER_WIDTH) + 1;
+			
+//			for(x = 0; x < RENDER_WIDTH; ++x, ++i)
+			for(x = 1; x < (RENDER_WIDTH - 1); ++x, ++i)
+			{
+				dest_fragment = _screen[i];
+				self_polygonid = dest_fragment.polyid.opaque;
+				
+//				if( dest_fragment.isTranslucentPoly || softRast_EdgeMarkingDisabled[self_polygonid >> 3] ) continue;
+				if(dest_fragment.isTranslucentPoly) continue;
+				
+				// > is used instead of != to prevent double edges
+				// between overlapping polys of different IDs.
+				// also note that the edge generally goes on the outside, not the inside, (maybe needs to change later)
+				// and that polys with the same edge color can make edges against each other.
+				
+				edge_color = softRast_EdgeMarkingColors[self_polygonid >> 3];
+				
+				#define PIXOFFSET(dx,dy)	( (dy * RENDER_WIDTH) + dx )
+//				#define ISEDGE(dx,dy)		( (x + dx) != RENDER_WIDTH ) && ( (x + dx) != -1 ) && ( (y + dy) != RENDER_HEIGHT ) && ( (y + dy) != -1 ) && (self_polygonid > _screen[i + PIXOFFSET(dx, dy)].polyid.opaque) )
+				#define ISEDGE(dx,dy)		(self_polygonid > _screen[i + PIXOFFSET(dx, dy)].polyid.opaque)
+				#define DRAWEDGE(dx,dy)		alphaBlend( _screenColor[i + PIXOFFSET(dx, dy)], edge_color )
+				
+				const bool upleft		= ISEDGE(-1, -1);
+				const bool up			= ISEDGE( 0, -1);
+				const bool upright		= ISEDGE( 1, -1);
+				const bool left			= ISEDGE(-1,  0);
+				const bool right		= ISEDGE( 1,  0);
+				const bool downleft		= ISEDGE(-1,  1);
+				const bool down			= ISEDGE( 0,  1);
+				const bool downright	= ISEDGE( 1,  1);
+				
+				if(upleft && upright && downleft && !downright)
+					DRAWEDGE(-1,-1);
+				
+				if(up && !down)
+					DRAWEDGE(0,-1);
+				
+				if(upleft && upright && !downleft && downright)
+					DRAWEDGE(1,-1);
+				
+				if(left && !right)
+					DRAWEDGE(-1,0);
+				
+				if(right && !left)
+					DRAWEDGE(1,0);
+				
+				if(upleft && !upright && downleft && downright)
+					DRAWEDGE(-1,1);
+				
+				if(down && !up)
+					DRAWEDGE(0,1);
+				
+				if(!upleft && upright && downleft && downright)
+					DRAWEDGE(1,1);
+				
+				#undef PIXOFFSET
+				#undef ISEDGE
+				#undef DRAWEDGE
+			}
+		}
+	}
+*/	
+	template <u32 RENDER_MAGNIFICATION>
+	static inline void SoftRast_DrawEdgeMarking(const u32 x, const u32 y, const Fragment * const dest_fragment, FragmentColor * const dest_color)
+	{
+		static const u32 RENDER_WIDTH = 256 * RENDER_MAGNIFICATION;
+		static const u32 RENDER_HEIGHT = 192 * RENDER_MAGNIFICATION;
+		
+//		if( (x <= 0) || ( x >= (RENDER_WIDTH - 1) ) || (y <= 0) || ( y >= (RENDER_HEIGHT - 1) ) ) return;
+		if( (x <= 1) || ( x >= (RENDER_WIDTH - 2) ) || (y <= 1) || ( y >= (RENDER_HEIGHT - 2) ) ) return;
+		
+		
+		const u8 self_polygonid = dest_fragment->polyid.opaque;
+		
+		const Fragment *target_fragment;
+		u8 target_id;
+		
+		#define PIXOFFSET(dx,dy)	( dest_fragment + ( (s32)dy * (s32)RENDER_WIDTH ) + (s32)dx )
+//		#define ISEDGE()			( !target_fragment->isTranslucentPoly && (target_id > self_polygonid) && !softRast_EdgeMarkingDisabled[target_id >> 3] )
+		#define ISEDGE()			( !target_fragment->isTranslucentPoly && (target_id > self_polygonid) )
+		
+		
+/*		#define DRAWEDGE(dx,dy) \
+			target_fragment = PIXOFFSET(dx, dy); \
+			target_id = target_fragment->polyid.opaque; \
+			if( ISEDGE() ) \
+			{ \
+				alphaBlend( *dest_color, softRast_EdgeMarkingColors[target_id >> 3] ); \
+				return; \
+			}
+		
+//		DRAWEDGE(-1, -1)
+		DRAWEDGE( 0, -1)
+//		DRAWEDGE( 1, -1)
+		DRAWEDGE(-1,  0)
+		DRAWEDGE( 1,  0)
+//		DRAWEDGE(-1,  1)
+		DRAWEDGE( 0,  1)
+//		DRAWEDGE( 1,  1)
+		
+		#undef DRAWEDGE
+*/		
+		
+		#define DRAWEDGE_2(dx,dy,dx2,dy2) \
+			target_fragment = PIXOFFSET(dx, dy); \
+			target_id = target_fragment->polyid.opaque; \
+			if( ISEDGE() && ( target_id <= PIXOFFSET(dx2, dy2)->polyid.opaque ) ) \
+			{ \
+				alphaBlend( *dest_color, softRast_EdgeMarkingColors[target_id >> 3] ); \
+				return; \
+			}
+		
+		#define DRAWEDGE_4(dx,dy,dx2,dy2,dx3,dy3,dx4,dy4) \
+			target_fragment = PIXOFFSET(dx, dy); \
+			target_id = target_fragment->polyid.opaque; \
+			if( ISEDGE() && ( target_id > PIXOFFSET(dx2, dy2)->polyid.opaque ) && ( target_id > PIXOFFSET(dx3, dy3)->polyid.opaque ) && ( target_id <= PIXOFFSET(dx4, dy4)->polyid.opaque ) ) \
+			{ \
+				alphaBlend( *dest_color, softRast_EdgeMarkingColors[target_id >> 3] ); \
+				return; \
+			}
+		
+		DRAWEDGE_2(		 0, -1,		 0, -2		)
+		DRAWEDGE_2(		 0,  1,		 0,  2		)
+		DRAWEDGE_2(		-1,  0,		-2,  0		)
+		DRAWEDGE_2(		 1,  0,		 2,  0		)
+		
+		DRAWEDGE_4(		 1,  1,		 2,  0,		 0,  2,		 2,  2		)
+		DRAWEDGE_4(		-1,  1,		-2,  0,		 0,  2,		-2,  2		)
+		DRAWEDGE_4(		 1, -1,		 0, -2,		 2,  0,		 2, -2		)
+		DRAWEDGE_4(		-1, -1,		 0, -2,		-2,  0,		-2, -2		)
+		
+		#undef DRAWEDGE_2
+		#undef DRAWEDGE_4
+		
+		
+		#undef PIXOFFSET
+		#undef ISEDGE
+	}
+	
+	
+	#if !defined(_MSC_VER) || (_MSC_VER < 1700) || !defined(X432R_PPL_TEST)
+	template <u32 RENDER_MAGNIFICATION, bool FOG_ENABLED, bool EDGEMARKING_ENABLED>
+	static void SoftRast_DownscaleFramebuffer()
+	{
+		u32 * const highresobuffer_begin = backBuffer.GetHighResolution3DBuffer();
+		u32 *highreso_buffer = highresobuffer_begin;
+		FragmentColor *color_buffer = _screenColor;
+		const Fragment *fragment_buffer = _screen;
+		u32 * const gfx3d_buffer = (u32 *)gfx3d_convertedScreen;
+		
+		u32 x, y, remainder_x, remainder_y, downscaled_index;
+		RGBA8888 color_rgba8888, color_tiletopleft, color_tiletopright, color_tilebottomleft;
+		u32 tiletop_index, tilebottom_index, tileleft_x;
+		
+		for( y = 0; y < (192 * RENDER_MAGNIFICATION); ++y )
+		{
+			remainder_y = (y % RENDER_MAGNIFICATION);
+			downscaled_index = (y / RENDER_MAGNIFICATION) * 256;
+			
+			for( x = 0; x < (256 * RENDER_MAGNIFICATION); ++x, ++color_buffer, ++fragment_buffer, ++highreso_buffer )
+			{
+				remainder_x = (x % RENDER_MAGNIFICATION);
+				
+				if(EDGEMARKING_ENABLED)
+					SoftRast_DrawEdgeMarking<RENDER_MAGNIFICATION>(x, y, fragment_buffer, color_buffer);
+				
+				if(FOG_ENABLED)
+					SoftRast_DrawFog<RENDER_MAGNIFICATION>(fragment_buffer, color_buffer);
+				
+				color_rgba8888 = FragmentColorToRGBA8888(*color_buffer);
+				*highreso_buffer = color_rgba8888.Color;
+				
+				// Bilinear
+				if( ( remainder_y != (RENDER_MAGNIFICATION - 1) ) || ( remainder_x != (RENDER_MAGNIFICATION - 1) ) ) continue;
+				
+				tiletop_index = ( y - (RENDER_MAGNIFICATION - 1) ) * (256 * RENDER_MAGNIFICATION);
+				tilebottom_index = y * (256 * RENDER_MAGNIFICATION);
+				tileleft_x = x - (RENDER_MAGNIFICATION - 1);
+				
+				color_tiletopleft = highresobuffer_begin[tiletop_index + tileleft_x];
+				color_tiletopright = highresobuffer_begin[tiletop_index + x];
+				color_tilebottomleft = highresobuffer_begin[tilebottom_index + tileleft_x];
+				
+				color_rgba8888.R = (u8)( ( (u32)color_tiletopleft.R + (u32)color_tiletopright.R + (u32)color_tilebottomleft.R + (u32)color_rgba8888.R ) >> 2 );
+				color_rgba8888.G = (u8)( ( (u32)color_tiletopleft.G + (u32)color_tiletopright.G + (u32)color_tilebottomleft.G + (u32)color_rgba8888.G ) >> 2 );
+				color_rgba8888.B = (u8)( ( (u32)color_tiletopleft.B + (u32)color_tiletopright.B + (u32)color_tilebottomleft.B + (u32)color_rgba8888.B ) >> 2 );
+				color_rgba8888.A = (u8)( ( (u32)color_tiletopleft.A + (u32)color_tiletopright.A + (u32)color_tilebottomleft.A + (u32)color_rgba8888.A ) >> 2 );
+				
+				gfx3d_buffer[ downscaled_index + (x / RENDER_MAGNIFICATION) ] = RGBA8888ToFragmentColor(color_rgba8888).color;
+			}
+		}
+	}
+	#else
+	template <u32 RENDER_MAGNIFICATION, bool FOG_ENABLED, bool EDGEMARKING_ENABLED>
+	static void SoftRast_DownscaleFramebuffer()
+	{
+		u32 * const highresobuffer_begin = backBuffer.GetHighResolution3DBuffer();
+		FragmentColor * const colorbuffer_begin = _screenColor;
+		const Fragment * const fragmentbuffer_begin = _screen;
+		u32 * const gfx3d_buffer = (u32 *)gfx3d_convertedScreen;
+		
+		concurrency::parallel_for( (u32)0, RENDER_MAGNIFICATION, [&](const u32 offset)
+		{
+			const u32 y_begin = 192 * offset;
+			const u32 y_end = y_begin + 192;
+			
+			const u32 highreso_index = y_begin * 256 * RENDER_MAGNIFICATION;
+			
+			u32 *highreso_buffer = highresobuffer_begin + highreso_index;
+			FragmentColor *color_buffer = colorbuffer_begin + highreso_index;
+			const Fragment *fragment_buffer = fragmentbuffer_begin + highreso_index;
+			
+			u32 x, y, remainder_x, remainder_y, downscaled_index;
+			RGBA8888 color_rgba8888, color_tiletopleft, color_tiletopright, color_tilebottomleft;
+			u32 tiletop_index, tilebottom_index, tileleft_x;
+			
+			for(y = y_begin; y < y_end; ++y)
+			{
+				remainder_y = (y % RENDER_MAGNIFICATION);
+				downscaled_index = (y / RENDER_MAGNIFICATION) * 256;
+				
+				for( x = 0; x < (256 * RENDER_MAGNIFICATION); ++x, ++color_buffer, ++fragment_buffer, ++highreso_buffer )
+				{
+					remainder_x = (x % RENDER_MAGNIFICATION);
+					
+					if(EDGEMARKING_ENABLED)
+						SoftRast_DrawEdgeMarking<RENDER_MAGNIFICATION>(x, y, fragment_buffer, color_buffer);
+					
+					if(FOG_ENABLED)
+						SoftRast_DrawFog<RENDER_MAGNIFICATION>(fragment_buffer, color_buffer);
+					
+					color_rgba8888 = FragmentColorToRGBA8888(*color_buffer);
+					*highreso_buffer = color_rgba8888.Color;
+					
+					// Bilinear
+					if( ( remainder_y != (RENDER_MAGNIFICATION - 1) ) || ( remainder_x != (RENDER_MAGNIFICATION - 1) ) ) continue;
+					
+					tiletop_index = ( y - (RENDER_MAGNIFICATION - 1) ) * (256 * RENDER_MAGNIFICATION);
+					tilebottom_index = y * (256 * RENDER_MAGNIFICATION);
+					tileleft_x = x - (RENDER_MAGNIFICATION - 1);
+					
+					color_tiletopleft = highresobuffer_begin[tiletop_index + tileleft_x];
+					color_tiletopright = highresobuffer_begin[tiletop_index + x];
+					color_tilebottomleft = highresobuffer_begin[tilebottom_index + tileleft_x];
+					
+					color_rgba8888.R = (u8)( ( (u32)color_tiletopleft.R + (u32)color_tiletopright.R + (u32)color_tilebottomleft.R + (u32)color_rgba8888.R ) >> 2 );
+					color_rgba8888.G = (u8)( ( (u32)color_tiletopleft.G + (u32)color_tiletopright.G + (u32)color_tilebottomleft.G + (u32)color_rgba8888.G ) >> 2 );
+					color_rgba8888.B = (u8)( ( (u32)color_tiletopleft.B + (u32)color_tiletopright.B + (u32)color_tilebottomleft.B + (u32)color_rgba8888.B ) >> 2 );
+					color_rgba8888.A = (u8)( ( (u32)color_tiletopleft.A + (u32)color_tiletopright.A + (u32)color_tilebottomleft.A + (u32)color_rgba8888.A ) >> 2 );
+					
+					gfx3d_buffer[ downscaled_index + (x / RENDER_MAGNIFICATION) ] = RGBA8888ToFragmentColor(color_rgba8888).color;
+				}
+			}
+		});
+	}
+	#endif
+	
+	template <u32 RENDER_MAGNIFICATION>
+	static void SoftRastRenderFinish()
+	{
+		X432R_STATIC_RENDER_MAGNIFICATION_CHECK();
+		
+		if( !softRastHasNewData ) return;
+		
+		
+		#ifdef X432R_PROCESSTIME_CHECK
+		AutoStopTimeCounter timecounter(timeCounter_3DFinish1);
+		#endif
+		
+		if(rasterizerCores > 1)
+		{
+			for(u32 i = 0; i < rasterizerCores; ++i)
+			{
+				rasterizerUnitTask[i].finish();
+			}
+		}
+		
+		TexCache_EvictFrame();
+		
+		
+		const bool edgemarking_enabled = CommonSettings.GFX3D_EdgeMark && gfx3d.renderState.enableEdgeMarking;
+		
+		if(edgemarking_enabled)
+		{
+			SoftRast_UpdateEdgeMarkingParams();
+//			SoftRast_DrawEdgeMarking<RENDER_MAGNIFICATION>();
+		}
+		
+		#define X432R_CALL_DOWNSCALEFRAMEBUFFER(fog_enabled) \
+			edgemarking_enabled ? SoftRast_DownscaleFramebuffer<RENDER_MAGNIFICATION, fog_enabled, true>() : SoftRast_DownscaleFramebuffer<RENDER_MAGNIFICATION, fog_enabled, false>()
+		
+		const u8 * const fogdensity_pointer = MMU.MMU_MEM[ARMCPU_ARM9][0x40] + 0x360;
+		
+		if( !gfx3d.renderState.enableFog || ( ( fogdensity_pointer[0] == 0 ) && ( fogdensity_pointer[31] == 0 ) ) )
+			X432R_CALL_DOWNSCALEFRAMEBUFFER(false);
+		else
+		{
+			SoftRast_UpdateFogParams();
+			
+			X432R_CALL_DOWNSCALEFRAMEBUFFER(true);
+			
+			#ifdef X432R_CUSTOMRENDERER_DEBUG
+			if(gfx3d.renderState.enableFogAlphaOnly)
+				X432R::ShowDebugMessage("SoftRast FogAlphaOnly");
+			#endif
+		}
+		
+		#undef X432R_CALL_DOWNSCALEFRAMEBUFFER
+		
+		
+		softRastHasNewData = false;
+	}
+	
+	
+	GPU3DInterface gpu3DRasterize_X2 =
+	{
+		"SoftRasterizer X2 (512x384)",
+		X432R::SoftRastInit<2>,
+		SoftRastReset,
+		SoftRastClose,
+		X432R::SoftRastRender<2>,
+		X432R::SoftRastRenderFinish<2>,
+		SoftRastVramReconfigureSignal
+	};
+	
+	GPU3DInterface gpu3DRasterize_X3 =
+	{
+		"SoftRasterizer X3 (768x576)",
+		X432R::SoftRastInit<3>,
+		SoftRastReset,
+		SoftRastClose,
+		X432R::SoftRastRender<3>,
+		X432R::SoftRastRenderFinish<3>,
+		SoftRastVramReconfigureSignal
+	};
+	
+	GPU3DInterface gpu3DRasterize_X4 =
+	{
+		"SoftRasterizer X4 (1024x768)",
+		X432R::SoftRastInit<4>,
+		SoftRastReset,
+		SoftRastClose,
+		X432R::SoftRastRender<4>,
+		X432R::SoftRastRenderFinish<4>,
+		SoftRastVramReconfigureSignal
+	};
+}
+#endif
Index: rasterize.h
===================================================================
--- rasterize.h	(revision 5164)
+++ rasterize.h	(working copy)
@@ -21,6 +21,12 @@
 #include "render3D.h"
 #include "gfx3d.h"
 
+
+//---CUSTOM--->
+#include "X432R_BuildSwitch.h"
+//<---CUSTOM---
+
+
 extern GPU3DInterface gpu3DRasterize;
 
 union FragmentColor {
@@ -90,7 +96,34 @@
 	VERTLIST* vertlist;
 	INDEXLIST* indexlist;
 	int width, height;
+	
+	
+	#ifdef X432R_CUSTOMSOFTRASTENGINE_ENABLED
+	#ifndef X432R_SOFTRAST_OPTIMIZE_TEST
+	template <bool CUSTOM>
+	void ProcessClippedPolygons(const u32 width, const u32 height);
+	
+	template <u32 RENDER_MAGNIFICATION>
+	void InitFramebuffer(const u32 width, const u32 height, const bool clear_image);
+	#else
+	template <u32 RENDER_MAGNIFICATION>
+	void ProcessClippedPolygons();
+	
+	template <u32 RENDER_MAGNIFICATION>
+	void InitFramebuffer(const bool clear_image);
+	#endif
+	#endif
 };
 
 
+#ifdef X432R_CUSTOMRENDERER_ENABLED
+namespace X432R
+{
+	extern GPU3DInterface gpu3DRasterize_X2;
+	extern GPU3DInterface gpu3DRasterize_X3;
+	extern GPU3DInterface gpu3DRasterize_X4;
+}
 #endif
+
+
+#endif
Index: saves.cpp
===================================================================
--- saves.cpp	(revision 5164)
+++ saves.cpp	(working copy)
@@ -684,6 +684,11 @@
    {
 	   osd->setLineColor(255, 0, 0);
 	   osd->addLine("Error saving %i slot", num);
+		
+		#ifdef X432R_MENUITEMMOD_ENABLED
+		osd->setLineColor(255, 255, 255);
+		#endif
+		
 	   return;
    }
 
@@ -717,6 +722,10 @@
    {
 	   osd->setLineColor(255, 0, 0);
 	   osd->addLine("Error loading %i slot", num);
+		
+		#ifdef X432R_MENUITEMMOD_ENABLED
+		osd->setLineColor(255, 255, 255);
+		#endif
    }
 }
 
Index: windows/hotkey.cpp
===================================================================
--- windows/hotkey.cpp	(revision 5164)
+++ windows/hotkey.cpp	(working copy)
@@ -370,6 +370,10 @@
 	else
 		osd->setLineColor(255,255,255);
 	osd->addLine(msg);
+	
+	#ifdef X432R_MENUITEMMOD_ENABLED
+	osd->setLineColor(255, 255, 255);
+	#endif
 }
 
 void HK_PlayMovie(int, bool justPressed) 
@@ -461,9 +465,11 @@
 }
 
 void HK_Pause(int, bool justPressed) { if(justPressed) TogglePause(); }
+#ifndef X432R_MENUITEMMOD_ENABLED
 void HK_FastForwardToggle(int, bool justPressed) { FastForward ^=1; }
 void HK_FastForwardKeyDown(int, bool justPressed) { FastForward = 1; }
 void HK_FastForwardKeyUp(int) { FastForward = 0; }
+#endif
 void HK_IncreaseSpeed(int, bool justPressed) { IncreaseSpeed(); }
 void HK_DecreaseSpeed(int, bool justPressed) { DecreaseSpeed(); }
 void HK_FrameLimitToggle(int, bool justPressed) {
@@ -475,11 +481,53 @@
 void HK_FrameAdvanceKeyUp(int) { FrameAdvance(false); }
 
 void HK_ToggleRasterizer(int, bool justPressed) { 
+	#ifndef X432R_CUSTOMRENDERER_ENABLED
 	if(cur3DCore == GPU3D_OPENGL_OLD || cur3DCore == GPU3D_OPENGL_3_2)
 		cur3DCore = GPU3D_SWRAST;
 	else cur3DCore = GPU3D_OPENGL_3_2;
 
 	Change3DCoreWithFallbackAndSave(cur3DCore);
+	#else
+	switch(cur3DCore)
+	{
+		case GPU3D_NULL:
+			return;
+		
+		case GPU3D_SWRAST:
+			cur3DCore = GPU3D_OPENGL_3_2;
+			break;
+		
+		case GPU3D_SWRAST_X2:
+			cur3DCore = GPU3D_OPENGL_X2;
+			break;
+		
+		case GPU3D_SWRAST_X3:
+			cur3DCore = GPU3D_OPENGL_X3;
+			break;
+		
+		case GPU3D_SWRAST_X4:
+			cur3DCore = GPU3D_OPENGL_X4;
+			break;
+		
+		case GPU3D_OPENGL_X2:
+			cur3DCore = GPU3D_SWRAST_X2;
+			break;
+		
+		case GPU3D_OPENGL_X3:
+			cur3DCore = GPU3D_SWRAST_X3;
+			break;
+		
+		case GPU3D_OPENGL_X4:
+			cur3DCore = GPU3D_SWRAST_X4;
+			break;
+		
+		default:
+			cur3DCore = GPU3D_SWRAST;
+			break;
+	}
+	
+	Change3DCoreWithFallbackAndSave(cur3DCore);
+	#endif
 }
 
 void HK_IncreasePressure(int, bool justPressed) {
@@ -533,6 +581,10 @@
 		key.page = NUM_HOTKEY_PAGE;
 		key.param = 0;
 
+		#ifdef X432R_TOUCHINPUT_ENABLED
+		key.keyPressed = false;
+		#endif
+
 		//keys->key[i].timing = PROCESS_NOW;
 		i++;
 	};
@@ -594,14 +646,23 @@
 	keys->FrameAdvance.page = HOTKEY_PAGE_MAIN;
 	keys->FrameAdvance.key = 'N';
 
+	#ifndef X432R_MENUITEMMOD_ENABLED
 	keys->FastForward.handleKeyDown = HK_FastForwardKeyDown;
 	keys->FastForward.handleKeyUp = HK_FastForwardKeyUp;
+	#else
+	keys->FastForward.handleKeyDown = X432R::HK_FastForwardKeyDown;
+	keys->FastForward.handleKeyUp = X432R::HK_FastForwardKeyUp;
+	#endif
 	keys->FastForward.code = "FastForward";
 	keys->FastForward.name = STRW(ID_LABEL_HK5);
 	keys->FastForward.page = HOTKEY_PAGE_MAIN;
 	keys->FastForward.key = VK_TAB;
 
+	#ifndef X432R_MENUITEMMOD_ENABLED
 	keys->FastForwardToggle.handleKeyDown = HK_FastForwardToggle;
+	#else
+	keys->FastForwardToggle.handleKeyDown = X432R::HK_ToggleFastForwardKeyDown;
+	#endif
 	keys->FastForwardToggle.code = "FastForwardToggle";
 	keys->FastForwardToggle.name = STRW(ID_LABEL_HK6);
 	keys->FastForwardToggle.page = HOTKEY_PAGE_MAIN;
@@ -690,6 +751,35 @@
 	keys->QuickPrintScreen.key = VK_F12;
 	keys->QuickPrintScreen.modifiers = CUSTKEY_CTRL_MASK;
 
+	#ifdef X432R_MENUITEMMOD_ENABLED
+	keys->ToggleSoundEnabled.handleKeyDown = X432R::HK_ToggleSoundEnabledKeyDown;
+	keys->ToggleSoundEnabled.code = "X432R:ToggleSoundEnabled";
+	keys->ToggleSoundEnabled.name = L"Toggle Sound Enabled";
+	keys->ToggleSoundEnabled.page = HOTKEY_PAGE_TOOLS;
+	keys->ToggleSoundEnabled.key = NULL;
+	
+	keys->SlowMotion.handleKeyDown = X432R::HK_SlowMotionKeyDown;
+	keys->SlowMotion.handleKeyUp = X432R::HK_SlowMotionKeyUp;
+	keys->SlowMotion.code = "X432R:SlowMotion";
+	keys->SlowMotion.name = L"Slow-Motion";
+	keys->SlowMotion.page = HOTKEY_PAGE_TOOLS;
+	keys->SlowMotion.key = NULL;
+	
+	keys->ToggleSlowMotion.handleKeyDown = X432R::HK_ToggleSlowMotionKeyDown;
+	keys->ToggleSlowMotion.code = "X432R:ToggleSlowMotion";
+	keys->ToggleSlowMotion.name = L"Toggle Slow-Motion";
+	keys->ToggleSlowMotion.page = HOTKEY_PAGE_TOOLS;
+	keys->ToggleSlowMotion.key = NULL;
+	
+	#ifdef X432R_CUSTOMSCREENSCALING_ENABLED
+	keys->SwapSmallScreenSetting.handleKeyDown = X432R::HK_SwapSmallScreenSetting;
+	keys->SwapSmallScreenSetting.code = "X432R:SwapScreenSize";
+	keys->SwapSmallScreenSetting.name = L"Swap Screen Size";
+	keys->SwapSmallScreenSetting.page = HOTKEY_PAGE_TOOLS;
+	keys->SwapSmallScreenSetting.key = NULL;
+	#endif
+	#endif
+
 	keys->ToggleReadOnly.handleKeyDown = HK_ToggleReadOnly;
 	keys->ToggleReadOnly.code = "ToggleReadOnly";
 	keys->ToggleReadOnly.name = STRW(ID_LABEL_HK24);
Index: windows/hotkey.h
===================================================================
--- windows/hotkey.h	(revision 5164)
+++ windows/hotkey.h	(working copy)
@@ -24,6 +24,12 @@
 #include <string>
 #include "../types.h"
 
+
+//---CUSTOM--->
+#include "X432R_BuildSwitch.h"
+//<---CUSTOM---
+
+
 enum HotkeyPage {
 	HOTKEY_PAGE_MAIN=0,
 	HOTKEY_PAGE_TOOLS,
@@ -60,6 +66,10 @@
 	const char* code;
 	int param;
 	//HotkeyTiming timing;
+	
+	#ifdef X432R_TOUCHINPUT_ENABLED
+	bool keyPressed;
+	#endif
 };
 
 struct SCustomKeys
@@ -107,6 +117,17 @@
 	SCustomKey SearchCheats;
 	SCustomKey IncreaseVolume;
 	SCustomKey DecreaseVolume;
+	
+	#ifdef X432R_MENUITEMMOD_ENABLED
+	SCustomKey ToggleSoundEnabled;
+	SCustomKey SlowMotion;
+	SCustomKey ToggleSlowMotion;
+	
+	#ifdef X432R_CUSTOMSCREENSCALING_ENABLED
+	SCustomKey SwapSmallScreenSetting;
+	#endif
+	#endif
+	
 	SCustomKey LastItem; // dummy, must be last
 
 	//--methods--
Index: windows/main.cpp
===================================================================
--- windows/main.cpp	(revision 5164)
+++ windows/main.cpp	(working copy)
@@ -307,8 +307,10 @@
 const int kGapBorder = 5;
 const int kGapNDS = 64; // extremely tilted (but some games seem to use this value)
 const int kGapNDS2 = 90; // more normal viewing angle
+#ifndef X432R_CUSTOMSCREENSCALING_ENABLED
 const int kScale1point5x = 65535;
 const int kScale2point5x = 65534;
+#endif
 
 static BOOL OpenCore(const char* filename);
 BOOL Mic_DeInit_Physical();
@@ -320,7 +322,10 @@
 HMENU mainMenu = NULL; //Holds handle to the main DeSmuME menu
 CToolBar* MainWindowToolbar;
 
+#ifndef X432R_TOUCHINPUT_ENABLED
 DWORD hKeyInputTimer;
+#endif
+
 bool start_paused;
 
 extern LRESULT CALLBACK RamSearchProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
@@ -500,6 +505,16 @@
 	&gpu3Dgl_3_2,
 	&gpu3DRasterize,
 	&gpu3DglOld,
+	
+	#ifdef X432R_CUSTOMRENDERER_ENABLED
+	&X432R::gpu3Dgl_X2,
+	&X432R::gpu3Dgl_X3,
+	&X432R::gpu3Dgl_X4,
+	&X432R::gpu3DRasterize_X2,
+	&X432R::gpu3DRasterize_X3,
+	&X432R::gpu3DRasterize_X4,
+	#endif
+	
 	NULL
 };
 
@@ -511,7 +526,11 @@
 bool continuousframeAdvancing = false;
 bool staterewindingenabled = false;
 
+#ifndef X432R_CUSTOMSCREENSCALING_ENABLED
 unsigned short windowSize = 0;
+#else
+float windowSize = 1.0f;
+#endif
 
 /*const u32 gapColors[16] = {
 	Color::Gray,
@@ -549,6 +568,7 @@
 //	const char *cflash_disk_image_file;
 //};
 
+#ifndef X432R_TOUCHINPUT_ENABLED
 static int KeyInDelayMSec = 0;
 static int KeyInRepeatMSec = 8;
 
@@ -618,9 +638,11 @@
 	InputTimer<false>();
 	InputTimer<true>();
 }
+#endif
 
 void ScaleScreen(float factor, bool user)
 {
+	#ifndef X432R_CUSTOMSCREENSCALING_ENABLED
 	if(user) // have to exit maximized mode if the user told us to set a specific window size
 	{
 		bool maximized = IsZoomed(MainWindow->getHWnd())==TRUE;
@@ -687,14 +709,101 @@
 				if (video.layout == 2)
 					MainWindow->setClientSize((int)(video.rotatedwidthgap() * factor), (int)(video.rotatedheightgap() * factor / 2));
 	}
+	#else
+	void UpdateWndRects(HWND hwnd);
+	
+	const HWND window_handle = MainWindow->getHWnd();
+	
+	if( IsZoomed(window_handle) )
+	{
+		if( !user ) return;
+		
+		ShowWindow(window_handle, SW_NORMAL);
+	}
+	
+	if(factor != windowSize)
+	{
+		windowSize = factor;
+		
+		if(user)
+			X432R::WritePrivateProfileFloat("Video", "Window Size", windowSize);
+	}
+	
+	float width, height;
+	float upperscreen_scale, lowerscreen_scale;
+	
+	X432R::GetScreenScales(upperscreen_scale, lowerscreen_scale);
+	
+	switch(video.layout)
+	{
+		case 1:					// horizontal
+			width = (256.0f * upperscreen_scale) + (256.0f * lowerscreen_scale);
+			height = 192.0f;
+			break;
+		
+		case 2:					// one screen
+			width = 256.0f;
+			height = 192.0f;
+			break;
+		
+		default:				// vertical
+		{
+			width = 256.0f;
+			height = (192.0f * upperscreen_scale) + (192.0f * lowerscreen_scale) + video.screengap;
+			
+			if( (video.rotation == 90) || (video.rotation == 270) )
+				std::swap(width, height);
+			
+			break;
+		}
+	}
+	
+	MainWindow->setClientSize(width * windowSize, height * windowSize);
+	UpdateWndRects(window_handle);
+	#endif
 }
 
 void SetMinWindowSize()
 {
+	#ifndef X432R_CUSTOMSCREENSCALING_ENABLED
 	if(ForceRatio)
 		MainWindow->setMinSize(video.rotatedwidth(), video.rotatedheight());
 	else
 		MainWindow->setMinSize(video.rotatedwidthgap(), video.rotatedheightgap());
+	#else
+	float mainscreen_scale, subscreen_scale;
+	
+	X432R::GetScreenScales(mainscreen_scale, subscreen_scale);
+	
+	int width, height;
+	
+	switch(video.layout)
+	{
+		case 2:			// one LCD
+			width = 256;
+			height = 256;
+			break;
+		
+		case 1:			// horizontal
+			width = (256 * mainscreen_scale) + (256 * subscreen_scale);
+			height = 192;
+			break;
+		
+		default:		// vertical
+			width = 256 * max(mainscreen_scale, subscreen_scale);
+			height = (192 * mainscreen_scale) + (192 * subscreen_scale);
+			
+			if( !SeparationBorderDrag )
+				height += video.screengap;
+			
+			if( (video.rotation == 90) || (video.rotation == 270) )
+				std::swap(width, height);
+			
+			break;
+	}
+	
+	MainWindow->setMinSize(width, height);
+	#endif
 }
 
 static void GetNdsScreenRect(RECT* r)
@@ -820,7 +929,11 @@
 	{
 		if(whichScreen)
 		{
+			#ifndef X432R_CUSTOMSCREENSCALING_ENABLED
 			bool topOnTop = (video.swap == 0) || (video.swap == 2 && !MainScreen.offset) || (video.swap == 3 && MainScreen.offset);
+			#else
+			bool topOnTop = (video.swap == 0);
+			#endif
 			bool bottom = (whichScreen > 0);
 			if(topOnTop)
 				y += bottom ? -192 : 0;
@@ -832,7 +945,11 @@
 	{
 		if(whichScreen)
 		{
+			#ifndef X432R_CUSTOMSCREENSCALING_ENABLED
 			bool topOnTop = (video.swap == 0) || (video.swap == 2 && !MainScreen.offset) || (video.swap == 3 && MainScreen.offset);
+			#else
+			bool topOnTop = (video.swap == 0);
+			#endif
 			bool bottom = (whichScreen > 0);
 			if(topOnTop)
 				x += bottom ? -256 : 0;
@@ -873,11 +990,17 @@
 const u32 DWS_DISPMETHODS =  (DWS_DDRAW_SW|DWS_DDRAW_HW|DWS_OPENGL);
 const u32 DWS_FILTER = 128;
 
+#ifdef X432R_MENUITEMMOD_ENABLED
+const u32 DWS_NORESIZE = 256;
+#endif
+
 static u32 currWindowStyle = DWS_NORMAL;
+
 static void SetStyle(u32 dws)
 {
 	//pokefan's suggestion, there are a number of ways we could do this.
 	//i sort of like this because it is very visually indicative of being locked down
+	#ifndef X432R_MENUITEMMOD_ENABLED
 	DWORD ws = GetWindowLong(MainWindow->getHWnd(),GWL_STYLE);
 	ws &= ~(WS_CAPTION | WS_POPUP | WS_THICKFRAME | WS_DLGFRAME );
 	if(dws & DWS_LOCKDOWN)
@@ -892,6 +1015,38 @@
 		SetMenu(MainWindow->getHWnd(),NULL);
 	else 
 		SetMenu(MainWindow->getHWnd(),mainMenu);
+	#else
+	const HWND window_handle = MainWindow->getHWnd();
+	
+	DWORD ws = GetWindowLong(window_handle, GWL_STYLE) | WS_MINIMIZEBOX;
+	
+	ws &= ~(WS_CAPTION | WS_POPUP | WS_THICKFRAME | WS_DLGFRAME | WS_MAXIMIZEBOX);
+	
+	if( IsZoomed( MainWindow->getHWnd() ) && (dws & DWS_LOCKDOWN) ) return;
+	
+	if(dws & DWS_LOCKDOWN)
+		ws |= WS_POPUP | WS_DLGFRAME;
+	
+	else if( !(dws & DWS_FULLSCREEN) )
+	{
+		if(dws & DWS_NORESIZE)
+			ws |= WS_POPUP | WS_CAPTION | WS_MAXIMIZEBOX;
+		
+		else
+			ws |= WS_CAPTION | WS_THICKFRAME | WS_MAXIMIZEBOX;
+	}
+	
+	SetWindowLong(window_handle, GWL_STYLE, ws);
+	
+	#ifndef X432R_MENUITEMMOD_ENABLED
+	if(dws & DWS_FULLSCREEN) 
+	#else
+	if( (dws & DWS_FULLSCREEN) && !X432R::showMenubarInFullScreen ) 
+	#endif
+		SetMenu(window_handle, NULL);
+	else 
+		SetMenu(window_handle, mainMenu);
+	#endif
 
 	currWindowStyle = dws;
 	HWND insertAfter = HWND_NOTOPMOST;
@@ -904,9 +1059,19 @@
 
 static void ToggleFullscreen()
 {
+/*	#ifdef X432R_MENUITEMMOD_ENABLED
+	Lock lock(win_backbuffer_sync);
+	#endif
+*/	
 	u32 style = GetStyle();
 	style ^= DWS_FULLSCREEN;
 	SetStyle(style);
+	
+	#ifdef X432R_MENUITEMMOD_ENABLED
+	if( IsZoomed( MainWindow->getHWnd() ) )
+		ShowWindow( MainWindow->getHWnd(), SW_NORMAL );
+	#endif
+	
 	if(style&DWS_FULLSCREEN)
 		ShowWindow(MainWindow->getHWnd(),SW_MAXIMIZE);
 	else ShowWindow(MainWindow->getHWnd(),SW_NORMAL);
@@ -1076,6 +1241,7 @@
 	int bufferWidth, bufferHeight;
 };
 
+#ifndef X432R_CUSTOMSCREENSCALING_ENABLED
 //performs aspect ratio letterboxing correction and integer clamping
 DisplayLayoutInfo CalculateDisplayLayout(RECT rcClient, bool maintainAspect, bool maintainInteger, int targetWidth, int targetHeight)
 {
@@ -1145,8 +1311,10 @@
 
 	GetClientRect(hwnd, &rc);
 
+	#ifndef X432R_MENUITEMMOD_ENABLED
 	if(maximized)
 		rc = FullScreenRect;
+	#endif
 	
 	tbheight = MainWindowToolbar->GetHeight();
 	
@@ -1318,7 +1486,211 @@
 	GapRect.top += tbheight;
 	GapRect.bottom += tbheight;
 }
+#else
+void UpdateWndRects(HWND hwnd)
+{
+	const bool maximized = (bool)IsZoomed(hwnd);
+	const int toolbar_height = MainWindowToolbar->GetHeight();
+	
+	RECT client_rect;
+	
+	GetClientRect(hwnd, &client_rect);
+	
+	const u32 client_width = client_rect.right;
+	const u32 client_height = client_rect.bottom - toolbar_height;
+	
+	float window_scale = PadToInteger ? floor(windowSize) : windowSize;
+	float mainscreen_scale, subscreen_scale;
+	
+	if(video.layout != 2)
+		X432R::GetScreenScales(mainscreen_scale, subscreen_scale);		// range: 0.5 to 1.0
+	else
+	{
+		mainscreen_scale = 1.0f;
+		subscreen_scale = 1.0f;
+	}
+	
+	float mainscreen_width = 256.0f * mainscreen_scale;
+	float mainscreen_height = 192.0f * mainscreen_scale;
+	float subscreen_width = 256.0f * subscreen_scale;
+	float subscreen_height = 192.0f * subscreen_scale;
+	float screen_gap = video.screengap;
+	
+	POINT point;
+	
+	// horizontal
+	if(video.layout == 1)
+	{
+		float target_width = mainscreen_width + subscreen_width;
+		float target_height = max(mainscreen_height, subscreen_height);
+		
+		if(maximized)
+			window_scale = X432R::CalculateDisplayScale(client_width, client_height, target_width, target_height);
+		
+		mainscreen_width = floor(mainscreen_width * window_scale);
+		mainscreen_height = floor(mainscreen_height * window_scale);
+		subscreen_width = floor(subscreen_width * window_scale);
+		subscreen_height = floor(subscreen_height * window_scale);
+		
+		target_width = mainscreen_width + subscreen_width;
+		target_height = max(mainscreen_height, subscreen_height);
+		
+		const u32 margin_width = (client_width - target_width) / 2;
+		const u32 margin_height = (client_height - target_height) / 2;
+		const u32 smallscreen_offset = abs( (s32)mainscreen_height - (s32)subscreen_height ) * X432R::GetSmallScreenOffset_Vertical();
+		
+		point.x = margin_width;
+		point.y = margin_height;
+		ClientToScreen(hwnd, &point);
+		
+		MainScreenRect.left = point.x;
+		MainScreenRect.top = point.y + ( (mainscreen_scale < subscreen_scale) ? smallscreen_offset : 0 );
+		MainScreenRect.right = MainScreenRect.left + mainscreen_width;
+		MainScreenRect.bottom = MainScreenRect.top + mainscreen_height;
+		
+		SubScreenRect.left = MainScreenRect.right;
+		SubScreenRect.top = point.y + ( (subscreen_scale < mainscreen_scale) ? smallscreen_offset : 0 );
+		SubScreenRect.right = SubScreenRect.left + subscreen_width;
+		SubScreenRect.bottom = SubScreenRect.top + subscreen_height;
+	}
+	
+	// one LCD
+	else if(video.layout == 2)
+	{
+		if(maximized)
+			window_scale = X432R::CalculateDisplayScale(client_width, client_height, mainscreen_width, mainscreen_height);
+		
+		mainscreen_width = floor(mainscreen_width * window_scale);
+		mainscreen_height = floor(mainscreen_height * window_scale);
+		
+		const u32 margin_width = (client_width - mainscreen_width) / 2;
+		const u32 margin_height = (client_height - mainscreen_height) / 2;
+		
+		point.x = margin_width;
+		point.y = margin_height;
+		ClientToScreen(hwnd, &point);
+		
+		MainScreenRect.left = point.x;
+		MainScreenRect.top = point.y;
+		MainScreenRect.right = MainScreenRect.left + mainscreen_width;
+		MainScreenRect.bottom = MainScreenRect.top + mainscreen_height;
+		
+		SubScreenRect.left = MainScreenRect.left;
+		SubScreenRect.top = MainScreenRect.top;
+		SubScreenRect.right = MainScreenRect.right;
+		SubScreenRect.bottom = MainScreenRect.bottom;
+	}
+	
+	// vertical
+	else if( (video.rotation == 90) || (video.rotation == 270) )
+	{
+		float target_width = mainscreen_height + subscreen_height + screen_gap;
+		float target_height = max(mainscreen_width, subscreen_width);
+		
+		if(maximized)
+			window_scale = X432R::CalculateDisplayScale(client_width, client_height, target_width, target_height);
+		
+		mainscreen_width = floor(mainscreen_width * window_scale);
+		mainscreen_height = floor(mainscreen_height * window_scale);
+		subscreen_width = floor(subscreen_width * window_scale);
+		subscreen_height = floor(subscreen_height * window_scale);
+		screen_gap = floor(screen_gap * window_scale);
+		
+		target_width = mainscreen_height + subscreen_height + screen_gap;
+		target_height = max(mainscreen_width, subscreen_width);
+		
+		const u32 margin_width = (client_width - target_width) / 2;
+		const u32 margin_height = (client_height - target_height) / 2;
+		const u32 smallscreen_offset = abs( (s32)mainscreen_width - (s32)subscreen_width ) * X432R::GetSmallScreenOffset_Vertical();
+		
+		point.x = margin_width;
+		point.y = margin_height;
+		ClientToScreen(hwnd, &point);
+		
+		if(video.rotation == 90)
+		{
+			MainScreenRect.left = point.x + subscreen_height + screen_gap;
+			SubScreenRect.left = point.x;
+		}
+		else
+		{
+			MainScreenRect.left = point.x;
+			SubScreenRect.left = point.x + mainscreen_height + screen_gap;
+		}
+		
+		MainScreenRect.top = point.y + ( (mainscreen_scale < subscreen_scale) ? smallscreen_offset : 0 );
+		MainScreenRect.right = MainScreenRect.left + mainscreen_height;
+		MainScreenRect.bottom = MainScreenRect.top + mainscreen_width;
+		
+		SubScreenRect.top = point.y + ( (subscreen_scale < mainscreen_scale) ? smallscreen_offset : 0 );
+		SubScreenRect.right = SubScreenRect.left + subscreen_height;
+		SubScreenRect.bottom = SubScreenRect.top + subscreen_width;
+		
+		GapRect.left = min(MainScreenRect.right, SubScreenRect.right);
+		GapRect.right = max(MainScreenRect.left, SubScreenRect.left);
+		GapRect.top = min(MainScreenRect.top, SubScreenRect.top);
+		GapRect.bottom = max(MainScreenRect.bottom, SubScreenRect.bottom);
+	}
+	else
+	{
+		float target_width = max(mainscreen_width, subscreen_width);
+		float target_height = mainscreen_height + subscreen_height + screen_gap;
+		
+		if(maximized)
+			window_scale = X432R::CalculateDisplayScale(client_width, client_height, target_width, target_height);
+		
+		mainscreen_width = floor(mainscreen_width * window_scale);
+		mainscreen_height = floor(mainscreen_height * window_scale);
+		subscreen_width = floor(subscreen_width * window_scale);
+		subscreen_height = floor(subscreen_height * window_scale);
+		screen_gap = floor(screen_gap * window_scale);
+		
+		target_width = max(mainscreen_width, subscreen_width);
+		target_height = mainscreen_height + subscreen_height + screen_gap;
+		
+		const u32 margin_width = (client_width - target_width) / 2;
+		const u32 margin_height = (client_height - target_height) / 2;
+		const u32 smallscreen_offset = abs( (s32)mainscreen_width - (s32)subscreen_width ) * X432R::GetSmallScreenOffset_Horizontal();
+		
+		point.x = margin_width;
+		point.y = margin_height;
+		ClientToScreen(hwnd, &point);
+		
+		if(video.rotation == 180)
+		{
+			MainScreenRect.top = point.y + subscreen_height + screen_gap;
+			SubScreenRect.top = point.y;
+		}
+		else
+		{
+			MainScreenRect.top = point.y;
+			SubScreenRect.top = point.y + mainscreen_height + screen_gap;
+		}
+		
+		MainScreenRect.left = point.x + ( (mainscreen_scale < subscreen_scale) ? smallscreen_offset : 0 );
+		MainScreenRect.right = MainScreenRect.left + mainscreen_width;
+		MainScreenRect.bottom = MainScreenRect.top + mainscreen_height;
+		
+		SubScreenRect.left = point.x + ( (subscreen_scale < mainscreen_scale) ? smallscreen_offset : 0 );
+		SubScreenRect.right = SubScreenRect.left + subscreen_width;
+		SubScreenRect.bottom = SubScreenRect.top + subscreen_height;
+		
+		GapRect.left = min(MainScreenRect.left, SubScreenRect.left);
+		GapRect.right = max(MainScreenRect.right, SubScreenRect.right);
+		GapRect.top = min(MainScreenRect.bottom, SubScreenRect.bottom);
+		GapRect.bottom = max(MainScreenRect.top, SubScreenRect.top);
+	}
+	
+	MainScreenRect.top += toolbar_height;
+	MainScreenRect.bottom += toolbar_height;
+	SubScreenRect.top += toolbar_height;
+	SubScreenRect.bottom += toolbar_height;
+	GapRect.top += toolbar_height;
+	GapRect.bottom += toolbar_height;
+}
+#endif
 
+
 void FixAspectRatio();
 
 void LCDsSwap(int swapVal)
@@ -1336,7 +1708,9 @@
 
 	bool maximized = IsZoomed(hwnd)==TRUE;
 
+//	#ifndef X432R_MENUITEMMOD_ENABLED
 	if(maximized) ShowWindow(hwnd,SW_NORMAL);
+//	#endif
 
 	if(video.layout != 0)
 	{
@@ -1357,6 +1731,7 @@
 	newwidth = oldwidth;
 	newheight = oldheight;
 
+	#ifndef X432R_CUSTOMSCREENSCALING_ENABLED
 	if (video.layout == 0)
 	{
 		DesEnableMenuItem(mainMenu, IDC_ROTATE90, true);
@@ -1459,6 +1834,95 @@
 		else
 			return;
 	}
+	#else
+	const u32 screen_width = max(MainScreenRect.right - MainScreenRect.left, SubScreenRect.right - SubScreenRect.left);
+	const u32 screen_height = max(MainScreenRect.bottom - MainScreenRect.top, SubScreenRect.bottom - SubScreenRect.top);
+	
+	float mainscreen_scale, subscreen_scale;
+	X432R::GetScreenScales(mainscreen_scale, subscreen_scale);
+	
+	const u32 mainscreen_width = screen_width * mainscreen_scale;
+	const u32 mainscreen_height = screen_height * mainscreen_scale;
+	const u32 subscreen_width = screen_width * subscreen_scale;
+	const u32 subscreen_height = screen_height * subscreen_scale;
+	
+	u32 scaled_screengap;
+	
+	if(video.layout == 0)
+	{
+		DesEnableMenuItem(mainMenu, IDC_ROTATE90, true);
+		DesEnableMenuItem(mainMenu, IDC_ROTATE180, true);
+		DesEnableMenuItem(mainMenu, IDC_ROTATE270, true);
+		DesEnableMenuItem(mainMenu, IDM_SCREENSEP_NONE, true);
+		DesEnableMenuItem(mainMenu, IDM_SCREENSEP_BORDER, true);
+		DesEnableMenuItem(mainMenu, IDM_SCREENSEP_NDSGAP, true);
+		DesEnableMenuItem(mainMenu, IDM_SCREENSEP_NDSGAP2, true);
+		DesEnableMenuItem(mainMenu, IDM_SCREENSEP_DRAGEDIT, true);
+//		DesEnableMenuItem(mainMenu, IDM_SCREENSEP_COLORWHITE, true);
+//		DesEnableMenuItem(mainMenu, IDM_SCREENSEP_COLORGRAY, true);
+//		DesEnableMenuItem(mainMenu, IDM_SCREENSEP_COLORBLACK, true);
+		
+		MainWindowToolbar->EnableButton(IDC_ROTATE90, true);
+		MainWindowToolbar->EnableButton(IDC_ROTATE270, true);
+		
+		if( (video.rotation == 90) || (video.rotation == 270) )
+		{
+			scaled_screengap = (u32)( (float)video.screengap * ( (float)max(mainscreen_height, subscreen_height) / 256.0f ) );
+			newwidth = mainscreen_width + subscreen_width + scaled_screengap;
+			newheight = max(mainscreen_height, subscreen_height);
+		}
+		else
+		{
+			scaled_screengap = (u32)( (float)video.screengap * ( (float)max(mainscreen_width, subscreen_width) / 256.0f ) );
+			newwidth = max(mainscreen_width, subscreen_width);
+			newheight = mainscreen_height + subscreen_height + scaled_screengap;
+		}
+		
+		MainWindow->checkMenu(ID_LCDS_VERTICAL, true);
+		MainWindow->checkMenu(ID_LCDS_HORIZONTAL, false);
+		MainWindow->checkMenu(ID_LCDS_ONE, false);
+	}
+	else
+	{
+		DesEnableMenuItem(mainMenu, IDC_ROTATE90, false);
+		DesEnableMenuItem(mainMenu, IDC_ROTATE180, false);
+		DesEnableMenuItem(mainMenu, IDC_ROTATE270, false);
+		DesEnableMenuItem(mainMenu, IDM_SCREENSEP_NONE, false);
+		DesEnableMenuItem(mainMenu, IDM_SCREENSEP_BORDER, false);
+		DesEnableMenuItem(mainMenu, IDM_SCREENSEP_NDSGAP, false);
+		DesEnableMenuItem(mainMenu, IDM_SCREENSEP_NDSGAP2, false);
+		DesEnableMenuItem(mainMenu, IDM_SCREENSEP_DRAGEDIT, false);
+//		DesEnableMenuItem(mainMenu, IDM_SCREENSEP_COLORWHITE, false);
+//		DesEnableMenuItem(mainMenu, IDM_SCREENSEP_COLORGRAY, false);
+//		DesEnableMenuItem(mainMenu, IDM_SCREENSEP_COLORBLACK, false);
+		
+		// As rotation was reset to 0, the button IDs were reset to 
+		// IDC_ROTATE90 and IDC_ROTATE270.
+		MainWindowToolbar->EnableButton(IDC_ROTATE90, false);
+		MainWindowToolbar->EnableButton(IDC_ROTATE270, false);
+		
+		scaled_screengap = (u32)( (float)video.screengap * ( (float)max(mainscreen_width, subscreen_width) / 256.0f ) );
+		
+		if(video.layout == 1)
+		{
+			newwidth = mainscreen_width + subscreen_width;
+			newheight = max(mainscreen_height, subscreen_height);
+			
+			MainWindow->checkMenu(ID_LCDS_HORIZONTAL, false);
+			MainWindow->checkMenu(ID_LCDS_VERTICAL, true);
+			MainWindow->checkMenu(ID_LCDS_ONE, false);
+		}
+		else if(video.layout == 2)
+		{
+			newwidth = mainscreen_width;
+			newheight = mainscreen_height;
+			
+			MainWindow->checkMenu(ID_LCDS_HORIZONTAL, false);
+			MainWindow->checkMenu(ID_LCDS_VERTICAL, false);
+			MainWindow->checkMenu(ID_LCDS_ONE, true);
+		}
+	}
+	#endif
 
 	video.layout_old = video.layout;
 	WritePrivateProfileInt("Video", "LCDsLayout", video.layout, IniName);
@@ -1470,7 +1934,13 @@
 		newheight = temp;
 	}
 
+//	#ifndef X432R_MENUITEMMOD_ENABLED
 	MainWindow->setClientSize(newwidth, newheight);
+/*	#else
+	if( !maximized )
+		MainWindow->setClientSize(newwidth, newheight);
+	#endif
+*/	
 	FixAspectRatio();
 	UpdateWndRects(hwnd);
 
@@ -1481,7 +1951,9 @@
 			SetRotate(hwnd, video.rotation_userset, false);
 	}
 
+//	#ifndef X432R_MENUITEMMOD_ENABLED
 	if(maximized) ShowWindow(hwnd,SW_MAXIMIZE);
+//	#endif
 }
 
 #pragma pack(push,1)
@@ -1509,11 +1981,18 @@
 	DDBLTFX fx;
 	memset(&fx,0,sizeof(DDBLTFX));
 	fx.dwSize = sizeof(DDBLTFX);
+	
+	#ifndef X432R_CUSTOMSCREENSCALING_ENABLED
 	//fx.dwFillColor = color;
 	fx.dwFillColor = 0; //color is just for debug
+	#else
+	fx.dwFillColor = color;
+	#endif
+	
 	surf->Blt(&r,NULL,NULL,DDBLT_COLORFILL | DDBLT_WAIT,&fx);
 }
 
+#ifndef X432R_D3D_DISPLAYMETHOD_ENABLED
 struct GLDISPLAY
 {
 	HGLRC privateContext;
@@ -1578,11 +2057,16 @@
 {
 	if(!gldisplay.begin()) return;
 
+	#ifndef X432R_CUSTOMRENDERER_ENABLED
 	static GLuint tex = 0;
 	if(tex == 0)
 		glGenTextures(1,&tex);
 
 	glBindTexture(GL_TEXTURE_2D,tex);
+	#else
+	glBindTexture( GL_TEXTURE_2D, X432R::GetScreenTexture() );
+	#endif
+
 	glTexImage2D(GL_TEXTURE_2D,0,GL_RGBA, video.width,video.height,0,GL_BGRA,GL_UNSIGNED_BYTE,video.finalBuffer());
 
 	//the ds screen fills the texture entirely, so we dont have garbage at edge to worry about,
@@ -1655,6 +2139,7 @@
 
 	RECT srcRects [2];
 
+	#ifndef X432R_CUSTOMSCREENSCALING_ENABLED
 	if(video.swap == 0)
 	{
 		srcRects[0] = MainScreenSrcRect;
@@ -1679,6 +2164,20 @@
 		srcRects[1] = (MainScreen.offset) ? SubScreenSrcRect : MainScreenSrcRect;
 		if(osd) osd->swapScreens = (SubScreen.offset != 0);
 	}
+	#else
+	if(video.swap == 1)
+	{
+		srcRects[0] = SubScreenSrcRect;
+		srcRects[1] = MainScreenSrcRect;
+		if(osd) osd->swapScreens = true;
+	}
+	else
+	{
+		srcRects[0] = MainScreenSrcRect;
+		srcRects[1] = SubScreenSrcRect;
+		if(osd) osd->swapScreens = false;
+	}
+	#endif
 
 	//printf("%d,%d %dx%d  -- %d,%d %dx%d\n",
 	//	srcRects[0].left,srcRects[0].top, srcRects[0].right-srcRects[0].left, srcRects[0].bottom-srcRects[0].top,
@@ -1738,6 +2237,7 @@
 
 	gldisplay.end();
 }
+#endif
 
 //the directdraw final presentation portion of display, including rotating
 static void DD_DoDisplay()
@@ -1772,6 +2272,7 @@
 	RECT* dstRects [2] = {&MainScreenRect, &SubScreenRect};
 	RECT* srcRects [2];
 
+	#ifndef X432R_CUSTOMSCREENSCALING_ENABLED
 	if(video.swap == 0)
 	{
 		srcRects[0] = &MainScreenSrcRect;
@@ -1850,6 +2351,75 @@
 		DeleteObject((HGDIOBJ)brush);
 		ReleaseDC(MainWindow->getHWnd(), dc);
 	}
+	#else
+	if(video.swap == 1)
+	{
+		srcRects[0] = &SubScreenSrcRect;
+		srcRects[1] = &MainScreenSrcRect;
+		if(osd) osd->swapScreens = true;
+	}
+	else
+	{
+		srcRects[0] = &MainScreenSrcRect;
+		srcRects[1] = &SubScreenSrcRect;
+		if(osd) osd->swapScreens = false;
+	}
+	
+	const u32 colordepth = ddraw.surfDescBack.ddpfPixelFormat.dwRGBBitCount;
+	const DWORD gapcolor = ( (colordepth == 32) || (colordepth == 24) ) ? ScreenGapColor : 0;
+	
+	RECT window_rect, screen_rect, client_rect;
+	
+	GetWindowRect( MainWindow->getHWnd(), &window_rect );
+	GetNdsScreenRect(&screen_rect);
+	
+	GetClientRect( MainWindow->getHWnd(), &client_rect );
+	
+	client_rect.bottom -= MainWindowToolbar->GetHeight();
+	
+	if( (screen_rect.right - screen_rect.left) < client_rect.right )
+	{
+		DD_FillRect(	ddraw.surface.primary,		0,						0,						screen_rect.left,		window_rect.bottom,		gapcolor		);		// left
+		DD_FillRect(	ddraw.surface.primary,		screen_rect.right,		0,						window_rect.right,		window_rect.bottom,		gapcolor		);		// right
+	}
+	
+	if( (screen_rect.bottom - screen_rect.top) < client_rect.bottom )
+	{
+		DD_FillRect(	ddraw.surface.primary,		screen_rect.left,		0,						screen_rect.right,		screen_rect.top,		gapcolor		);		// top
+		DD_FillRect(	ddraw.surface.primary,		screen_rect.left,		screen_rect.bottom,		screen_rect.right,		window_rect.bottom,		gapcolor		);		// bottom
+	}
+	
+	float mainscreen_scale, subscreen_scale;
+	
+	X432R::GetScreenScales(mainscreen_scale, subscreen_scale);
+	
+	if( (video.layout != 2) && ( (mainscreen_scale != subscreen_scale) ) )
+	{
+		const RECT &smallscreen_rect = (mainscreen_scale < subscreen_scale) ? MainScreenRect : SubScreenRect;
+			
+		if( (video.layout == 1) || (video.rotation == 90) || (video.rotation == 270) )
+		{
+			DD_FillRect(	ddraw.surface.primary,		smallscreen_rect.left,		screen_rect.top,				smallscreen_rect.right,		smallscreen_rect.top,		gapcolor		);
+			DD_FillRect(	ddraw.surface.primary,		smallscreen_rect.left,		smallscreen_rect.bottom,		smallscreen_rect.right,		screen_rect.bottom,			gapcolor		);
+		}
+		else
+		{
+			DD_FillRect(	ddraw.surface.primary,		screen_rect.left,			smallscreen_rect.top,		smallscreen_rect.left,		smallscreen_rect.bottom,		gapcolor		);
+			DD_FillRect(	ddraw.surface.primary,		smallscreen_rect.right,		smallscreen_rect.top,		screen_rect.right,			smallscreen_rect.bottom,		gapcolor		);
+		}
+	}
+	
+	if( (video.layout == 0) && (video.screengap > 0) )
+		DD_FillRect(	ddraw.surface.primary,		GapRect.left,		GapRect.top,		GapRect.right,		GapRect.bottom,		gapcolor		);		// gap
+	
+	if(video.layout == 2)
+		ddraw.blt( dstRects[0], srcRects[0] );
+	else
+	{
+		ddraw.blt( dstRects[0], srcRects[0] );
+		ddraw.blt( dstRects[1], srcRects[1] );
+	}
+	#endif
 }
 
 //triple buffering logic
@@ -1881,11 +2451,2999 @@
 	osd->clear();
 }
 
+
+#ifdef X432R_TOUCHINPUT_ENABLED
+namespace X432R
+{
+	static BOOL (__stdcall *RegisterTouchWindowProc)(HWND, ULONG) = NULL;
+	static BOOL (__stdcall *UnregisterTouchWindowProc)(HWND) = NULL;
+	static BOOL (__stdcall *GetTouchInputInfoProc)(HTOUCHINPUT, UINT, PTOUCHINPUT, int) = NULL;
+	static BOOL (__stdcall *CloseTouchInputHandleProc)(HTOUCHINPUT) = NULL;
+	
+	static bool touchInputDeviceInitialized = false;
+	static bool isTouchDowned = false;
+	static bool isTouchUpped = false;
+	
+	
+	static void CheckTouchInputDeviceConnected()
+	{
+		if( (MainWindow == NULL) || (RegisterTouchWindowProc == NULL) || (UnregisterTouchWindowProc == NULL) || (GetTouchInputInfoProc == NULL) || (CloseTouchInputHandleProc == NULL) ) return;
+		
+		const int device_status = GetSystemMetrics(SM_DIGITIZER);
+		const bool exists_touchdevice = (device_status & NID_INTEGRATED_TOUCH) || (device_status & NID_EXTERNAL_TOUCH);
+//		const bool exists_pendevice = (device_status & NID_INTEGRATED_PEN) || (device_status & NID_EXTERNAL_PEN);
+//		const bool multiinput_supported = device_status & NID_MULTI_INPUT;
+//		const bool device_ready = device_status & NID_READY;
+		
+//		const bool device_connected = device_ready && exists_touchdevice;
+		const bool device_connected = exists_touchdevice;
+		
+/*		if(device_connected == touchInputDeviceInitialized) return;
+		
+		if(device_connected)
+		{
+			RegisterTouchWindowProc( MainWindow->getHWnd(), 0 );
+			INFO("TouchInputDevice enabled.\n");
+		}
+		else
+		{
+			UnregisterTouchWindowProc( MainWindow->getHWnd() );
+			INFO("TouchInputDevice disabled.\n");
+			
+			if(isTouchDowned || isTouchUpped)
+			{
+				if( !StylusAutoHoldPressed )
+					NDS_releaseTouch();
+				
+				userTouchesScreen = false;
+			}
+		}
+		
+		touchInputDeviceInitialized = device_connected;
+		isTouchDowned = false;
+		isTouchDowned = false;
+*/		
+		if( !device_connected ) return;
+		
+		RegisterTouchWindowProc( MainWindow->getHWnd(), 0 );
+		INFO("TouchInputDevice enabled.\n");
+		
+		touchInputDeviceInitialized = true;
+	}
+	
+	static void InitTouchInput()
+	{
+		HMODULE user32dll = LoadLibrary( _T("user32.dll") );
+		
+		if(user32dll == NULL) return;
+		
+		RegisterTouchWindowProc = ( BOOL (__stdcall *)(HWND, ULONG) )GetProcAddress(user32dll, "RegisterTouchWindow");
+		UnregisterTouchWindowProc = ( BOOL (__stdcall *)(HWND) )GetProcAddress(user32dll, "UnregisterTouchWindow");
+		GetTouchInputInfoProc = ( BOOL (__stdcall *)(HTOUCHINPUT, UINT, PTOUCHINPUT, int) )GetProcAddress(user32dll, "GetTouchInputInfo");
+		CloseTouchInputHandleProc = ( BOOL (__stdcall *)(HTOUCHINPUT) )GetProcAddress(user32dll, "CloseTouchInputHandle");
+		
+		FreeLibrary(user32dll);
+		
+		
+		CheckTouchInputDeviceConnected();
+	}
+	
+	static inline void DeinitTouchInput()
+	{
+		if( (UnregisterTouchWindowProc == NULL) || (MainWindow == NULL) || !touchInputDeviceInitialized ) return;
+		
+		UnregisterTouchWindowProc( MainWindow->getHWnd() );
+	}
+	
+	static inline BOOL GetTouchInputInfo(HTOUCHINPUT hTouchInput, UINT cInputs, PTOUCHINPUT pInputs, int cbSize)
+	{
+		if(GetTouchInputInfoProc == NULL) return FALSE;
+		
+		return GetTouchInputInfoProc(hTouchInput, cInputs, pInputs, cbSize);
+	}
+	
+	static inline BOOL CloseTouchInputHandle(HTOUCHINPUT hTouchInput)
+	{
+		if(CloseTouchInputHandleProc == NULL) return FALSE;
+		
+		return CloseTouchInputHandleProc(hTouchInput);
+	}
+	
+	
+	#define MOUSEEVENTF_FROMTOUCH	0xFF515700
+	
+	static inline bool IsMouseEventFromTouch()
+	{
+//		if( !touchInputDeviceInitialized ) return false;
+		if( !touchInputDeviceInitialized || !isTouchDowned ) return false;
+		
+		#if 0
+		return ( ( GetMessageExtraInfo() & MOUSEEVENTF_FROMTOUCH ) != 0 );
+		#else
+		LPARAM info = GetMessageExtraInfo();
+		
+		return ( (info & MOUSEEVENTF_FROMTOUCH) && (info & 0x80) );			// true:touch, false:mouse or pen
+		#endif
+	}
+	
+	
+	static inline void SetTouchDownFlag()
+	{
+		if( !touchInputDeviceInitialized ) return;
+		
+		isTouchDowned = true;
+	}
+	
+	static inline void SetTouchUpFlag()
+	{
+		if( !touchInputDeviceInitialized ) return;
+		
+		isTouchUpped = true;
+	}
+	
+	// TouchUpを1フレーム遅延させることでタッチ無反応を防止 (TOUCHEVENTF_DOWNとTOUCHEVENTF_UPがほぼ同時に発生する場合があるため)
+	static void ExecDelayedTouchUp()
+	{
+		if( !isTouchUpped ) return;
+		
+		if( !StylusAutoHoldPressed )
+			NDS_releaseTouch();
+		
+		userTouchesScreen = false;
+		
+		isTouchDowned = false;
+		isTouchUpped = false;
+	}
+	
+	
+//	bool allowBackgroundHotkeys = false;				// バックグラウンド時のホットキー入力の有効／無効
+//	bool allowBackgroundKeyboardHotkeys = false;		// バックグラウンド時のキーボードからのホットキー入力の有効／無効
+	
+	void HandleHotkeys()
+	{
+		bool S9xGetState(WORD KeyIdent);
+		
+		const bool is_background = ( MainWindow->getHWnd() != GetForegroundWindow() );
+		
+		if( is_background && !allowBackgroundInput ) return;
+//		if( is_background && !allowBackgroundHotkeys ) return;
+		
+		WORD key, modifiers, pressed_modifiers;
+		bool key_pressed, last_pressed;
+		
+		const bool alt_pressed = !S9xGetState(VK_LMENU) || !S9xGetState(VK_RMENU);
+		const bool control_pressed = !S9xGetState(VK_LCONTROL) || !S9xGetState(VK_RCONTROL);
+		const bool shift_pressed = !S9xGetState(VK_LSHIFT) || !S9xGetState(VK_RSHIFT);
+		
+		for( SCustomKey* customkey = &CustomKeys.key(0); !IsLastCustomKey(customkey); ++customkey )
+		{
+			key = customkey->key;
+			
+			if(key == 0) continue;
+//			if( (key < 0x8000) && is_background && !allowBackgroundKeyboardHotkeys ) continue;
+			
+			modifiers = customkey->modifiers;
+			last_pressed = customkey->keyPressed;
+			
+			pressed_modifiers = 0;
+			
+			switch(key)
+			{
+				case VK_MENU:
+//					key_pressed = alt_pressed && !control_pressed && !shift_pressed;
+					key_pressed = alt_pressed;		// Alt, Control, Shiftは他のモディファイアキーと組み合わせたホットキー登録ができないためこれでOK
+					break;
+				
+				case VK_CONTROL:
+					key_pressed = control_pressed;
+					break;
+				
+				case VK_SHIFT:
+					key_pressed = shift_pressed;
+					break;
+				
+				default:
+					if(alt_pressed)
+						pressed_modifiers |= CUSTKEY_ALT_MASK;
+					
+					if(control_pressed)
+						pressed_modifiers |= CUSTKEY_CTRL_MASK;
+					
+					if(shift_pressed)
+						pressed_modifiers |= CUSTKEY_SHIFT_MASK;
+					
+					key_pressed = !S9xGetState(key) && (pressed_modifiers == modifiers);
+					break;
+			}
+			
+			if( key_pressed && !last_pressed )
+			{
+				customkey->keyPressed = true;
+				
+				if(customkey->handleKeyDown != NULL)
+				{
+					customkey->handleKeyDown(customkey->param, true);
+					break;		// 重複割り当てされたホットキーを無視する
+				}
+			}
+			else if( !key_pressed && last_pressed )
+			{
+				customkey->keyPressed = false;
+				
+				if(customkey->handleKeyUp != NULL)
+				{
+					customkey->handleKeyUp(customkey->param);
+					break;
+				}
+			}
+		}
+	}
+}
+#endif
+
+#ifdef X432R_MENUITEMMOD_ENABLED
+namespace X432R
+{
+	static bool showMenubarInFullScreen = false;
+	static bool soundOutputEnabled = true;
+	bool cpuPowerSavingEnabled = false;
+	
+	
+	// ボリュームを0にするだけ
+	static void ChangeSoundEnabled(bool enable)
+	{
+		SPU_SetVolume(enable ? sndvolume : 0);
+		
+		soundOutputEnabled = enable;
+	}
+	
+	void HK_ToggleSoundEnabledKeyDown(int, bool)
+	{
+		ChangeSoundEnabled( !soundOutputEnabled );
+		
+		WritePrivateProfileBool("X432R", "SoundEnabled", soundOutputEnabled, IniName);
+		
+		if(osd != NULL)
+			osd->addLine(soundOutputEnabled ? "Sound enabled" : "Sound disabled");
+	}
+	
+	
+	//--- FastForward / SlowMotion ---
+	void SetTargetFps(const float target_fps);
+	
+	static const u32 fastForwardPresetSetting[] =
+	{
+		0,		180,		150,		120,		90
+	};
+	
+	static const u32 slowMotionPresetSetting[] =
+	{
+		50,		40,		30,		20,		10
+	};
+	
+	static const u32 fastForwardLevel_Max = ( sizeof(fastForwardPresetSetting) / sizeof(u32) ) - 1;
+	static const u32 slowMotionLevel_Max = ( sizeof(slowMotionPresetSetting) / sizeof(u32) ) - 1;
+	
+	static u32 fastForwardLevel = 0;
+	static u32 slowMotionLevel = 0;
+	
+	static u32 currentTargetFps = 60;
+	static bool fastForwardEnabled = false;
+	static bool slowMotionEnabled = false;
+	
+	void SetFastForwardSpeedSetting(const u32 level)
+	{
+		fastForwardLevel = clamp<u32>(level, 0, fastForwardLevel_Max);
+		WritePrivateProfileInt("X432R", "FastForwardLevel", fastForwardLevel, IniName);
+		
+		if( (currentTargetFps == 0) || (currentTargetFps > 60) )
+		{
+			HK_FastForwardKeyDown(0, false);
+			
+			if(currentTargetFps == 0)
+				osd->addLine("Target FPS: Unlimited");
+			else
+				osd->addLine("Target FPS: %d", currentTargetFps);
+		}
+	}
+	
+	void SetSlowMotionSpeedSetting(const u32 level)
+	{
+		slowMotionLevel = clamp<u32>(level, 0, slowMotionLevel_Max);
+		WritePrivateProfileInt("X432R", "SlowMotionLevel", slowMotionLevel, IniName);
+		
+		if( (currentTargetFps > 0) && (currentTargetFps < 60) )
+		{
+			HK_SlowMotionKeyDown(0, false);
+			
+			osd->addLine("Target FPS: %d", currentTargetFps);
+		}
+	}
+	
+	void HK_FastForwardKeyDown(int, bool)
+	{
+		currentTargetFps = fastForwardPresetSetting[fastForwardLevel];
+		fastForwardEnabled = true;
+		
+		if(currentTargetFps == 0)
+		{
+			FastForward = 1;
+			SetTargetFps(60);
+		}
+		else
+		{
+			FastForward = 0;
+			SetTargetFps(currentTargetFps);
+		}
+	}
+	
+	void HK_FastForwardKeyUp(int)
+	{
+		fastForwardEnabled = false;
+		FastForward = 0;
+		
+		if(slowMotionEnabled)
+			HK_SlowMotionKeyDown(0, false);
+		else
+		{
+			currentTargetFps = 60;
+			SetTargetFps(60);
+		}
+	}
+	
+	void HK_ToggleFastForwardKeyDown(int, bool)
+	{
+		slowMotionEnabled = false;
+		
+//		if(fastForwardEnabled)
+		if( (currentTargetFps == 0) || (currentTargetFps > 60) )
+			HK_FastForwardKeyUp(0);
+		else
+			HK_FastForwardKeyDown(0, false);
+		
+		if(currentTargetFps == 0)
+			osd->addLine("Target FPS: Unlimited");
+		else
+			osd->addLine("Target FPS: %d", currentTargetFps);
+	}
+	
+	void HK_SlowMotionKeyDown(int, bool)
+	{
+		currentTargetFps = slowMotionPresetSetting[slowMotionLevel];
+		slowMotionEnabled = true;
+		FastForward = 0;
+		
+		SetTargetFps(currentTargetFps);
+	}
+	
+	void HK_SlowMotionKeyUp(int target_fps)
+	{
+		slowMotionEnabled = false;
+		
+		if(fastForwardEnabled)
+			HK_FastForwardKeyDown(0, false);
+		else
+		{
+			currentTargetFps = 60;
+			SetTargetFps(60);
+		}
+	}
+	
+	void HK_ToggleSlowMotionKeyDown(int, bool)
+	{
+		fastForwardEnabled = false;
+		FastForward = 0;
+		
+//		if(slowMotionEnabled)
+		if( (currentTargetFps > 0) && (currentTargetFps < 60) )
+			HK_SlowMotionKeyUp(0);
+		else
+			HK_SlowMotionKeyDown(0, false);
+		
+		osd->addLine("Target FPS: %d", currentTargetFps);
+	}
+	
+	
+	#ifdef X432R_CUSTOMSCREENSCALING_ENABLED
+	//--- Screen Size ---
+	static const float smallScreenSetting_Step = 0.1f;
+	static const s32 smallScreenSetting_Min = -5;
+	static const s32 smallScreenSetting_Max = 5;
+	
+	static s32 smallScreenSetting_Current = 0;
+	static s32 smallScreenSetting_Last = 3;
+	
+	
+	static void SetSmallScreenSetting(const s32 value)
+	{
+		if( HudEditorMode && (value != 0) ) return;
+		
+		smallScreenSetting_Current = clamp(value, smallScreenSetting_Min, smallScreenSetting_Max);
+		WritePrivateProfileInt("X432R", "SmallScreenSetting_Current", smallScreenSetting_Current, IniName);
+		
+		if(smallScreenSetting_Current != 0)
+		{
+			smallScreenSetting_Last = abs(smallScreenSetting_Current);
+			WritePrivateProfileInt("X432R", "SmallScreenSetting_Last", smallScreenSetting_Last, IniName);
+		}
+		
+		
+		const HWND window_handle = MainWindow->getHWnd();
+		
+		if( IsZoomed(window_handle) )
+			UpdateWndRects(window_handle);
+		else
+			ScaleScreen(windowSize, false);
+	}
+	
+	static void SetSmallScreenSettingIndex(const u32 index)
+	{
+		SetSmallScreenSetting(smallScreenSetting_Min + index);
+	}
+	
+	static void ResetSmallScreenSetting()
+	{
+		SetSmallScreenSetting(0);
+	}
+	
+	static void GetScreenScales(float &mainscreen_scale, float &subscreen_scale)
+	{
+		if(smallScreenSetting_Current < 0)
+		{
+			mainscreen_scale = 1.0f;
+			subscreen_scale = 1.0f + ( smallScreenSetting_Step * (float)smallScreenSetting_Current );
+		}
+		else if(smallScreenSetting_Current > 0)
+		{
+			mainscreen_scale = 1.0f - ( smallScreenSetting_Step * (float)smallScreenSetting_Current );
+			subscreen_scale = 1.0f;
+		}
+		else
+		{
+			mainscreen_scale = 1.0f;
+			subscreen_scale = 1.0f;
+		}
+	}
+	
+	void HK_SwapSmallScreenSetting(int, bool)
+	{
+		if(smallScreenSetting_Current < 0)
+			SetSmallScreenSetting(-smallScreenSetting_Current);
+		
+		else if(smallScreenSetting_Current > 0)
+			SetSmallScreenSetting(0);
+		
+		else
+			SetSmallScreenSetting(-smallScreenSetting_Last);
+	}
+	
+/*	#ifdef X432R_CUSTOMRENDERER_ENABLED
+	extern const bool *isHighResolutionScreen_Current;
+	
+	static bool smallScreen_AutoSwapEnabled = false;
+	
+	static void ExecSmallScreenAutoSwap()
+	{
+		const bool highreso_upper = isHighResolutionScreen_Current[0];
+		const bool highreso_lower = isHighResolutionScreen_Current[1];
+		
+		if( ( highreso_upper && !highreso_lower && (smallScreenSetting_Current > 0) ) || ( !highreso_upper && highreso_lower && (smallScreenSetting_Current < 0) ) )
+			SetSmallScreenSetting(-smallScreenSetting_Current);
+	}
+	#endif
+*/	
+	
+	static const u32 smallScreenOffset_Min = 0;
+	static const u32 smallScreenOffset_Center = 1;
+	static const u32 smallScreenOffset_Max = 2;
+	
+	static u32 smallScreenOffset_Horizontal = smallScreenOffset_Center;
+	static u32 smallScreenOffset_Vertical = smallScreenOffset_Center;
+	
+	static void SetSmallScreenOffset_Horizontal(const u32 offset)
+	{
+		smallScreenOffset_Horizontal = clamp(offset, smallScreenOffset_Min, smallScreenOffset_Max);
+		WritePrivateProfileInt("X432R", "SmallScreenOffset_Horizontal", smallScreenOffset_Horizontal, IniName);
+		
+		UpdateWndRects( MainWindow->getHWnd() );
+	}
+	
+	static void SetSmallScreenOffset_Vertical(const u32 offset)
+	{
+		smallScreenOffset_Vertical = clamp(offset, smallScreenOffset_Min, smallScreenOffset_Max);
+		WritePrivateProfileInt("X432R", "SmallScreenOffset_Vertical", smallScreenOffset_Vertical, IniName);
+		
+		UpdateWndRects( MainWindow->getHWnd() );
+	}
+	
+	static float GetSmallScreenOffset_Horizontal()
+	{
+		return ( (float)smallScreenOffset_Horizontal / (float)X432R::smallScreenOffset_Max );
+	}
+	
+	static float GetSmallScreenOffset_Vertical()
+	{
+		return ( (float)smallScreenOffset_Vertical / (float)X432R::smallScreenOffset_Max );
+	}
+	
+	
+	static void ToDSScreenRelativeCoords(s32 &x, s32 &y)
+	{
+		const HWND window_handle = MainWindow->getHWnd();
+		
+		RECT screen_rect = (video.swap == 1) ? MainScreenRect : SubScreenRect;
+		ScreenToClient( window_handle, (LPPOINT)&screen_rect.left );
+		ScreenToClient( window_handle, (LPPOINT)&screen_rect.right );
+		
+		const float width = screen_rect.right - screen_rect.left;
+		const float height = screen_rect.bottom - screen_rect.top;
+		
+		if(video.layout != 0) goto no_rotation;
+		
+		switch(video.rotation)
+		{
+			case 90:
+				x = (s32)( (float)(screen_rect.right - x) * (192.0f / width) );
+				y = (s32)( (float)(y - screen_rect.top) * (256.0f / height) );
+				std::swap(x, y);
+				break;
+			
+			case 180:
+				x = (s32)( ( (float)(screen_rect.right - x) * (256.0f / width) ) );
+				y = (s32)( ( (float)(screen_rect.bottom - y) * (192.0f / height) ) );
+				break;
+			
+			case 270:
+				x = (s32)( (float)(x - screen_rect.left) * (192.0f / width) );
+				y = (s32)( (float)(screen_rect.bottom - y) * (256.0f / height) );
+				std::swap(x, y);
+				break;
+				
+			default:
+				no_rotation:
+				
+				x = (s32)( (float)(x - screen_rect.left) * (256.0f / width) );
+				y = (s32)( (float)(y - screen_rect.top) * (192.0f / height) );
+				break;
+		}
+	}
+	
+	static float CalculateDisplayScale(const float client_width, const float client_height, const float target_width, const float target_height)
+	{
+		const float scale = min(client_width / target_width,  client_height / target_height);
+		
+		return ( PadToInteger ? floor(scale) : scale );
+	}
+	
+	static void UpdateScreenGap(const float client_height, const float window_scale)
+	{
+		float mainscreen_scale, subscreen_scale;
+		GetScreenScales(mainscreen_scale, subscreen_scale);
+		
+		const float scaled_gap = client_height - ( ( (192.0f * mainscreen_scale) + (192.0f * subscreen_scale) ) * window_scale );
+		
+		video.screengap = (u32)clamp(scaled_gap / window_scale, 0.0f, 192.0f);
+	}
+	
+	
+	static void InitSmallScreenSetting()
+	{
+		smallScreenSetting_Current = clamp( (s32)GetPrivateProfileInt("X432R", "SmallScreenSetting_Current", smallScreenSetting_Current, IniName), smallScreenSetting_Min, smallScreenSetting_Max );
+		
+		const s32 buffer = (s32)GetPrivateProfileInt("X432R", "SmallScreenSetting_Last", smallScreenSetting_Last, IniName);
+		
+		if(buffer > 0)
+			smallScreenSetting_Last = min(buffer, smallScreenSetting_Max);
+		
+/*		#ifdef X432R_CUSTOMRENDERER_ENABLED
+		smallScreen_AutoSwapEnabled = GetPrivateProfileBool("X432R", "SmallScreen_AutoSwapEnabled", smallScreen_AutoSwapEnabled, IniName);
+		#endif
+*/		
+		smallScreenOffset_Horizontal = clamp( GetPrivateProfileInt("X432R", "SmallScreenOffset_Horizontal", smallScreenOffset_Horizontal, IniName), smallScreenOffset_Min, smallScreenOffset_Max );
+		smallScreenOffset_Vertical = clamp( GetPrivateProfileInt("X432R", "SmallScreenOffset_Vertical", smallScreenOffset_Vertical, IniName), smallScreenOffset_Min, smallScreenOffset_Max );
+	}
+	
+	static void WritePrivateProfileFloat(const std::string app_name, const std::string key_name, const float value)
+	{
+		char buffer[512];
+		
+		sprintf_s(buffer, sizeof(buffer), "%.3f", value);
+		
+		WritePrivateProfileString( app_name.c_str(), key_name.c_str(), buffer, IniName );
+	}
+	
+	static float GetPrivateProfileFloat(const std::string app_name, const std::string key_name, const float default_value)
+	{
+		char buffer[512];
+		
+		GetPrivateProfileString( app_name.c_str(), key_name.c_str(), "", buffer, sizeof(buffer), IniName );
+		
+		if( strcmp(buffer, "") == 0 )
+			return default_value;
+		
+		try
+		{
+			return std::stof(buffer);
+		}
+		catch(...)
+		{
+			return default_value;
+		}
+	}
+	#endif
+}
+#endif
+
+#ifdef X432R_CUSTOMRENDERER_ENABLED
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1700)
+#ifdef X432R_PPL_TEST
+#include <ppl.h>
+#endif
+#endif
+
+#ifdef X432R_D3D_DISPLAYMETHOD_ENABLED
+#pragma comment(lib, "d3d9.lib")
+#include <d3d9.h>
+#endif
+
+namespace X432R
+{
+	CRITICAL_SECTION customFrontBufferSync;
+	
+	HighResolutionFramebuffers backBuffer;
+	
+	#ifndef X432R_D3D_DISPLAYMETHOD_ENABLED
+	static GLuint screenTexture = 0;
+	static GLuint hudTexture = 0;
+	static u32 lastRenderMagnification = 1;
+	#endif
+	static volatile bool screenTextureUpdated = false;
+	
+	static u32 frontBuffer[3][1024 * 768 * 2] = {0};
+	static u32 hudBuffer[256 * 192 * 2] = {0};
+	static u32 masterBrightness[3][2] = {0};
+	static bool isHighResolutionScreen[3][2] = {0};
+	
+	static const bool *isHighResolutionScreen_Current = isHighResolutionScreen[0];
+	
+	#ifdef X432R_LOWQUALITYMODE_TEST
+	bool lowQualityMsaaEnabled = false;
+	bool lowQualityAlphaBlendEnabled = false;
+	#endif
+	
+	#ifdef X432R_CUSTOMRENDERER_DEBUG
+	bool debugModeEnabled = true;
+	bool debugModeEnabled2 = false;
+	#endif
+	
+	
+	void ClearBuffers()
+	{
+		Lock lock(customFrontBufferSync);
+		
+		backBuffer.Clear();
+		
+		memset( frontBuffer, 0xFF, sizeof(frontBuffer) );
+		memset( masterBrightness, 0, sizeof(masterBrightness) );
+		memset( isHighResolutionScreen, 0, sizeof(isHighResolutionScreen) );
+		
+		screenTextureUpdated = false;
+	}
+	
+	
+	inline bool IsHighResolutionRendererSelected()
+	{
+		switch(cur3DCore)
+		{
+			case GPU3D_SWRAST_X2:
+			case GPU3D_SWRAST_X3:
+			case GPU3D_SWRAST_X4:
+			case GPU3D_OPENGL_X2:
+			case GPU3D_OPENGL_X3:
+			case GPU3D_OPENGL_X4:
+				return true;
+		}
+		
+		return false;
+	}
+	
+	inline bool IsSoftRasterzierSelected()
+	{
+		switch(cur3DCore)
+		{
+			case GPU3D_SWRAST:
+			case GPU3D_SWRAST_X2:
+			case GPU3D_SWRAST_X3:
+			case GPU3D_SWRAST_X4:
+				return true;
+		}
+		
+		return false;
+	}
+	
+	inline u32 GetCurrentRenderMagnification()
+	{
+		switch(cur3DCore)
+		{
+			case GPU3D_SWRAST_X2:
+			case GPU3D_OPENGL_X2:
+				return 2;
+			
+			case GPU3D_SWRAST_X3:
+			case GPU3D_OPENGL_X3:
+				return 3;
+			
+			case GPU3D_SWRAST_X4:
+			case GPU3D_OPENGL_X4:
+				return 4;
+		}
+		
+		return 1;
+	}
+	
+	
+	static inline void Lock_forHighResolutionFrontBuffer()
+	{
+		EnterCriticalSection(&customFrontBufferSync);
+	}
+	
+	static inline void Unlock_forHighResolutionFrontBuffer()
+	{
+		LeaveCriticalSection(&customFrontBufferSync);
+	}
+	
+/*	static inline bool TryLock_forHighResolutionFrontBuffer()
+	{
+		return TryEnterCriticalSection(&customFrontBufferSync);
+	}
+*/	
+	
+	//---------- debug ----------
+	
+	#ifdef X432R_PROCESSTIME_CHECK
+	inline void ProcessTimeCounter::Start()
+	{
+		startTime = timeGetTime();
+//		++execCount;
+	}
+	
+	inline void ProcessTimeCounter::Stop()
+	{
+		totalTime += ( timeGetTime() - startTime );
+	}
+	
+	inline void ProcessTimeCounter::Reset(const u32 fps)
+	{
+		Time = ( (fps == 0) || (fps >= 60) ) ? totalTime : (u32)( (float)totalTime * ( 60.0f / (float)fps ) );
+//		Count = execCount;
+		
+		totalTime = 0;
+//		execCount = 0;
+	}
+	
+	ProcessTimeCounter timeCounter_3D;
+	ProcessTimeCounter timeCounter_3DFinish1;
+	ProcessTimeCounter timeCounter_3DFinish2;
+	ProcessTimeCounter timeCounter_2D;
+	ProcessTimeCounter timeCounter_2DHighReso;
+	ProcessTimeCounter timeCounter_Final;
+	ProcessTimeCounter timeCounter_Display;
+	ProcessTimeCounter timeCounter_LockMain;
+	ProcessTimeCounter timeCounter_LockDisp;
+	#endif
+	
+	#ifdef X432R_CUSTOMRENDERER_DEBUG
+	void ShowDebugMessage(std::string message)
+	{
+		if( (osd == NULL) || !debugModeEnabled ) return;
+		
+		osd->setLineColor(0xFF, 0x80, 0);
+		osd->addLine( message.c_str() );
+		osd->setLineColor(0xFF, 0xFF, 0xFF);
+	}
+	#endif
+	
+	
+//	static const std::string windowCaption = (std::string)EMU_DESMUME_NAME_AND_VERSION() + (std::string)" - fps:";
+	static const std::string windowCaption = "DeSmuME X432R - fps:";
+	
+	static inline void UpdateWindowCaptionFPS(const u32 fps, const u32 fps3d)
+	{
+		if( paused || finished || !romloaded || (MainWindow == NULL) ) return;
+		
+		#ifndef X432R_PROCESSTIME_CHECK
+		const std::string caption = windowCaption + std::to_string(fps) + "/" + std::to_string(fps3d);
+		#else
+		timeCounter_3D.Reset(fps);
+		timeCounter_3DFinish1.Reset(fps);
+		timeCounter_3DFinish2.Reset(fps);
+		timeCounter_2D.Reset(fps);
+		timeCounter_2DHighReso.Reset(fps);
+		timeCounter_Final.Reset(fps);
+		timeCounter_Display.Reset(fps);
+		timeCounter_LockMain.Reset(fps);
+		timeCounter_LockDisp.Reset(fps);
+		
+		std::string caption = std::to_string(fps) + "/" + std::to_string(fps3d);
+		caption += " " + std::to_string(timeCounter_3D.Time + timeCounter_3DFinish2.Time + timeCounter_2D.Time + timeCounter_Final.Time + timeCounter_LockMain.Time);
+		caption += "(3:" + std::to_string(timeCounter_3D.Time);
+		caption += " 3F1:" + std::to_string(timeCounter_3DFinish1.Time);
+		caption += " 3F2:" + std::to_string(timeCounter_3DFinish2.Time);
+		caption += " 2:" + std::to_string(timeCounter_2D.Time);
+		caption += " 2H:" + std::to_string(timeCounter_2DHighReso.Time);
+		caption += " F:" + std::to_string(timeCounter_Final.Time);
+		caption += " L:" + std::to_string(timeCounter_LockMain.Time);
+		caption +=  ")/" + std::to_string(timeCounter_Display.Time) + "(";
+		caption += "L:" + std::to_string(timeCounter_LockDisp.Time) + ") ";
+		
+		caption += (std::string)( isHighResolutionScreen_Current[0] ? "H" : "L" ) + "/" + (std::string)( isHighResolutionScreen_Current[1] ? "H" : "L" );
+		#endif
+		
+		SetWindowText( MainWindow->getHWnd(), caption.c_str() );
+	}
+	
+	
+	//---------- MainThread用 ----------
+	
+	static void UpdateFrontBuffer()
+	{
+		static bool buffers_cleared = false;
+		
+		if( !IsHighResolutionRendererSelected() || !romloaded || finished || display_die )
+		{
+			if( !buffers_cleared )
+			{
+				ClearBuffers();
+				
+				buffers_cleared = true;
+			}
+			
+			return;
+		}
+		
+		buffers_cleared = false;
+		
+		
+		#ifdef X432R_PROCESSTIME_CHECK
+		timeCounter_LockMain.Start();
+		#endif
+		
+		Lock lock(customFrontBufferSync);		// スコープを抜けてこのインスタンスのデストラクタが呼ばれると自動的にロックが解除される
+		
+		#ifdef X432R_PROCESSTIME_CHECK
+		timeCounter_LockMain.Stop();
+		#endif
+		
+		#ifdef X432R_PROCESSTIME_CHECK
+		AutoStopTimeCounter timecounter(timeCounter_Final);
+		#endif
+		
+		const u8 buffer_index = CommonSettings.single_core() ? 0 : clamp(newestDisplayBuffer, 0, 2);
+		
+		u32 * const front_buffer = frontBuffer[buffer_index];
+		u32 * const master_brightness = masterBrightness[buffer_index];
+		bool * const is_highreso_screen = isHighResolutionScreen[buffer_index];
+		
+		switch(cur3DCore)
+		{
+			case GPU3D_SWRAST_X2:
+			case GPU3D_OPENGL_X2:
+				backBuffer.UpdateFrontBufferAndDisplayCapture<2>(front_buffer, master_brightness, is_highreso_screen);
+				break;
+			
+			case GPU3D_SWRAST_X3:
+			case GPU3D_OPENGL_X3:
+				backBuffer.UpdateFrontBufferAndDisplayCapture<3>(front_buffer, master_brightness, is_highreso_screen);
+				break;
+			
+			case GPU3D_SWRAST_X4:
+			case GPU3D_OPENGL_X4:
+				backBuffer.UpdateFrontBufferAndDisplayCapture<4>(front_buffer, master_brightness, is_highreso_screen);
+				break;
+		}
+		
+		isHighResolutionScreen_Current = is_highreso_screen;
+		
+		screenTextureUpdated = false;
+	}
+	
+	static void ChangeRenderMagnification(const u32 magnification)
+	{
+		const bool softrast = IsSoftRasterzierSelected();
+		
+//		switch( clamp<u32>(magnification, 1, 4) )
+		switch(magnification)
+		{
+			case 2:
+				cur3DCore = softrast ? GPU3D_SWRAST_X2 : GPU3D_OPENGL_X2;
+				break;
+			
+			case 3:
+				cur3DCore = softrast ? GPU3D_SWRAST_X3 : GPU3D_OPENGL_X3;
+				break;
+			
+			case 4:
+				cur3DCore = softrast ? GPU3D_SWRAST_X4 : GPU3D_OPENGL_X4;
+				break;
+			
+			default:
+				cur3DCore = softrast ? GPU3D_SWRAST : GPU3D_OPENGL_3_2;
+				break;
+		}
+		
+		Change3DCoreWithFallbackAndSave(cur3DCore);
+	}
+	
+	
+	//---------- DisplayThread用 ----------
+	
+	static inline bool IsHudVisible()
+	{
+		if(osd == NULL) return false;
+		
+		return
+		(
+			CommonSettings.hud.ShowInputDisplay ||
+			CommonSettings.hud.ShowGraphicalInputDisplay ||
+			CommonSettings.hud.FpsDisplay ||
+			CommonSettings.hud.FrameCounterDisplay ||
+			CommonSettings.hud.ShowLagFrameCounter ||
+			CommonSettings.hud.ShowMicrophone ||
+			CommonSettings.hud.ShowRTC ||
+			( osd->GetLineCount() > 0 )
+		);
+	}
+	
+	
+	template <u32 RENDER_MAGNIFICATION, u32 ROTATION_ANGLE, bool HIGHRESO, bool HUD_VISIBLE>
+	static void DD_UpdateBackSurface(const u32 *source_buffer, const u32 master_brightness, const u32 screen_index)
+	{
+		const u32 dest_linepitch = ddraw.surfDescBack.lPitch / sizeof(u32);
+		u32 * const destbuffer_begin = (u32 *)ddraw.surfDescBack.lpSurface;
+		u32 *dest_buffer;
+		
+		source_buffer += (screen_index * 256 * 192 * RENDER_MAGNIFICATION * RENDER_MAGNIFICATION);
+		
+		const u32 * const hud_buffer = hudBuffer + (screen_index * 256 * 192);
+		
+		s32 dest_x, dest_y, dest_begin_x, dest_begin_y, dest_end_x, dest_end_y;
+		s32 source_x, source_y, source_begin_x, source_begin_y;
+		s32 downscaled_index;
+		
+		RGBA8888 color_rgba8888, hud_rgba8888;
+		
+		switch(ROTATION_ANGLE)
+		{
+			case 90:
+//				dest_begin_x = screen_index ? (192 * RENDER_MAGNIFICATION) : 0;
+				dest_begin_x = screen_index ? 0 : (192 * RENDER_MAGNIFICATION);
+				dest_begin_y = 0;
+				dest_end_x = dest_begin_x + (192 * RENDER_MAGNIFICATION);
+				dest_end_y = dest_begin_y + (256 * RENDER_MAGNIFICATION);
+				
+				source_begin_x = 0;
+				source_begin_y = (192 * RENDER_MAGNIFICATION) - 1;
+				break;
+				
+			case 180:
+				dest_begin_x = 0;
+//				dest_begin_y = screen_index ? (192 * RENDER_MAGNIFICATION) : 0;
+				dest_begin_y = screen_index ? 0 : (192 * RENDER_MAGNIFICATION);
+				dest_end_x = 256 * RENDER_MAGNIFICATION;
+				dest_end_y = dest_begin_y + (192 * RENDER_MAGNIFICATION);
+				
+				source_begin_x = (256 * RENDER_MAGNIFICATION) - 1;
+				source_begin_y = (192 * RENDER_MAGNIFICATION) - 1;
+				break;
+				
+			case 270:
+				dest_begin_x = screen_index ? (192 * RENDER_MAGNIFICATION) : 0;
+				dest_begin_y = 0;
+				dest_end_x = dest_begin_x + (192 * RENDER_MAGNIFICATION);
+				dest_end_y = dest_begin_y + (256 * RENDER_MAGNIFICATION);
+				
+				source_begin_x = (256 * RENDER_MAGNIFICATION) - 1;
+				source_begin_y = 0;
+				break;
+				
+			default:
+				dest_begin_x = 0;
+				dest_begin_y = screen_index ? (192 * RENDER_MAGNIFICATION) : 0;
+				dest_end_x = 256 * RENDER_MAGNIFICATION;
+				dest_end_y = dest_begin_y + (192 * RENDER_MAGNIFICATION);
+				
+				source_begin_x = 0;
+				source_begin_y = 0;
+				break;
+		}
+		
+		source_x = source_begin_x;
+		source_y = source_begin_y;
+		
+		
+		for(dest_y = dest_begin_y; dest_y < dest_end_y; ++dest_y)
+		{
+			dest_buffer = destbuffer_begin + (dest_y * dest_linepitch) + dest_begin_x;
+			
+			for(dest_x = dest_begin_x; dest_x < dest_end_x; ++dest_x, ++dest_buffer)
+			{
+				if( !HIGHRESO || HUD_VISIBLE )
+					downscaled_index = ( (source_y / RENDER_MAGNIFICATION) * 256 ) + (source_x / RENDER_MAGNIFICATION);
+				
+				if( !HIGHRESO )
+					color_rgba8888 = source_buffer[downscaled_index];
+				else
+					color_rgba8888 = source_buffer[ (source_y * 256 * RENDER_MAGNIFICATION) + source_x ];
+				
+				color_rgba8888.AlphaBlend(master_brightness);
+				
+				if(HUD_VISIBLE)
+					color_rgba8888.AlphaBlend( hud_buffer[downscaled_index] );
+				
+				*dest_buffer = color_rgba8888.Color;
+				
+				switch(ROTATION_ANGLE)
+				{
+					case 90:	--source_y;		break;
+					case 180:	--source_x;		break;
+					case 270:	++source_y;		break;
+					default:	++source_x;		break;
+				}
+			}
+			
+			switch(ROTATION_ANGLE)
+			{
+				case 90:	++source_x;		source_y = source_begin_y;		break;
+				case 180:	--source_y;		source_x = source_begin_x;		break;
+				case 270:	--source_x;		source_y = source_begin_y;		break;
+				default:	++source_y;		source_x = source_begin_x;		break;
+			}
+		}
+	}
+	
+	static void DD_FillRect(LPDIRECTDRAWSURFACE7 surface, const u32 left, const u32 top, const u32 right, const u32 bottom)
+	{
+		RECT rect;
+		SetRect(&rect, left, top, right, bottom);
+		
+		DDBLTFX effect;
+		memset( &effect, 0, sizeof(DDBLTFX) );
+		effect.dwSize = sizeof(DDBLTFX);
+		
+		effect.dwFillColor = ScreenGapColor;		// 32bpp環境のみ考慮
+		
+		surface->Blt(&rect, NULL, NULL, DDBLT_COLORFILL | DDBLT_WAIT, &effect);
+	}
+	
+	template <u32 RENDER_MAGNIFICATION>
+	static void DD_DoDisplay()
+	{
+		#ifdef X432R_PROCESSTIME_CHECK
+		AutoStopTimeCounter timecounter(timeCounter_Display);
+		#endif
+		
+		
+		const HWND window_handle = MainWindow->getHWnd();
+		const bool hud_visible = IsHudVisible();
+		
+		const u32 rotation_angle = (video.layout == 0) ? video.rotation : 0;
+		const bool source_rect_rotation = (rotation_angle == 90) || (rotation_angle == 270);
+		bool screen_swap = false;
+		
+		switch(video.swap)
+		{
+			case 1:		screen_swap = true;							break;
+			#ifndef X432R_CUSTOMSCREENSCALING_ENABLED
+			case 2:		screen_swap = (MainScreen.offset > 0);		break;
+			case 3:		screen_swap = (SubScreen.offset > 0);		break;
+			#endif
+		}
+		
+		if( !screenTextureUpdated || hud_visible )
+		{
+			if(hud_visible)
+			{
+				osd->swapScreens = screen_swap;
+				aggDraw.hud->attach( (u8*)hudBuffer, 256, 192 * 2, 256 * 4 );
+				aggDraw.hud->clear();
+				DoDisplay_DrawHud();
+			}
+			
+			if( !ddraw.lock() ) return;
+			
+			const u32 color_depth = ddraw.surfDescBack.ddpfPixelFormat.dwRGBBitCount;
+			
+			if(color_depth != 32)
+			{
+				ddraw.unlock();
+				
+				if(color_depth != 0)
+				{
+					INFO("X432R: DirectDraw Output failed.\nDisplay Color-Depth must be 32bpp.\n");
+					
+					osd->addLine("X432R: DirectDraw Output failed.");
+					
+					#ifndef X432R_D3D_DISPLAYMETHOD_ENABLED
+					SetStyle( ( GetStyle() & ~DWS_DISPMETHODS ) | DWS_OPENGL );
+					WritePrivateProfileInt("Video","Display Method", DISPMETHOD_OPENGL, IniName);
+					ddraw.createSurfaces(window_handle);
+					#else
+					ChangeRenderMagnification(1);
+					#endif
+				}
+				
+				return;
+			}
+			
+			static u8 buffer_index = 0;
+			
+			if( !screenTextureUpdated )
+			{
+				#ifdef X432R_PROCESSTIME_CHECK
+				timeCounter_LockDisp.Start();
+				#endif
+				
+				Lock lock(customFrontBufferSync);
+				
+				#ifdef X432R_PROCESSTIME_CHECK
+				timeCounter_LockDisp.Stop();
+				#endif
+				
+				buffer_index = CommonSettings.single_core() ? 0 : clamp(currDisplayBuffer, 0, 2);
+				screenTextureUpdated = true;
+			}
+			
+			const u32 * const front_buffer = frontBuffer[buffer_index];
+			const u32 * const master_brightness = masterBrightness[buffer_index];
+			const bool * const is_highreso_screen = isHighResolutionScreen[buffer_index];
+			
+			#define X432R_CALL_UPDATEBACKSURFACE(rotation_angle,screen_index) \
+			{ \
+				if( is_highreso_screen[screen_index] ) \
+				{ \
+					if(hud_visible) \
+						DD_UpdateBackSurface<RENDER_MAGNIFICATION, rotation_angle, true, true>(front_buffer, master_brightness[screen_index], screen_index); \
+					else \
+						DD_UpdateBackSurface<RENDER_MAGNIFICATION, rotation_angle, true, false>(front_buffer, master_brightness[screen_index], screen_index); \
+				} \
+				else \
+				{ \
+					if(hud_visible) \
+						DD_UpdateBackSurface<RENDER_MAGNIFICATION, rotation_angle, false, true>(front_buffer, 0, screen_index); \
+					else \
+						DD_UpdateBackSurface<RENDER_MAGNIFICATION, rotation_angle, false, false>(front_buffer, 0, screen_index); \
+				} \
+			}
+			
+			for(u32 i = 0; i < 2; ++i)
+			{
+				switch(rotation_angle)
+				{
+					case 90:	X432R_CALL_UPDATEBACKSURFACE(90, i);	break;
+					case 180:	X432R_CALL_UPDATEBACKSURFACE(180, i);	break;
+					case 270:	X432R_CALL_UPDATEBACKSURFACE(270, i);	break;
+					default:	X432R_CALL_UPDATEBACKSURFACE(0, i);		break;
+				}
+			}
+			
+			#undef X432R_CALL_UPDATEBACKSURFACE
+			
+			if( !ddraw.unlock() ) return;
+		}
+		
+		RECT window_rect, screen_rect;
+		
+		GetWindowRect(window_handle, &window_rect);
+		GetNdsScreenRect(&screen_rect);
+		
+		RECT screen_source_rect[2] =
+		{
+			{
+				0,
+				0,
+				source_rect_rotation ?		(192 * RENDER_MAGNIFICATION)			: (256 * RENDER_MAGNIFICATION),
+				source_rect_rotation ?		(256 * RENDER_MAGNIFICATION)			: (192 * RENDER_MAGNIFICATION)
+			},
+			{
+				source_rect_rotation ?		(192 * RENDER_MAGNIFICATION)			: 0,
+				source_rect_rotation ?		0										: (192 * RENDER_MAGNIFICATION),
+				source_rect_rotation ?		(192 * RENDER_MAGNIFICATION * 2)		: (256 * RENDER_MAGNIFICATION),
+				source_rect_rotation ?		(256 * RENDER_MAGNIFICATION)			: (192 * RENDER_MAGNIFICATION * 2)
+			}
+		};
+		
+		#ifndef X432R_CUSTOMSCREENSCALING_ENABLED
+		RECT *source_rect[2] =
+		{
+			&screen_source_rect[0],
+			&screen_source_rect[1]
+		};
+		
+		RECT *dest_rect[2] =
+		{
+			screen_swap ? &SubScreenRect : &MainScreenRect,
+			screen_swap ? &MainScreenRect : &SubScreenRect
+		};
+		
+		if( IsZoomed(window_handle) )
+		{
+			DD_FillRect(	ddraw.surface.primary,		0,						0,						screen_rect.left,		window_rect.bottom		);		// left
+			DD_FillRect(	ddraw.surface.primary,		screen_rect.right,		0,						window_rect.right,		window_rect.bottom		);		// right
+			DD_FillRect(	ddraw.surface.primary,		screen_rect.left,		0,						screen_rect.right,		screen_rect.top			);		// top
+			DD_FillRect(	ddraw.surface.primary,		screen_rect.left,		screen_rect.bottom,		screen_rect.right,		window_rect.bottom		);		// bottom
+		}
+		
+		if( (video.layout == 0) && (video.screengap > 0) )
+			DD_FillRect(ddraw.surface.primary, GapRect.left, GapRect.top, GapRect.right, GapRect.bottom);
+		
+		if(video.layout == 2)
+		{
+			const u32 screen_index = screen_swap ? 1 : 0;
+			
+			ddraw.blt( dest_rect[screen_index], source_rect[screen_index] );
+		}
+		else
+		{
+			ddraw.blt( dest_rect[0], source_rect[0] );
+			ddraw.blt( dest_rect[1], source_rect[1] );
+		}
+		#else
+		if( (rotation_angle == 90) || (rotation_angle == 180) )
+			std:swap( screen_source_rect[0], screen_source_rect[1] );
+		
+		RECT *source_rect[2] =
+		{
+			screen_swap ? &screen_source_rect[1] : &screen_source_rect[0],
+			screen_swap ? &screen_source_rect[0] : &screen_source_rect[1]
+		};
+		
+		RECT *dest_rect[2] =
+		{
+			&MainScreenRect,
+			&SubScreenRect
+		};
+		
+		RECT client_rect;
+		GetClientRect(window_handle, &client_rect);
+		
+		client_rect.bottom -= MainWindowToolbar->GetHeight();
+		
+		if( (screen_rect.right - screen_rect.left) < client_rect.right )
+		{
+			DD_FillRect(	ddraw.surface.primary,		0,						0,						screen_rect.left,		window_rect.bottom		);		// left
+			DD_FillRect(	ddraw.surface.primary,		screen_rect.right,		0,						window_rect.right,		window_rect.bottom		);		// right
+		}
+		
+		if( (screen_rect.bottom - screen_rect.top) < client_rect.bottom )
+		{
+			DD_FillRect(	ddraw.surface.primary,		screen_rect.left,		0,						screen_rect.right,		screen_rect.top			);		// top
+			DD_FillRect(	ddraw.surface.primary,		screen_rect.left,		screen_rect.bottom,		screen_rect.right,		window_rect.bottom		);		// bottom
+		}
+		
+		float mainscreen_scale, subscreen_scale;
+		
+		GetScreenScales(mainscreen_scale, subscreen_scale);
+		
+		if( (video.layout != 2) && ( (mainscreen_scale != subscreen_scale) ) )
+		{
+			const RECT &smallscreen_rect = (mainscreen_scale < subscreen_scale) ? MainScreenRect : SubScreenRect;
+			
+			if( (video.layout == 1) || (rotation_angle == 90) || (rotation_angle == 270) )
+			{
+				DD_FillRect(	ddraw.surface.primary,		smallscreen_rect.left,		screen_rect.top,				smallscreen_rect.right,		smallscreen_rect.top		);
+				DD_FillRect(	ddraw.surface.primary,		smallscreen_rect.left,		smallscreen_rect.bottom,		smallscreen_rect.right,		screen_rect.bottom			);
+			}
+			else
+			{
+				DD_FillRect(	ddraw.surface.primary,		screen_rect.left,			smallscreen_rect.top,		smallscreen_rect.left,		smallscreen_rect.bottom		);
+				DD_FillRect(	ddraw.surface.primary,		smallscreen_rect.right,		smallscreen_rect.top,		screen_rect.right,			smallscreen_rect.bottom		);
+			}
+		}
+		
+		if( (video.layout == 0) && (video.screengap > 0) )
+			DD_FillRect(ddraw.surface.primary, GapRect.left, GapRect.top, GapRect.right, GapRect.bottom);
+		
+		if(video.layout == 2)
+			ddraw.blt( dest_rect[0], source_rect[0] );
+		else
+		{
+			ddraw.blt( dest_rect[0], source_rect[0] );
+			ddraw.blt( dest_rect[1], source_rect[1] );
+		}
+		#endif
+	}
+	
+	
+	#ifndef X432R_D3D_DISPLAYMETHOD_ENABLED
+//	inline GLuint GetScreenTexture()
+	inline u32 GetScreenTexture()
+	{
+		if(screenTexture == 0)
+			glGenTextures(1, &screenTexture);
+		
+		return screenTexture;
+	}
+	
+	static inline void DeleteScreenTexture()
+	{
+		lastRenderMagnification = 1;
+		
+		if(screenTexture != 0)
+		{
+			glDeleteTextures(1, &screenTexture);
+			screenTexture = 0;
+		}
+		
+		if(hudTexture != 0)
+		{
+			glDeleteTextures(1, &hudTexture);
+			hudTexture = 0;
+		}
+	}
+	
+	static void OGL_DoDisplay(const u32 render_magnification)
+	{
+		assert( (lastRenderMagnification >= 1) && (lastRenderMagnification <= 4) );
+		
+		
+		const u32 render_width = 256 * render_magnification;
+		const u32 render_height = 192 * render_magnification;
+		const u32 texture_width = render_width;
+		const u32 texture_height = render_height * 2;
+		
+		
+		if( !gldisplay.begin() ) return;
+		
+		#ifdef X432R_PROCESSTIME_CHECK
+		AutoStopTimeCounter timecounter(timeCounter_Display);
+		#endif
+		
+		
+		// 作成可能な最大テクスチャサイズをチェック
+		static int max_texture_size = 0;
+		
+		if(max_texture_size == 0)
+		{
+			glGetIntegerv(GL_MAX_TEXTURE_SIZE, &max_texture_size);
+			INFO( "X432R: OpenGL supported texture size:%d (required:%d)\n", max_texture_size, (texture_width * 4) );
+			
+			if( max_texture_size < (texture_width * 4) )
+			{
+				gldisplay.end();
+				
+				INFO("X432R: High-Resolution Output failed.\n");
+				Change3DCoreWithFallbackAndSave(GPU3D_OPENGL_3_2);
+				return;
+			}
+			
+			INFO("X432R: High-Resolution Output OK.\n");
+		}
+		
+		
+		const HWND window_handle = MainWindow->getHWnd();
+		const u32 window_style = GetStyle();
+		
+		RECT client_rect;
+		GetClientRect(window_handle, &client_rect);
+		
+		const int window_width = client_rect.right;
+		const int window_height = client_rect.bottom;
+		
+		
+		// 画面描画用テクスチャ生成
+		glPixelStorei(GL_UNPACK_ALIGNMENT, 4);
+		
+		if(hudTexture == 0)
+		{
+			glGenTextures(1, &hudTexture);
+			
+			glBindTexture(GL_TEXTURE_2D, hudTexture);
+			glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, 256, 192 * 2, 0, GL_BGRA, GL_UNSIGNED_BYTE, NULL);
+		}
+		
+		if(screenTexture == 0)
+			glGenTextures(1, &screenTexture);
+		
+		glBindTexture(GL_TEXTURE_2D, screenTexture);
+		
+		if(lastRenderMagnification != render_magnification)
+		{
+			lastRenderMagnification = render_magnification;
+			
+			glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, texture_width, texture_height, 0, GL_BGRA, GL_UNSIGNED_BYTE, NULL);		// データを転送せずに領域だけ確保
+		}
+		
+		static bool is_highreso_screen[2] = {false, false};
+		static u32 master_brightness[2] = {0, 0};
+		
+		if( !screenTextureUpdated )
+		{
+			#ifdef X432R_PROCESSTIME_CHECK
+			timeCounter_LockDisp.Start();
+			#endif
+			
+			Lock_forHighResolutionFrontBuffer();
+			
+			#ifdef X432R_PROCESSTIME_CHECK
+			timeCounter_LockDisp.Stop();
+			#endif
+			
+			screenTextureUpdated = true;
+			
+			const u8 buffer_index = CommonSettings.single_core() ? 0 : clamp(currDisplayBuffer, 0, 2);
+			const u32 * const front_buffer = frontBuffer[buffer_index];
+			
+			is_highreso_screen[0] = isHighResolutionScreen[buffer_index][0];
+			is_highreso_screen[1] = isHighResolutionScreen[buffer_index][1];
+			
+			master_brightness[0] = is_highreso_screen[0] ? masterBrightness[buffer_index][0] : 0;
+			master_brightness[1] = is_highreso_screen[1] ? masterBrightness[buffer_index][1] : 0;
+			
+			Unlock_forHighResolutionFrontBuffer();
+			
+			if( is_highreso_screen[0] && is_highreso_screen[1] )
+				glTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, texture_width, texture_height, GL_BGRA, GL_UNSIGNED_BYTE, front_buffer);
+			else
+			{
+				if( is_highreso_screen[0] )
+					glTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, render_width, render_height, GL_BGRA, GL_UNSIGNED_BYTE, front_buffer);
+				else
+					glTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, 256, 192, GL_BGRA, GL_UNSIGNED_BYTE, front_buffer);
+				
+				if( is_highreso_screen[1] )
+					glTexSubImage2D( GL_TEXTURE_2D, 0, 0, render_height, render_width, render_height, GL_BGRA, GL_UNSIGNED_BYTE, front_buffer + (render_width * render_height) );
+				else
+					glTexSubImage2D( GL_TEXTURE_2D, 0, 0, render_height, 256, 192, GL_BGRA, GL_UNSIGNED_BYTE, front_buffer + (render_width * render_height) );
+			}
+		}
+		
+		
+		// テクスチャ座標生成
+		const float default_texcoord[2][8] =
+		{
+			{
+				0.0f,		0.0f,
+				1.0f,		0.0f,
+				1.0f,		0.5f,
+				0.0f,		0.5f
+			},
+			{
+				0.0f,		0.5f,
+				1.0f,		0.5f,
+				1.0f,		1.0f,
+				0.0f,		1.0f
+			}
+		};
+		
+		const float lowreso_texcoord[2][8] =
+		{
+			{
+				0.0f,								0.0f,
+				256.0f / (float)texture_width,		0.0f,
+				256.0f / (float)texture_width,		192.0f / (float)texture_height,
+				0.0f,								192.0f / (float)texture_height
+			},
+			{
+				0.0f,								0.5f,
+				256.0f / (float)texture_width,		0.5f,
+				256.0f / (float)texture_width,		0.5f + ( 192.0f / (float)texture_height ),
+				0.0f,								0.5f + ( 192.0f / (float)texture_height )
+			}
+		};
+		
+		const u32 rotation = (video.layout == 0) ? video.rotation : 0;
+		
+		float texcoord[2][8];
+		float texcoord_hud[2][8];
+		
+		bool screen_swap = false;
+		bool hud_swap = false;
+		u32 texture_index_offset = 0;
+		u32 i;
+		
+		switch(video.swap)
+		{
+			case 1:		screen_swap = true;							break;
+			#ifndef X432R_CUSTOMSCREENSCALING_ENABLED
+			case 2:		screen_swap = (MainScreen.offset > 0);		break;
+			case 3:		screen_swap = (SubScreen.offset > 0);		break;
+			#endif
+		}
+		
+		hud_swap = screen_swap;
+		
+		switch(rotation)
+		{
+			case 90:
+				texture_index_offset = 6;
+				#ifndef X432R_CUSTOMSCREENSCALING_ENABLED
+				screen_swap = !screen_swap;
+				#endif
+				break;
+				
+			case 180:
+				texture_index_offset = 4;
+				#ifndef X432R_CUSTOMSCREENSCALING_ENABLED
+				screen_swap = !screen_swap;
+				#endif
+				break;
+				
+			case 270:
+				texture_index_offset = 2;
+				break;
+		}
+		
+		for(i = 0; i < 8; ++i)
+		{
+			u32 index = (i + texture_index_offset) % 8;
+			
+			texcoord[0][i] = is_highreso_screen[0] ? default_texcoord[0][index] : lowreso_texcoord[0][index];
+			texcoord[1][i] = is_highreso_screen[1] ? default_texcoord[1][index] : lowreso_texcoord[1][index];
+			
+			texcoord_hud[0][i] = default_texcoord[0][index];
+			texcoord_hud[1][i] = default_texcoord[1][index];
+		}
+		
+		
+		// ポリゴン座標配列生成
+		const u32 upperscreen_index = screen_swap ? 1 : 0;
+		const u32 lowerscreen_index = screen_swap ? 0 : 1;
+		const RECT screen_rect[] = {MainScreenRect, SubScreenRect};
+		
+		for(i = 0; i < 2; ++i)
+		{
+			ScreenToClient( window_handle, (LPPOINT)&screen_rect[i].left );
+			ScreenToClient( window_handle, (LPPOINT)&screen_rect[i].right );
+		}
+		
+		const float polygon_vertices[2][8] =
+		{
+			{
+				screen_rect[upperscreen_index].left,		screen_rect[upperscreen_index].top,
+				screen_rect[upperscreen_index].right,		screen_rect[upperscreen_index].top,
+				screen_rect[upperscreen_index].right,		screen_rect[upperscreen_index].bottom,
+				screen_rect[upperscreen_index].left,		screen_rect[upperscreen_index].bottom
+			},
+			{
+				screen_rect[lowerscreen_index].left,		screen_rect[lowerscreen_index].top,
+				screen_rect[lowerscreen_index].right,		screen_rect[lowerscreen_index].top,
+				screen_rect[lowerscreen_index].right,		screen_rect[lowerscreen_index].bottom,
+				screen_rect[lowerscreen_index].left,		screen_rect[lowerscreen_index].bottom
+			}
+		};
+		
+		
+		// 描画開始
+		const RGBA8888 clearcolor = (u32)ScreenGapColor;
+		const GLuint texture_filter = ( GetStyle() & DWS_FILTER ) ? GL_LINEAR : GL_NEAREST;
+		const bool single_screen_mode = (video.layout == 2);
+		
+		glDisable(GL_LIGHTING);
+		glDisable(GL_DEPTH_TEST);
+		glDisable(GL_STENCIL_TEST);
+		glDisable(GL_CULL_FACE);
+		glDisable(GL_ALPHA);
+		
+		glEnable(GL_TEXTURE_2D);
+		glEnableClientState(GL_VERTEX_ARRAY);
+		glEnableClientState(GL_TEXTURE_COORD_ARRAY);
+		
+		glViewport(0, 0, window_width, window_height);
+		
+		glMatrixMode(GL_PROJECTION);
+		glLoadIdentity();
+		glOrtho( 0.0f, (float)window_width, (float)window_height, 0.0f, -100.0f, 100.0f );
+		
+		glMatrixMode(GL_MODELVIEW);
+		glLoadIdentity();
+		
+		glClearColor( (float)clearcolor.R / 255.0f, (float)clearcolor.G / 255.0f, (float)clearcolor.B / 255.0f, 1.0f );
+		glClear(GL_COLOR_BUFFER_BIT);				// Viewport全体をScreen Gapの色でクリア
+		
+		glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);
+		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, texture_filter);
+		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, texture_filter);
+		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
+		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
+		
+//		glColor4ub(0xFF, 0xFF, 0xFF, 0xFF);
+		glVertexPointer(2, GL_FLOAT, 0, polygon_vertices);
+		
+		
+		glDisable(GL_BLEND);
+		glBlendFunc(GL_ONE, GL_ZERO);
+		
+		glTexCoordPointer(2, GL_FLOAT, 0, texcoord);
+		
+		if(single_screen_mode)
+			glDrawArrays(GL_QUADS, screen_swap ? 4 : 0, 4);
+		else
+			glDrawArrays(GL_QUADS, 0, 4 * 2);
+		
+		glEnable(GL_BLEND);
+		glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+		
+		
+		if( ( master_brightness[0] != 0 ) || ( master_brightness[1] != 0) )
+		{
+//			glDisable(GL_TEXTURE_2D);
+			glBindTexture(GL_TEXTURE_2D, 0);
+			glEnableClientState(GL_COLOR_ARRAY);
+			
+			#if 0
+			u8 fade_colors[2][4][4];
+			RGBA8888 brightness;
+			u32 j;
+			
+			for(i = 0; i < 2; ++i)
+			{
+				brightness = master_brightness[i]
+				
+				for(j = 0; j < 4; ++j)
+				{
+					fade_colors[i][j][0] = brightness.R;
+					fade_colors[i][j][1] = brightness.G;
+					fade_colors[i][j][2] = brightness.B;
+					fade_colors[i][j][3] = brightness.A;
+				}
+			}
+			#else
+			const u32 fade_colors[8] =
+			{
+				master_brightness[0], master_brightness[0], master_brightness[0], master_brightness[0],
+				master_brightness[1], master_brightness[1], master_brightness[1], master_brightness[1]
+			};
+			#endif
+			
+			glColorPointer(4, GL_UNSIGNED_BYTE, 0, fade_colors);
+			
+			if(single_screen_mode)
+				glDrawArrays(GL_QUADS, screen_swap ? 4 : 0, 4);
+			else
+				glDrawArrays(GL_QUADS, 0, 4 * 2);
+			
+			glDisableClientState(GL_COLOR_ARRAY);
+//			glEnable(GL_TEXTURE_2D);
+		}
+		
+		
+		if( IsHudVisible() )
+		{
+			osd->swapScreens = hud_swap;
+			aggDraw.hud->attach( (u8*)hudBuffer, 256, 192 * 2, 256 * 4 );
+			aggDraw.hud->clear();
+			DoDisplay_DrawHud();
+			
+			glBindTexture(GL_TEXTURE_2D, hudTexture);
+			glTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, 256, 192 * 2, GL_BGRA, GL_UNSIGNED_BYTE, hudBuffer);
+			
+			glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);
+//			glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
+//			glColor4ub(0xFF, 0xFF, 0xFF, 0x7F);
+			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
+			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
+			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
+			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
+			
+			glTexCoordPointer(2, GL_FLOAT, 0, texcoord_hud);
+			
+			if(single_screen_mode)
+				glDrawArrays(GL_QUADS, screen_swap ? 4 : 0, 4);
+			else
+				glDrawArrays(GL_QUADS, 0, 4 * 2);
+		}
+		
+		glBindTexture(GL_TEXTURE_2D, 0);
+		glDisable(GL_TEXTURE_2D);
+		glDisable(GL_BLEND);
+		glDisableClientState(GL_VERTEX_ARRAY);
+		glDisableClientState(GL_TEXTURE_COORD_ARRAY);
+		
+		gldisplay.showPage();
+		gldisplay.end();
+	}
+	#else
+	
+	#define X432R_CALL_D3D_RELEASE(d3d_pointer) \
+		if(d3d_pointer != NULL) \
+		{ \
+			d3d_pointer->Release(); \
+			d3d_pointer = NULL; \
+		}
+	
+	
+	struct D3D_Vertex
+	{
+		float X, Y, Z;
+		float U, V;
+		D3DCOLOR Diffuse;
+		
+		#if 0
+		void Set(const float x, const float y, const float u, const float v, const RGBA8888 color)
+		{
+			X = x - 0.5f;
+			Y = y - 0.5f;
+		#else
+		void Set(const float x, const float y, const float u, const float v, const RGBA8888 color, const bool filter)
+		{
+//			X = filter ? x : (x - 0.5f);
+//			Y = filter ? y : (y - 0.5f);
+			X = x - (filter ? 0.25f : 0.5f);
+			Y = y - (filter ? 0.25f : 0.5f);
+		#endif
+			Z = 0.0f;
+			
+			U = u;
+			V = v;
+			
+			Diffuse = D3DCOLOR_ARGB(color.A, color.R, color.G, color.B);
+		}
+	};
+	
+	static const D3DVERTEXELEMENT9 D3D_VertexElements[] =
+	{
+		{	0,		0,						D3DDECLTYPE_FLOAT3,			D3DDECLMETHOD_DEFAULT,		D3DDECLUSAGE_POSITIONT,		0		},		// x, y, z
+		{	0,		sizeof(float) * 3,		D3DDECLTYPE_FLOAT2,			D3DDECLMETHOD_DEFAULT,		D3DDECLUSAGE_TEXCOORD,		0		},		// u, v
+		{	0,		sizeof(float) * 5,		D3DDECLTYPE_D3DCOLOR,		D3DDECLMETHOD_DEFAULT,		D3DDECLUSAGE_COLOR,			0		},		// diffuse
+		
+		D3DDECL_END()
+	};
+	
+	class D3D_DisplayMethod
+	{
+		public:
+		
+		D3D_DisplayMethod()
+		{
+			direct3d = NULL;
+			d3dDevice = NULL;
+			d3dDeviceStatus = D3DERR_DEVICELOST;
+			
+			d3dTexture_Screen = NULL;
+			d3dTexture_Hud = NULL;
+			
+			d3dPixelShader = NULL;
+			
+			d3dTexture_OffscreenBuffer[0] = NULL;
+			d3dTexture_OffscreenBuffer[1] = NULL;
+			d3dRenderTarget_OffscreenTexture[0] = NULL;
+			d3dRenderTarget_OffscreenTexture[1] = NULL;
+			d3dRenderTarget = NULL;
+			
+			d3dShaderProgramLoaded = false;
+			d3dShaderModel3Supported = false;
+			
+			currentTextureWidth = 0;
+			currentTextureHeight = 0;
+			currentViewportWidth = 0;
+			currentViewportHeight = 0;
+		};
+		
+		~D3D_DisplayMethod()
+		{
+			Deinit(true);
+		};
+		
+		void Deinit(const bool release_all);
+		
+		template <u32 RENDER_MAGNIFICATION>
+		void DoDisplay(const bool highresorenderer_selected);
+		
+		void LoadShaderSettings();
+		void UpdateShaderMenuItems(const bool init_items);
+		
+		
+		private:
+		bool d3dShaderModel3Supported;
+		bool d3dShaderProgramLoaded;
+		
+		IDirect3D9 *direct3d;
+		IDirect3DDevice9 *d3dDevice;
+		HRESULT d3dDeviceStatus;
+		
+		IDirect3DTexture9 *d3dTexture_Screen;
+		IDirect3DTexture9 *d3dTexture_Hud;
+		
+		IDirect3DPixelShader9 *d3dPixelShader;
+		
+		IDirect3DTexture9 *d3dTexture_OffscreenBuffer[2];
+		IDirect3DSurface9 *d3dRenderTarget_OffscreenTexture[2];
+		IDirect3DSurface9 *d3dRenderTarget;
+		
+		u32 currentTextureWidth;
+		u32 currentTextureHeight;
+		u32 currentViewportWidth;
+		u32 currentViewportHeight;
+		
+		void Init(const u32 texture_width, const u32 texture_height, const u32 viewport_width, const u32 viewport_height);
+		
+		void LoadSelectedShader();
+		
+		template <u32 RENDER_MAGNIFICATION>
+		bool UpdateTexture(const u32 * const sourcebuffer_begin, const bool * const is_highreso);
+		
+		template <u32 RENDER_MAGNIFICATION>
+		bool UpdateTexture_fromNativeScreenBuffer();
+		
+		void UpdateTexture_Hud();
+	};
+	
+	
+	static std::string d3dShaderDirectoryPath = "";
+	static std::string d3dShaderSettingsFilePath = "";
+	
+	struct D3D_ShaderFileInfo
+	{
+		std::string Name;
+		std::string PixelShaderFileName;
+		u32 MaxEffectLevel;
+		u32 MaxEffectMode;
+//		std::string ModeName[4];
+		u32 MaxEffectLoop;
+		
+		D3D_ShaderFileInfo()
+		{
+			Clear();
+		}
+		
+		void Clear()
+		{
+			Name.clear();
+			PixelShaderFileName.clear();
+			MaxEffectLevel = 0;
+			MaxEffectMode = 0;
+			MaxEffectLoop = 0;
+		}
+		
+		bool Exists() const
+		{
+			if( ( PixelShaderFileName.length() == 0 ) || !PathFileExists( d3dShaderDirectoryPath.c_str() ) )  return false;
+			
+			return PathFileExists( (d3dShaderDirectoryPath + PixelShaderFileName).c_str() );
+		}
+	};
+	
+	struct BufferedBinaryFileData
+	{
+		BYTE *Buffer;
+		long Size;
+		
+		BufferedBinaryFileData() : Buffer(NULL), Size(0)
+		{}
+		
+		~BufferedBinaryFileData()
+		{
+			Release();
+		}
+		
+		void Release()
+		{
+			if(Buffer != NULL)
+			{
+				delete[] Buffer;
+				Buffer = NULL;
+			}
+			
+			Size = 0;
+		}
+		
+		bool Load(const std::string path)
+		{
+			Release();
+			
+			if( !PathFileExists( path.c_str() ) ) return false;
+			
+			FILE* file = NULL;
+			
+			file = fopen( path.c_str(), "rb" );
+			
+			if(file == NULL) return false;
+			
+			fseek(file, 0, SEEK_END);
+			Size = ftell(file);
+			
+			Buffer = new BYTE[Size];
+			
+			fseek(file, 0, SEEK_SET);
+			fread(Buffer, Size, 1, file);
+			fclose(file);
+			
+			return true;
+		}
+	};
+	
+	
+	static D3D_DisplayMethod d3dDisplayMethod;
+	
+	static const u32 d3dMaxShaderSlot = 9;
+	static const u32 d3dMaxShaderEffectLevel = 3;		// 0〜3
+	static const u32 d3dMaxShaderEffectMode = 3;		// 0〜3
+	static const u32 d3dMaxShaderEffectLoop = 5;
+	
+	static D3D_ShaderFileInfo d3dShaderFileInfo[d3dMaxShaderSlot + 1];
+	static volatile u32 d3dSelectedShaderSlot = 0;
+	static volatile u32 d3dShaderEffectLevel = 0;
+	static volatile u32 d3dShaderEffectMode = 0;
+	static volatile u32 d3dSelectedShaderMaxEffectLevel = 0;
+	static volatile u32 d3dSelectedShaderMaxEffectMode = 0;
+	static volatile bool d3dShaderSettingsChanged = false;
+	static int d3dSelectedShaderMaxEffectLoop = 0;
+	
+	
+	void D3D_DisplayMethod::Deinit(const bool release_all)
+	{
+		currentTextureWidth = 0;
+		currentTextureHeight = 0;
+		currentViewportWidth = 0;
+		currentViewportHeight = 0;
+		
+		screenTextureUpdated = false;
+		d3dShaderProgramLoaded = false;
+		
+		X432R_CALL_D3D_RELEASE(d3dPixelShader);
+		
+		X432R_CALL_D3D_RELEASE(d3dRenderTarget);
+		X432R_CALL_D3D_RELEASE( d3dRenderTarget_OffscreenTexture[0] );
+		X432R_CALL_D3D_RELEASE( d3dRenderTarget_OffscreenTexture[1] );
+		X432R_CALL_D3D_RELEASE( d3dTexture_OffscreenBuffer[0] );
+		X432R_CALL_D3D_RELEASE( d3dTexture_OffscreenBuffer[1] );
+		
+		X432R_CALL_D3D_RELEASE(d3dTexture_Screen);
+		X432R_CALL_D3D_RELEASE(d3dTexture_Hud);
+		
+		X432R_CALL_D3D_RELEASE(d3dDevice);
+		d3dDeviceStatus = D3DERR_DEVICELOST;
+		
+		if( !release_all ) return;
+		
+		X432R_CALL_D3D_RELEASE(direct3d);
+		
+		d3dShaderModel3Supported = false;
+	}
+	
+	void D3D_DisplayMethod::Init(const u32 texture_width, const u32 texture_height, const u32 viewport_width, const u32 viewport_height)
+	{
+		assert( (texture_width >= 256) && ( texture_width <= (256 * 5) ) && ( texture_height >= (192 * 2) ) && ( texture_height <= (192 * 2 * 5) ) );
+		
+		
+		Deinit(false);
+		
+		if( (MainWindow == NULL) || (viewport_width == 0) || (viewport_height == 0) ) return;
+		
+		const HWND window_handle = MainWindow->getHWnd();
+		HRESULT result;
+		
+		
+		try
+		{
+			if(direct3d == NULL)
+			{
+				direct3d = Direct3DCreate9(D3D_SDK_VERSION);
+				
+				if(direct3d == NULL) throw std::runtime_error("D3D9 Device Initializing failed.");
+			}
+			
+			
+			// device
+			D3DPRESENT_PARAMETERS d3d_params = {0};
+			d3d_params.BackBufferFormat = D3DFMT_UNKNOWN;
+			d3d_params.BackBufferCount = 1;
+			d3d_params.BackBufferWidth = viewport_width;
+			d3d_params.BackBufferHeight = viewport_height;
+			d3d_params.SwapEffect = D3DSWAPEFFECT_DISCARD;
+			d3d_params.hDeviceWindow = window_handle;
+			d3d_params.Windowed = TRUE;
+			d3d_params.PresentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE;
+			d3d_params.MultiSampleType = D3DMULTISAMPLE_NONE;
+			
+//			result = direct3d->CreateDevice(D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, window_handle, D3DCREATE_MIXED_VERTEXPROCESSING, &d3d_params, &d3dDevice);
+			result = direct3d->CreateDevice(D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, window_handle, D3DCREATE_MIXED_VERTEXPROCESSING | D3DCREATE_MULTITHREADED, &d3d_params, &d3dDevice);
+			
+			if( FAILED(result) ) throw std::runtime_error("D3D9 Device initializing failed.");
+			
+			
+/*			// viewport
+//			const D3DVIEWPORT9 viewport = {0, 0, client_width, client_height, 1.0, 0.0};
+			const D3DVIEWPORT9 viewport = {0, 0, client_width, client_height, 0.0, 0.0};
+			
+			result = d3dDevice->SetViewport(&viewport);
+			
+			if( FAILED(result) ) throw std::runtime_error("D3D9 Viewport settings failed.");
+*/			
+			
+			// 環境チェック
+			D3DCAPS9 device_caps;
+			d3dDevice->GetDeviceCaps(&device_caps);
+			
+//			d3dShaderModel3Supported = ( device_caps.VertexShaderVersion >= D3DVS_VERSION(3, 0) ) && ( device_caps.PixelShaderVersion >= D3DVS_VERSION(3, 0) );
+			d3dShaderModel3Supported = ( device_caps.PixelShaderVersion >= D3DVS_VERSION(3, 0) );
+			
+/*			const u32 max_width = device_caps.MaxTextureWidth;
+			const u32 max_height = device_caps.MaxTextureHeight;
+			
+			INFO("Direct3D max texture size: %dx%d\n", max_width, max_height);
+			
+			if( (max_width < texture_width) || (max_height < texture_height) ) throw std::runtime_error("D3D9 Texture creation failed.");
+*/			
+			
+			// texture
+			result = d3dDevice->CreateTexture(texture_width, texture_height, 0, D3DUSAGE_DYNAMIC, D3DFMT_A8R8G8B8, D3DPOOL_DEFAULT, &d3dTexture_Screen, NULL);
+			
+			if( FAILED(result) ) throw std::runtime_error("D3D9 Texture creation failed.");
+			
+			result = d3dDevice->CreateTexture(256, 192 * 2, 0, D3DUSAGE_DYNAMIC, D3DFMT_A8R8G8B8, D3DPOOL_DEFAULT, &d3dTexture_Hud, NULL);
+			
+			if( FAILED(result) ) throw std::runtime_error("D3D9 Texture creation failed.");
+			
+			for(u32 i = 0; i < 2; ++i)
+			{
+				result = d3dDevice->CreateTexture(texture_width, texture_height, 0, D3DUSAGE_RENDERTARGET, D3DFMT_A8R8G8B8, D3DPOOL_DEFAULT, &d3dTexture_OffscreenBuffer[i], NULL);
+				
+				if( FAILED(result) ) throw std::runtime_error("D3D9 Texture creation failed.");
+				
+				result = d3dTexture_OffscreenBuffer[i]->GetSurfaceLevel( 0, &d3dRenderTarget_OffscreenTexture[i] );
+				
+				if( FAILED(result) ) throw std::runtime_error("D3D9 Offscreen-Buffer initializing failed.");
+			}
+			
+			result = d3dDevice->GetRenderTarget(0, &d3dRenderTarget);
+			
+			if( FAILED(result) ) throw std::runtime_error("D3D9 RenderTarget initializing failed.");
+			
+			
+			// shader
+//			LoadSelectedShader();
+			d3dShaderSettingsChanged = true;
+			
+			
+			// レンダリング設定
+			IDirect3DVertexDeclaration9 *vertex_declaration = NULL;
+			d3dDevice->CreateVertexDeclaration(D3D_VertexElements, &vertex_declaration);
+			d3dDevice->SetVertexDeclaration(vertex_declaration);
+			X432R_CALL_D3D_RELEASE(vertex_declaration);
+			
+			d3dDevice->SetRenderState(D3DRS_CULLMODE, D3DCULL_NONE);
+			d3dDevice->SetRenderState(D3DRS_ZENABLE, FALSE);
+			d3dDevice->SetRenderState(D3DRS_STENCILENABLE, FALSE);
+			d3dDevice->SetRenderState(D3DRS_LIGHTING, FALSE);
+			
+			d3dDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);
+			d3dDevice->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);
+			d3dDevice->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);
+			
+//			d3dDevice->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);
+//			d3dDevice->SetTextureStageState(0, D3DTSS_COLORARG2, D3DTA_DIFFUSE);
+			d3dDevice->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
+//			d3dDevice->SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);
+//			d3dDevice->SetTextureStageState(0, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE);
+			d3dDevice->SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);
+			
+			d3dDevice->SetSamplerState(0, D3DSAMP_ADDRESSU, D3DTADDRESS_CLAMP);
+			d3dDevice->SetSamplerState(0, D3DSAMP_ADDRESSV, D3DTADDRESS_CLAMP);
+			d3dDevice->SetSamplerState(0, D3DSAMP_MAGFILTER, D3DTEXF_POINT);
+			d3dDevice->SetSamplerState(0, D3DSAMP_MINFILTER, D3DTEXF_POINT);
+			
+			d3dDevice->SetSamplerState(1, D3DSAMP_ADDRESSU, D3DTADDRESS_CLAMP);
+			d3dDevice->SetSamplerState(1, D3DSAMP_ADDRESSV, D3DTADDRESS_CLAMP);
+			d3dDevice->SetSamplerState(1, D3DSAMP_MAGFILTER, D3DTEXF_LINEAR);
+			d3dDevice->SetSamplerState(1, D3DSAMP_MINFILTER, D3DTEXF_LINEAR);
+			
+			
+			currentTextureWidth = texture_width;
+			currentTextureHeight = texture_height;
+			currentViewportWidth = viewport_width;
+			currentViewportHeight = viewport_height;
+			
+			
+			// 初期化完了
+			INFO("Direct3D DisplayMethod initialized.\n");
+		}
+		catch(std::runtime_error exception)
+		{
+			// 初期化失敗
+			Deinit(true);
+			
+			osd->addLine("Direct3D DisplayMethod failed");
+//			INFO("Direct3D DisplayMethod failed.\n");
+			INFO( exception.what() );
+			INFO("\n");
+			
+//			Lock lock(win_backbuffer_sync);
+			SetStyle( ( GetStyle()&~DWS_DISPMETHODS ) | DWS_DDRAW_SW );
+			WritePrivateProfileInt("Video", "Display Method", DISPMETHOD_DDRAW_SW, IniName);
+			ddraw.createSurfaces(window_handle);
+		}
+	}
+	
+	
+	template <u32 RENDER_MAGNIFICATION>
+	bool D3D_DisplayMethod::UpdateTexture(const u32 * const sourcebuffer_begin, const bool * const is_highreso)
+	{
+//		X432R_STATIC_RENDER_MAGNIFICATION_CHECK();
+		static_assert( (RENDER_MAGNIFICATION >= 1) && (RENDER_MAGNIFICATION <= 5), "X432R: invalid rendering magnification" );
+		assert( (sourcebuffer_begin != NULL) && (is_highreso != NULL) );
+		
+		if(d3dTexture_Screen == NULL) return false;
+		
+		D3DLOCKED_RECT locked_rect;
+		
+//		const HRESULT result = d3dTexture_Screen->LockRect(0, &locked_rect, NULL, D3DLOCK_DISCARD);
+		const HRESULT result = d3dTexture_Screen->LockRect(0, &locked_rect, NULL, D3DLOCK_DISCARD | D3DLOCK_NO_DIRTY_UPDATE);
+//		const HRESULT result = d3dTexture_Screen->LockRect(0, &locked_rect, NULL, D3DLOCK_DISCARD | D3DLOCK_NO_DIRTY_UPDATE | D3DLOCK_NOSYSLOCK);
+//		const HRESULT result = d3dTexture_Screen->LockRect(0, &locked_rect, NULL, D3DLOCK_DISCARD | D3DLOCK_DONOTWAIT | D3DLOCK_NO_DIRTY_UPDATE | D3DLOCK_NOSYSLOCK);
+		
+		if( FAILED(result) || (locked_rect.pBits == NULL) ) return false;
+		
+		const u32 destbuffer_linepitch = locked_rect.Pitch / sizeof(u32);
+		u32 * const destbuffer_begin = (u32 *)locked_rect.pBits;
+		
+		const u32 *source_buffer;
+		u32 *dest_buffer;
+		
+		for(u32 screen_index = 0; screen_index < 2; ++screen_index)
+		{
+			const u32 y_offset = screen_index * 192 * RENDER_MAGNIFICATION;
+			const u32 * const sourcebuffer_begin2 = sourcebuffer_begin + (y_offset * 256 * RENDER_MAGNIFICATION);
+			u32 * const destbuffer_begin2 = destbuffer_begin + (y_offset * destbuffer_linepitch);
+			
+			if( !is_highreso[screen_index] )
+			{
+				// post-processing shaderのためにテクスチャを拡大しておく
+				u32 x, y;
+				
+				for( y = 0; y < (192 * RENDER_MAGNIFICATION); ++y )
+				{
+					source_buffer = sourcebuffer_begin2 + ( (y / RENDER_MAGNIFICATION) * 256 );
+					dest_buffer = destbuffer_begin2 + (y * destbuffer_linepitch);
+					
+					for( x = 0; x < (256 * RENDER_MAGNIFICATION); ++x, ++dest_buffer )
+					{
+						*dest_buffer = *source_buffer;
+						
+						if( (x % RENDER_MAGNIFICATION) == (RENDER_MAGNIFICATION - 1) )
+							++source_buffer;
+					}
+				}
+			}
+			else if( destbuffer_linepitch == (256 * RENDER_MAGNIFICATION) )
+				memcpy( destbuffer_begin2, sourcebuffer_begin2, sizeof(u32) * 256 * 192 * RENDER_MAGNIFICATION * RENDER_MAGNIFICATION );
+			else
+			{
+				u32 x, y;
+				
+				source_buffer = sourcebuffer_begin2;
+				
+				for( y = 0; y < (192 * RENDER_MAGNIFICATION); ++y )
+				{
+					dest_buffer = destbuffer_begin2 + (y * destbuffer_linepitch);
+					
+					for( x = 0; x < (256 * RENDER_MAGNIFICATION); ++x, ++source_buffer, ++dest_buffer )
+					{
+						*dest_buffer = *source_buffer;
+					}
+				}
+			}
+		}
+		
+		d3dTexture_Screen->UnlockRect(0);
+		
+		return true;
+	}
+	
+	template <u32 RENDER_MAGNIFICATION>
+	bool D3D_DisplayMethod::UpdateTexture_fromNativeScreenBuffer()
+	{
+		static_assert( (RENDER_MAGNIFICATION >= 1) && (RENDER_MAGNIFICATION <= 5), "X432R: invalid rendering magnification" );
+		
+		if(d3dTexture_Screen == NULL) return false;
+		
+		D3DLOCKED_RECT locked_rect;
+		
+//		const HRESULT result = d3dTexture_Screen->LockRect(0, &locked_rect, NULL, D3DLOCK_DISCARD);
+		const HRESULT result = d3dTexture_Screen->LockRect(0, &locked_rect, NULL, D3DLOCK_DISCARD | D3DLOCK_NO_DIRTY_UPDATE);
+//		const HRESULT result = d3dTexture_Screen->LockRect(0, &locked_rect, NULL, D3DLOCK_DISCARD | D3DLOCK_NO_DIRTY_UPDATE | D3DLOCK_NOSYSLOCK);
+//		const HRESULT result = d3dTexture_Screen->LockRect(0, &locked_rect, NULL, D3DLOCK_DISCARD | D3DLOCK_DONOTWAIT | D3DLOCK_NO_DIRTY_UPDATE | D3DLOCK_NOSYSLOCK);
+		
+		if( FAILED(result) || (locked_rect.pBits == NULL) ) return false;
+		
+		const u32 destbuffer_linepitch = locked_rect.Pitch / sizeof(u32);
+		u32 * const destbuffer_begin = (u32 *)locked_rect.pBits;
+		
+		const u32 *source_buffer = (u32 *)video.finalBuffer();
+		
+		if( destbuffer_linepitch == (256 * RENDER_MAGNIFICATION) )
+			memcpy( destbuffer_begin, source_buffer, sizeof(u32) * 256 * 192 * 2 * RENDER_MAGNIFICATION * RENDER_MAGNIFICATION );
+		else
+		{
+			u32 *dest_buffer;
+			u32 x, y;
+			
+			for( y = 0; y < (192 * 2 * RENDER_MAGNIFICATION); ++y )
+			{
+				dest_buffer = destbuffer_begin + (y * destbuffer_linepitch);
+					
+				for( x = 0; x < (256 * RENDER_MAGNIFICATION); ++x, ++source_buffer, ++dest_buffer )
+				{
+					*dest_buffer = *source_buffer;
+				}
+			}
+		}
+		
+		d3dTexture_Screen->UnlockRect(0);
+		
+		return true;
+	}
+	
+	void D3D_DisplayMethod::UpdateTexture_Hud()
+	{
+		if(d3dTexture_Hud == NULL) return;
+		
+		
+		D3DLOCKED_RECT locked_rect;
+		
+//		const HRESULT result = d3dTexture_Hud->LockRect(0, &locked_rect, NULL, D3DLOCK_DISCARD);
+		const HRESULT result = d3dTexture_Hud->LockRect(0, &locked_rect, NULL, D3DLOCK_DISCARD | D3DLOCK_NO_DIRTY_UPDATE);
+//		const HRESULT result = d3dTexture_Hud->LockRect(0, &locked_rect, NULL, D3DLOCK_DISCARD | D3DLOCK_NO_DIRTY_UPDATE | D3DLOCK_NOSYSLOCK);
+//		const HRESULT result = d3dTexture_Hud->LockRect(0, &locked_rect, NULL, D3DLOCK_DISCARD | D3DLOCK_DONOTWAIT | D3DLOCK_NO_DIRTY_UPDATE | D3DLOCK_NOSYSLOCK);
+		
+		if( FAILED(result) || (locked_rect.pBits == NULL) ) return;
+		
+		u32 * const destbuffer_begin = (u32 *)locked_rect.pBits;
+		const u32 destbuffer_linepitch = locked_rect.Pitch / sizeof(u32);
+		
+		const u32 *source_buffer = hudBuffer;
+		
+		if(destbuffer_linepitch == 256)
+			memcpy( destbuffer_begin, source_buffer, sizeof(u32) * 256 * 192 * 2 );
+		else
+		{
+			u32 *dest_buffer;
+			u32 x, y;
+			
+			for( y = 0; y < (192 * 2); ++y )
+			{
+				dest_buffer = destbuffer_begin + (y * destbuffer_linepitch);
+				
+				for(x = 0; x < 256; ++x, ++source_buffer, ++dest_buffer)
+				{
+					*dest_buffer = *source_buffer;
+				}
+			}
+		}
+		
+		d3dTexture_Hud->UnlockRect(0);
+	}
+	
+	
+	template <u32 RENDER_MAGNIFICATION>
+	void D3D_DisplayMethod::DoDisplay(const bool highresorenderer_selected)
+	{
+//		X432R_STATIC_RENDER_MAGNIFICATION_CHECK();
+		static_assert( (RENDER_MAGNIFICATION >= 1) && (RENDER_MAGNIFICATION <= 5), "X432R: invalid rendering magnification" );
+		
+		
+		static const float TEXTURE_WIDTH = 256 * RENDER_MAGNIFICATION;
+		static const float TEXTURE_HEIGHT = 192 * 2 * RENDER_MAGNIFICATION;
+		
+		
+		#ifdef X432R_PROCESSTIME_CHECK
+		AutoStopTimeCounter timecounter(timeCounter_Display);
+		#endif
+		
+		
+		// ウインドウサイズをチェック
+		const HWND window_handle = MainWindow->getHWnd();
+		
+		RECT client_rect;
+		GetClientRect(window_handle, &client_rect);
+		
+		const u32 viewport_width = client_rect.right;
+		const u32 viewport_height = client_rect.bottom;
+		
+		
+		if( (d3dDeviceStatus == D3D_OK) && ( (viewport_width != currentViewportWidth) || (viewport_height != currentViewportHeight) || (TEXTURE_WIDTH != currentTextureWidth) || (TEXTURE_HEIGHT != currentTextureHeight) ) )
+			d3dDeviceStatus = D3DERR_DEVICENOTRESET;
+		
+		if( (d3dDevice == NULL) || (d3dTexture_Screen == NULL) || (d3dTexture_Hud == NULL) || (d3dDeviceStatus != D3D_OK) )
+			Init(TEXTURE_WIDTH, TEXTURE_HEIGHT, viewport_width, viewport_height);					// displayThreadからのみ使用する
+		
+		if( (d3dDevice == NULL) || (d3dTexture_Screen == NULL) || (d3dTexture_Hud == NULL) ) return;
+		
+		d3dDeviceStatus = d3dDevice->TestCooperativeLevel();
+		
+		if(d3dDeviceStatus != D3D_OK) return;
+		
+		if(d3dShaderSettingsChanged)
+		{
+			LoadSelectedShader();					// displayThreadからのみ使用する
+			d3dShaderSettingsChanged = false;
+		}
+		
+		
+		// テクスチャ更新
+		static u32 master_brightness[2] = {0, 0};
+		bool skip_postprocess = screenTextureUpdated;
+		
+		if( !screenTextureUpdated )
+		{
+			#ifdef X432R_PROCESSTIME_CHECK
+			timeCounter_LockDisp.Start();
+			#endif
+			
+			Lock_forHighResolutionFrontBuffer();
+			
+			#ifdef X432R_PROCESSTIME_CHECK
+			timeCounter_LockDisp.Stop();
+			#endif
+			
+			const u8 buffer_index = CommonSettings.single_core() ? 0 : clamp(currDisplayBuffer, 0, 2);
+			
+			Unlock_forHighResolutionFrontBuffer();
+			
+			if( (RENDER_MAGNIFICATION == 1) || !highresorenderer_selected )
+			{
+				screenTextureUpdated = UpdateTexture_fromNativeScreenBuffer<RENDER_MAGNIFICATION>();
+				
+				if( !screenTextureUpdated )
+					skip_postprocess = true;
+				
+				master_brightness[0] = 0;
+				master_brightness[1] = 0;
+			}
+			else
+			{
+				const u32 * const front_buffer = frontBuffer[buffer_index];
+				const bool * const is_highreso_screen = isHighResolutionScreen[buffer_index];
+				
+				screenTextureUpdated = UpdateTexture<RENDER_MAGNIFICATION>(front_buffer, is_highreso_screen);
+				
+				if( !screenTextureUpdated )
+					skip_postprocess = true;
+				else
+				{
+					master_brightness[0] = is_highreso_screen[0] ? masterBrightness[buffer_index][0] : 0;
+					master_brightness[1] = is_highreso_screen[1] ? masterBrightness[buffer_index][1] : 0;
+				}
+			}
+		}
+		
+		
+		// テクスチャ・ポリゴン座標生成
+		static const float default_texcoord[2][8] =
+		{
+			{
+				0.0f,		0.0f,		// left-top
+				1.0f,		0.0f,		// right-top
+				1.0f,		0.5f,		// right-bottom
+				0.0f,		0.5f		// left-bottom
+			},
+			{
+				0.0f,		0.5f,
+				1.0f,		0.5f,
+				1.0f,		1.0f,
+				0.0f,		1.0f
+			}
+		};
+		
+		float texcoord[2][8];
+		float texcoord_hud[2][8];
+		
+		#ifndef X432R_CUSTOMSCREENSCALING_ENABLED
+		bool screen_swap = false;
+		bool hud_swap = false;
+		u32 texture_index_offset = 0;
+		
+		switch(video.swap)
+		{
+			case 1:		screen_swap = true;							break;
+			case 2:		screen_swap = (MainScreen.offset > 0);		break;
+			case 3:		screen_swap = (SubScreen.offset > 0);		break;
+		}
+		
+		hud_swap = screen_swap;
+		#else
+		const bool screen_swap = (video.swap == 1);
+		u32 texture_index_offset = 0;
+		#endif
+		
+		RECT screen_rect[] = {MainScreenRect, SubScreenRect};
+		
+		for(u32 i = 0; i < 2; ++i)
+		{
+			ScreenToClient( window_handle, (LPPOINT)&screen_rect[i].left );
+			ScreenToClient( window_handle, (LPPOINT)&screen_rect[i].right );
+		}
+		
+//		u32 polygon_width = screen_rect[0].right - screen_rect[0].left;
+//		u32 polygon_height = screen_rect[0].bottom - screen_rect[0].top;
+		const u32 rotation = (video.layout == 0) ? video.rotation : 0;
+		
+		switch(rotation)
+		{
+			case 90:
+				texture_index_offset = 6;
+				#ifndef X432R_CUSTOMSCREENSCALING_ENABLED
+				screen_swap = !screen_swap;
+				#endif
+//				std::swap(polygon_width, polygon_height);
+				break;
+				
+			case 180:
+				texture_index_offset = 4;
+				#ifndef X432R_CUSTOMSCREENSCALING_ENABLED
+				screen_swap = !screen_swap;
+				#endif
+				break;
+				
+			case 270:
+				texture_index_offset = 2;
+//				std::swap(polygon_width, polygon_height);
+				break;
+		}
+		
+//		polygon_height *= 2;
+		
+		for(u32 i = 0; i < 8; ++i)
+		{
+			u32 index = (i + texture_index_offset) % 8;
+			
+			texcoord[0][i] = default_texcoord[0][index];
+			texcoord[1][i] = default_texcoord[1][index];
+			
+			texcoord_hud[0][i] = default_texcoord[0][index];
+			texcoord_hud[1][i] = default_texcoord[1][index];
+		}
+		
+		const u32 upperscreen_index = screen_swap ? 1 : 0;
+		const u32 lowerscreen_index = screen_swap ? 0 : 1;
+		
+		const float polygon_vertices[2][8] =
+		{
+			{
+				screen_rect[upperscreen_index].left,		screen_rect[upperscreen_index].top,
+				screen_rect[upperscreen_index].right,		screen_rect[upperscreen_index].top,
+				screen_rect[upperscreen_index].right,		screen_rect[upperscreen_index].bottom,
+				screen_rect[upperscreen_index].left,		screen_rect[upperscreen_index].bottom
+			},
+			{
+				screen_rect[lowerscreen_index].left,		screen_rect[lowerscreen_index].top,
+				screen_rect[lowerscreen_index].right,		screen_rect[lowerscreen_index].top,
+				screen_rect[lowerscreen_index].right,		screen_rect[lowerscreen_index].bottom,
+				screen_rect[lowerscreen_index].left,		screen_rect[lowerscreen_index].bottom
+			}
+		};
+		
+		static const D3D_Vertex d3d_vertices_offscreen[4] =
+		{
+			{
+				-0.5f,						-0.5f,						0.0f,		// x, y, z
+				0.0f,						0.0f,									// u, v
+				0																	// diffuse
+			},
+			{
+				TEXTURE_WIDTH - 0.5f,		-0.5f,						0.0f,
+				1.0f,						0.0f,
+				0
+			},
+			{
+				-0.5f,						TEXTURE_HEIGHT - 0.5f,		0.0f,
+				0.0f,						1.0f,
+				0
+			},
+			{
+				TEXTURE_WIDTH - 0.5f,		TEXTURE_HEIGHT - 0.5f,		0.0f,
+				1.0f,						1.0f,
+				0
+			}
+		};
+		
+		const bool filter_enabled = GetStyle() & DWS_FILTER;
+		D3D_Vertex d3d_vertices[2][4] = {0};
+		D3D_Vertex d3d_vertices_brightness[2][4] = {0};
+		D3D_Vertex d3d_vertices_hud[2][4] = {0};
+		
+		for(u32 i = 0; i < 2; ++i)
+		{
+			#if 0
+			// screen
+			d3d_vertices[i][0].Set( polygon_vertices[i][0], polygon_vertices[i][1], texcoord[i][0], texcoord[i][1], 0xFFFFFFFF );
+			d3d_vertices[i][1].Set( polygon_vertices[i][2], polygon_vertices[i][3], texcoord[i][2], texcoord[i][3], 0xFFFFFFFF );
+			d3d_vertices[i][3].Set( polygon_vertices[i][4], polygon_vertices[i][5], texcoord[i][4], texcoord[i][5], 0xFFFFFFFF );
+			d3d_vertices[i][2].Set( polygon_vertices[i][6], polygon_vertices[i][7], texcoord[i][6], texcoord[i][7], 0xFFFFFFFF );
+			
+			// master brightness
+			d3d_vertices_brightness[i][0].Set( polygon_vertices[i][0], polygon_vertices[i][1], 0.0f, 0.0f, master_brightness[i] );
+			d3d_vertices_brightness[i][1].Set( polygon_vertices[i][2], polygon_vertices[i][3], 0.0f, 0.0f, master_brightness[i] );
+			d3d_vertices_brightness[i][3].Set( polygon_vertices[i][4], polygon_vertices[i][5], 0.0f, 0.0f, master_brightness[i] );
+			d3d_vertices_brightness[i][2].Set( polygon_vertices[i][6], polygon_vertices[i][7], 0.0f, 0.0f, master_brightness[i] );
+			
+			// HUD
+			d3d_vertices_hud[i][0].Set( polygon_vertices[i][0], polygon_vertices[i][1], texcoord_hud[i][0], texcoord_hud[i][1], 0xFFFFFFFF );
+			d3d_vertices_hud[i][1].Set( polygon_vertices[i][2], polygon_vertices[i][3], texcoord_hud[i][2], texcoord_hud[i][3], 0xFFFFFFFF );
+			d3d_vertices_hud[i][3].Set( polygon_vertices[i][4], polygon_vertices[i][5], texcoord_hud[i][4], texcoord_hud[i][5], 0xFFFFFFFF );
+			d3d_vertices_hud[i][2].Set( polygon_vertices[i][6], polygon_vertices[i][7], texcoord_hud[i][6], texcoord_hud[i][7], 0xFFFFFFFF );
+			#else
+			d3d_vertices[i][0].Set( polygon_vertices[i][0], polygon_vertices[i][1], texcoord[i][0], texcoord[i][1], 0xFFFFFFFF, filter_enabled );
+			d3d_vertices[i][1].Set( polygon_vertices[i][2], polygon_vertices[i][3], texcoord[i][2], texcoord[i][3], 0xFFFFFFFF, filter_enabled );
+			d3d_vertices[i][3].Set( polygon_vertices[i][4], polygon_vertices[i][5], texcoord[i][4], texcoord[i][5], 0xFFFFFFFF, filter_enabled );
+			d3d_vertices[i][2].Set( polygon_vertices[i][6], polygon_vertices[i][7], texcoord[i][6], texcoord[i][7], 0xFFFFFFFF, filter_enabled );
+			
+			// master brightness
+			d3d_vertices_brightness[i][0].Set( polygon_vertices[i][0], polygon_vertices[i][1], 0.0f, 0.0f, master_brightness[i], false );
+			d3d_vertices_brightness[i][1].Set( polygon_vertices[i][2], polygon_vertices[i][3], 0.0f, 0.0f, master_brightness[i], false );
+			d3d_vertices_brightness[i][3].Set( polygon_vertices[i][4], polygon_vertices[i][5], 0.0f, 0.0f, master_brightness[i], false );
+			d3d_vertices_brightness[i][2].Set( polygon_vertices[i][6], polygon_vertices[i][7], 0.0f, 0.0f, master_brightness[i], false );
+			
+			// HUD
+			d3d_vertices_hud[i][0].Set( polygon_vertices[i][0], polygon_vertices[i][1], texcoord_hud[i][0], texcoord_hud[i][1], 0xFFFFFFFF, false );
+			d3d_vertices_hud[i][1].Set( polygon_vertices[i][2], polygon_vertices[i][3], texcoord_hud[i][2], texcoord_hud[i][3], 0xFFFFFFFF, false );
+			d3d_vertices_hud[i][3].Set( polygon_vertices[i][4], polygon_vertices[i][5], texcoord_hud[i][4], texcoord_hud[i][5], 0xFFFFFFFF, false );
+			d3d_vertices_hud[i][2].Set( polygon_vertices[i][6], polygon_vertices[i][7], texcoord_hud[i][6], texcoord_hud[i][7], 0xFFFFFFFF, false );
+			#endif
+		}
+		
+		
+		// HUD用テクスチャ更新
+		const bool hud_visible = IsHudVisible();
+		
+		if(hud_visible)
+		{
+			#ifndef X432R_CUSTOMSCREENSCALING_ENABLED
+			osd->swapScreens = hud_swap;
+			#else
+			osd->swapScreens = screen_swap;
+			#endif
+			aggDraw.hud->attach( (u8*)hudBuffer, 256, 192 * 2, 256 * 4 );
+			aggDraw.hud->clear();
+			DoDisplay_DrawHud();
+			
+			UpdateTexture_Hud();
+		}
+		
+		
+		// 描画開始
+		const RGBA8888 clearcolor = (u32)ScreenGapColor;
+		const D3DTEXTUREFILTERTYPE texture_filter = filter_enabled ? D3DTEXF_LINEAR : D3DTEXF_POINT;
+		const bool single_screen_mode = (video.layout == 2);
+		
+		const D3DVIEWPORT9 viewport = {0, 0, viewport_width, viewport_height, 0.0, 0.0};
+		const D3DVIEWPORT9 viewport_offscreen = {0, 0, TEXTURE_WIDTH, TEXTURE_HEIGHT, 0.0, 0.0};
+		
+		HRESULT result = d3dDevice->BeginScene();
+		
+		if( FAILED(result) )
+		{
+			d3dDeviceStatus = d3dDevice->Present(NULL, NULL, NULL, NULL);
+			return;
+		}
+		
+		static u32 postprocessed_texture_index = 0;
+		
+		if( !d3dShaderProgramLoaded )
+			d3dDevice->SetTexture(0, d3dTexture_Screen);
+		
+		else if(skip_postprocess)
+			d3dDevice->SetTexture( 0, d3dTexture_OffscreenBuffer[postprocessed_texture_index] );
+		
+		else
+		{
+			// offscreen rendering
+			d3dDevice->SetPixelShader(d3dPixelShader);
+			
+			float effect_settings[] = {		RENDER_MAGNIFICATION,		d3dShaderEffectLevel,		d3dShaderEffectMode,		0.0f		};		// register c0
+			float * const loop_count = &effect_settings[3];
+			
+			d3dDevice->SetPixelShaderConstantF(0, effect_settings, 1);
+			
+			d3dDevice->SetSamplerState(0, D3DSAMP_MAGFILTER, D3DTEXF_POINT);
+			d3dDevice->SetSamplerState(0, D3DSAMP_MINFILTER, D3DTEXF_POINT);
+			
+			// initial effect
+			u32 rendertarget_index = 0;
+			u32 sourcetexture_index = 1;
+			
+			d3dDevice->SetRenderTarget( 0, d3dRenderTarget_OffscreenTexture[rendertarget_index] );
+			d3dDevice->SetViewport(&viewport_offscreen);
+//			d3dDevice->Clear(0, NULL, D3DCLEAR_TARGET, 0, 1.0f, 0);
+			
+			d3dDevice->SetTexture(0, d3dTexture_Screen);				// register s0: point filter
+			d3dDevice->SetTexture(1, d3dTexture_Screen);				// register s1: linear filter
+			
+			d3dDevice->DrawPrimitiveUP( D3DPT_TRIANGLESTRIP, 2, d3d_vertices_offscreen, sizeof(D3D_Vertex) );
+			
+			// effect loop
+			for(u32 i = 1; i <= d3dSelectedShaderMaxEffectLoop; ++i)
+			{
+				std::swap(rendertarget_index, sourcetexture_index);
+				
+				d3dDevice->SetRenderTarget( 0, d3dRenderTarget_OffscreenTexture[rendertarget_index] );
+				d3dDevice->SetViewport(&viewport_offscreen);
+//				d3dDevice->Clear(0, NULL, D3DCLEAR_TARGET, 0, 1.0f, 0);
+				
+				d3dDevice->SetTexture( 1, d3dTexture_OffscreenBuffer[sourcetexture_index] );			// register s1
+				
+				*loop_count = (float)i;
+				d3dDevice->SetPixelShaderConstantF(0, effect_settings, 1);
+				
+				d3dDevice->DrawPrimitiveUP( D3DPT_TRIANGLESTRIP, 2, d3d_vertices_offscreen, sizeof(D3D_Vertex) );
+			}
+			
+			postprocessed_texture_index = rendertarget_index;
+			
+			d3dDevice->SetTexture( 0, d3dTexture_OffscreenBuffer[rendertarget_index] );
+			d3dDevice->SetTexture(1, NULL);
+			
+			d3dDevice->SetPixelShader(NULL);
+		}
+		
+		d3dDevice->SetRenderTarget(0, d3dRenderTarget);
+		d3dDevice->SetViewport(&viewport);
+		d3dDevice->Clear( 0, NULL, D3DCLEAR_TARGET, D3DCOLOR_XRGB(clearcolor.R, clearcolor.G, clearcolor.B), 1.0f, 0 );
+		
+		// screen
+		d3dDevice->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);
+		d3dDevice->SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_DIFFUSE);
+		
+		d3dDevice->SetSamplerState(0, D3DSAMP_MAGFILTER, texture_filter);
+		d3dDevice->SetSamplerState(0, D3DSAMP_MINFILTER, texture_filter);
+		
+		if(single_screen_mode)
+			d3dDevice->DrawPrimitiveUP( D3DPT_TRIANGLESTRIP, 2, d3d_vertices[upperscreen_index], sizeof(D3D_Vertex) );
+		else
+		{
+			d3dDevice->DrawPrimitiveUP( D3DPT_TRIANGLESTRIP, 2, d3d_vertices[0], sizeof(D3D_Vertex) );
+			d3dDevice->DrawPrimitiveUP( D3DPT_TRIANGLESTRIP, 2, d3d_vertices[1], sizeof(D3D_Vertex) );
+		}
+		
+		d3dDevice->SetTexture(0, NULL);
+		
+		d3dDevice->SetSamplerState(0, D3DSAMP_MAGFILTER, D3DTEXF_POINT);
+		d3dDevice->SetSamplerState(0, D3DSAMP_MINFILTER, D3DTEXF_POINT);
+		
+		// master_brightness
+		if( master_brightness[0] || master_brightness[1] )
+		{
+			d3dDevice->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_DIFFUSE);
+			d3dDevice->SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_DIFFUSE);
+			
+			if(single_screen_mode)
+			{
+				if( master_brightness[upperscreen_index] )
+					d3dDevice->DrawPrimitiveUP( D3DPT_TRIANGLESTRIP, 2, d3d_vertices_brightness[upperscreen_index], sizeof(D3D_Vertex) );
+			}
+			else
+			{
+				if( master_brightness[0] )
+					d3dDevice->DrawPrimitiveUP( D3DPT_TRIANGLESTRIP, 2, d3d_vertices_brightness[0], sizeof(D3D_Vertex) );
+				
+				if( master_brightness[1] )
+					d3dDevice->DrawPrimitiveUP( D3DPT_TRIANGLESTRIP, 2, d3d_vertices_brightness[1], sizeof(D3D_Vertex) );
+			}
+		}
+		
+		// HUD
+		if(hud_visible)
+		{
+			d3dDevice->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);
+			d3dDevice->SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);
+			
+			d3dDevice->SetTexture(0, d3dTexture_Hud);
+			
+			if(single_screen_mode)
+				d3dDevice->DrawPrimitiveUP( D3DPT_TRIANGLESTRIP, 2, d3d_vertices_hud[upperscreen_index], sizeof(D3D_Vertex) );
+			else
+			{
+				d3dDevice->DrawPrimitiveUP( D3DPT_TRIANGLESTRIP, 2, d3d_vertices_hud[0], sizeof(D3D_Vertex) );
+				d3dDevice->DrawPrimitiveUP( D3DPT_TRIANGLESTRIP, 2, d3d_vertices_hud[1], sizeof(D3D_Vertex) );
+			}
+			
+			d3dDevice->SetTexture(0, NULL);
+		}
+		
+		d3dDevice->EndScene();
+		
+		d3dDeviceStatus = d3dDevice->Present(NULL, NULL, NULL, NULL);
+	}
+	
+	
+	void D3D_DisplayMethod::LoadSelectedShader()
+	{
+		if(d3dDevice == NULL) return;
+		
+		X432R_CALL_D3D_RELEASE(d3dPixelShader);
+		d3dShaderProgramLoaded = false;
+		
+//		if( !PathFileExists( d3dShaderDirectoryPath.c_str() ) )
+//			LoadShaderSettings();
+		
+		if(d3dSelectedShaderSlot > d3dMaxShaderSlot)
+		{
+			d3dSelectedShaderSlot = 0;
+			WritePrivateProfileInt("X432R", "D3DSelectedShaderSlot", 0, IniName);
+		}
+		
+		const D3D_ShaderFileInfo &info = d3dShaderFileInfo[d3dSelectedShaderSlot];
+		
+		BufferedBinaryFileData buffered_file;
+		
+		try
+		{
+//			d3dDevice->SetPixelShader(NULL);
+			
+			if(d3dSelectedShaderSlot == 0) return;
+			if( (d3dSelectedShaderSlot > 0) && ( info.PixelShaderFileName.length() == 0 ) ) throw std::runtime_error("D3D9 PixelShader not found.");
+			
+			// pixel shader
+			const bool load_result = buffered_file.Load(d3dShaderDirectoryPath + info.PixelShaderFileName);
+			
+			if( !load_result || (buffered_file.Buffer == NULL) ) throw std::runtime_error("D3D9 PixelShader not found.");
+			
+			const HRESULT result = d3dDevice->CreatePixelShader( (DWORD *)buffered_file.Buffer, &d3dPixelShader );
+			
+			buffered_file.Release();
+			
+			if( FAILED(result) ) throw std::runtime_error("D3D9 PixelShader creation failed.");
+			
+			// 初期化完了
+//			d3dDevice->SetPixelShader(d3dPixelShader);
+			
+			d3dShaderEffectLevel = clamp<u32>(d3dShaderEffectLevel, 0, info.MaxEffectLevel);
+			d3dShaderEffectMode = clamp<u32>(d3dShaderEffectMode, 0, info.MaxEffectMode);
+			d3dSelectedShaderMaxEffectLevel = info.MaxEffectLevel;
+			d3dSelectedShaderMaxEffectMode = info.MaxEffectMode;
+			d3dSelectedShaderMaxEffectLoop = info.MaxEffectLoop;
+			d3dShaderProgramLoaded = true;
+		}
+		catch(std::runtime_error exception)
+		{
+			buffered_file.Release();
+			
+//			INFO("Direct3D Shader loading failed.\n");
+			INFO( exception.what() );
+			INFO("\n");
+			
+			// 初期化失敗 or シェーダOFF
+//			d3dDevice->SetPixelShader(NULL);
+			X432R_CALL_D3D_RELEASE(d3dPixelShader);
+			
+			d3dSelectedShaderSlot = 0;
+//			d3dSelectedShaderMaxEffectLevel = 0;
+//			d3dSelectedShaderMaxEffectMode = 0;
+//			d3dShaderEffectLevel = 0;
+//			d3dShaderEffectMode = 0;
+			d3dSelectedShaderMaxEffectLoop = 0;
+			d3dShaderProgramLoaded = false;
+			
+			WritePrivateProfileInt("X432R", "D3DSelectedShaderSlot", 0, IniName);
+		}
+	}
+	
+	void D3D_DisplayMethod::UpdateShaderMenuItems(const bool init_items)
+	{
+		bool shader_enabled = ( GetStyle() & DWS_OPENGL );
+		
+		u32 menuitem_id;
+		u32 i;
+		
+		if(init_items)
+		{
+			std::string shader_name;
+			char buffer[512] = {0};
+			
+			MENUITEMINFO menuitem_info = {0};
+			menuitem_info.cbSize = sizeof(MENUITEMINFO);
+			menuitem_info.fMask = MIIM_STRING;
+			menuitem_info.dwTypeData = buffer;
+			
+			for(u32 i = 1; i <= d3dMaxShaderSlot; ++i)					// slot 0: default shader (effect off)
+			{
+				menuitem_id = X432R_MENUITEM_D3D_SHADER_DISABLED + i;
+				shader_name = d3dShaderFileInfo[i].Name;
+				
+				if( shader_name.length() == 0 )
+					shader_name = "Slot " + std::to_string(i); 
+				
+				strncpy( buffer, shader_name.c_str(), 512 );
+				
+				menuitem_info.cch = shader_name.length();
+				SetMenuItemInfo(mainMenu, menuitem_id, FALSE, &menuitem_info);
+				DesEnableMenuItem(mainMenu, menuitem_id, d3dShaderFileInfo[i].Exists() );
+			}
+			
+			DrawMenuBar( MainWindow->getHWnd() );
+		}
+		
+		MainWindow->checkMenu( X432R_MENUITEM_D3D_SHADER_DISABLED, (d3dSelectedShaderSlot == 0) );
+		DesEnableMenuItem(mainMenu, X432R_MENUITEM_D3D_SHADER_DISABLED, shader_enabled);
+		DesEnableMenuItem(mainMenu, X432R_MENUITEM_D3D_RELOADSHADER, shader_enabled);
+		
+		for(i = 1; i <= d3dMaxShaderSlot; ++i)
+		{
+			menuitem_id = X432R_MENUITEM_D3D_SHADER_DISABLED + i;
+			
+			MainWindow->checkMenu( menuitem_id, (i == d3dSelectedShaderSlot) );
+			DesEnableMenuItem( mainMenu, menuitem_id, shader_enabled && d3dShaderFileInfo[i].Exists() );
+		}
+		
+		shader_enabled = shader_enabled && (d3dSelectedShaderSlot > 0);
+		
+		for(i = 0; i <= d3dMaxShaderEffectLevel; ++i)
+		{
+			menuitem_id = X432R_MENUITEM_D3D_SHADEREFFECT_LEVEL1 + i;
+			MainWindow->checkMenu( menuitem_id, (i == d3dShaderEffectLevel) );
+			DesEnableMenuItem(mainMenu, menuitem_id, shader_enabled && (i <= d3dSelectedShaderMaxEffectLevel) );
+		}
+			
+		for(i = 0; i <= d3dMaxShaderEffectMode; ++i)
+		{
+			menuitem_id = X432R_MENUITEM_D3D_SHADEREFFECT_MODE1 + i;
+			MainWindow->checkMenu( menuitem_id, (i == d3dShaderEffectMode) );
+			DesEnableMenuItem(mainMenu, menuitem_id, shader_enabled && (i <= d3dSelectedShaderMaxEffectMode) );
+		}
+	}
+	
+	void D3D_DisplayMethod::LoadShaderSettings()
+	{
+		if( !PathFileExists( d3dShaderDirectoryPath.c_str() ) || !PathFileExists( d3dShaderSettingsFilePath.c_str() ) )
+		{
+			char buffer_fullpath[MAX_PATH] = {0};
+			char buffer_driveletter[MAX_PATH] = {0};
+			char buffer_directorypath[MAX_PATH] = {0};
+			
+			GetModuleFileName( NULL, buffer_directorypath, sizeof(buffer_directorypath) );					// exeのフルパスを取得
+			GetFullPathName( buffer_directorypath, sizeof(buffer_fullpath), buffer_fullpath, NULL );		// 相対パスが含まれる可能性があるため絶対パスに変換
+			_splitpath(buffer_fullpath, buffer_driveletter, buffer_directorypath, NULL, NULL);				// パスを分割してexeファイル名(拡張子なし)を取得
+			
+			d3dShaderDirectoryPath = (std::string)buffer_driveletter + (std::string)buffer_directorypath + "D3D9_Shaders\\";
+			d3dShaderSettingsFilePath = d3dShaderDirectoryPath + "D3D9_Shaders.ini";
+		}
+		
+		const bool settingsfile_is_invalid = !PathFileExists( d3dShaderSettingsFilePath.c_str() );
+		
+		D3D_ShaderFileInfo *info;
+		std::string ini_section;
+		char buffer[512];
+		bool exists_directory_delimiter;
+		
+		for(u32 i = 1; i <= d3dMaxShaderSlot; ++i)
+		{
+			info = d3dShaderFileInfo + i;
+			
+			info->Clear();
+			
+			if(settingsfile_is_invalid) continue;
+			
+			ini_section = "Slot" + std::to_string(i);
+			
+			// name
+			GetPrivateProfileString( ini_section.c_str(), "Name", "", buffer, 512, d3dShaderSettingsFilePath.c_str() );
+			info->Name = (std::string)buffer;
+			
+			// pixel shader
+			GetPrivateProfileString( ini_section.c_str(), "PixelShader", "", buffer, 512, d3dShaderSettingsFilePath.c_str() );
+			exists_directory_delimiter = ( _mbschr( (unsigned char *)buffer, '\\' ) != NULL ) || ( _mbschr( (unsigned char *)buffer, '/' ) != NULL );
+			info->PixelShaderFileName = exists_directory_delimiter ? "" : (std::string)buffer;
+			
+			// shader options
+			info->MaxEffectLevel = clamp<s32>( GetPrivateProfileInt( ini_section.c_str(), "MaxEffectLevel", 0, d3dShaderSettingsFilePath.c_str() ) - 1, 0, d3dMaxShaderEffectLevel );
+			info->MaxEffectMode = clamp<s32>( GetPrivateProfileInt( ini_section.c_str(), "MaxEffectMode", 0, d3dShaderSettingsFilePath.c_str() ) - 1, 0, d3dMaxShaderEffectMode );
+			info->MaxEffectLoop = clamp<s32>( GetPrivateProfileInt( ini_section.c_str(), "MaxEffectLoop", 0, d3dShaderSettingsFilePath.c_str() ), 0, d3dMaxShaderEffectLoop );
+		}
+		
+		UpdateShaderMenuItems(true);
+		
+		d3dShaderSettingsChanged = true;
+	}
+	
+	#undef X432R_CALL_D3D_RELEASE
+	
+	#endif
+	
+	
+	template <u32 RENDER_MAGNIFICATION>
+	static void DoDisplay()
+	{
+		X432R_STATIC_RENDER_MAGNIFICATION_CHECK();
+		
+		
+		if(screenTextureUpdated)
+		{
+			if( displayPostponeType && !displayNoPostponeNext && ( displayPostponeType < 0 || ( timeGetTime() < displayPostponeUntil ) ) ) return;
+			
+			displayNoPostponeNext = false;
+		}
+		
+		
+		if( AnyLuaActive() )
+		{
+			if( g_thread_self() == display_thread )
+				InvokeOnMainThread( ( void(*)(DWORD) )CallRegisteredLuaFunctions, LUACALL_AFTEREMULATIONGUI );
+			
+			else
+				CallRegisteredLuaFunctions(LUACALL_AFTEREMULATIONGUI);
+		}
+		
+		
+		const HWND window_handle = MainWindow->getHWnd();
+		const u32 window_style = GetStyle();
+		
+		#ifndef X432R_D3D_DISPLAYMETHOD_ENABLED
+		if( (window_style & DWS_DDRAW_HW) || (window_style & DWS_DDRAW_SW) )
+		{
+			DeleteScreenTexture();
+			gldisplay.kill();
+			
+			DD_DoDisplay<RENDER_MAGNIFICATION>();
+			return;
+		}
+		else
+			OGL_DoDisplay(RENDER_MAGNIFICATION);
+		#else
+		if(window_style & DWS_OPENGL)
+			d3dDisplayMethod.DoDisplay<RENDER_MAGNIFICATION>(true);
+		else
+		{
+			X432R::d3dDisplayMethod.Deinit(true);					// displayThreadからのみ使用する
+			
+			DD_DoDisplay<RENDER_MAGNIFICATION>();
+		}
+		#endif
+	}
+}
+#endif
+
+
 //does a single display work unit. only to be used from the display thread
 static void DoDisplay(bool firstTime)
 {
 	Lock lock (win_backbuffer_sync);
 
+	#ifdef X432R_CUSTOMRENDERER_ENABLED
+	const u32 render_magnification = X432R::GetCurrentRenderMagnification();
+	
+	switch(render_magnification)
+	{
+		case 2:
+			X432R::DoDisplay<2>();
+			return;
+		
+		case 3:
+			X432R::DoDisplay<3>();
+			return;
+		
+		case 4:
+			X432R::DoDisplay<4>();
+			return;
+	}
+	#endif
+	
+	#ifdef X432R_D3D_DISPLAYMETHOD_ENABLED
+	const bool d3d_displaymethod = GetStyle() & DWS_OPENGL;
+	
+	if(d3d_displaymethod)
+	{
+		switch(video.currentfilter)
+		{
+			case video.EPX1POINT5:
+				video.setfilter(video.EPX);
+				FilterUpdate( MainWindow->getHWnd() );
+				break;
+			
+			case video.EPXPLUS1POINT5:
+				video.setfilter(video.EPXPLUS);
+				FilterUpdate( MainWindow->getHWnd() );
+				break;
+			
+			case video.NEAREST1POINT5:
+			case video.NEARESTPLUS1POINT5:
+				video.setfilter(video.NEAREST2X);
+				FilterUpdate( MainWindow->getHWnd() );
+				break;
+		}
+	}
+	#endif
+
 	if(displayPostponeType && !displayNoPostponeNext && (displayPostponeType < 0 || timeGetTime() < displayPostponeUntil))
 		return;
 	displayNoPostponeNext = false;
@@ -1926,6 +5484,15 @@
 	//apply user's filter
 	video.filter();
 
+	#ifndef X432R_D3D_DISPLAYMETHOD_ENABLED
+	#ifdef X432R_CUSTOMRENDERER_ENABLED
+	if(X432R::lastRenderMagnification != 1)
+	{
+		X432R::lastRenderMagnification = 1;
+		X432R::screenTextureUpdated = false;
+	}
+	#endif
+	
 	if(!CommonSettings.single_core())
 	{
 		//draw and composite the OSD (but not if we are drawing osd straight to screen)
@@ -1937,6 +5504,7 @@
 	
 	bool hw = (GetStyle()&DWS_DDRAW_HW)!=0;
 	bool sw = (GetStyle()&DWS_DDRAW_SW)!=0;
+	
 	if(hw || sw)
 	{
 		gldisplay.kill();
@@ -1947,6 +5515,52 @@
 		//other cases..?
 		OGL_DoDisplay();
 	}
+	#else
+	if(d3d_displaymethod)
+	{
+		if(firstTime)
+			X432R::screenTextureUpdated = false;
+		
+		switch(video.currentfilter)
+		{
+			case video.NONE:
+				X432R::d3dDisplayMethod.DoDisplay<1>(false);
+				break;
+			
+			case video._5XBRZ:
+				X432R::d3dDisplayMethod.DoDisplay<5>(false);
+				break;
+			
+			case video.HQ4X:
+			case video._4XBRZ:
+				X432R::d3dDisplayMethod.DoDisplay<4>(false);
+				break;
+			
+			case video._3XBRZ:
+				X432R::d3dDisplayMethod.DoDisplay<3>(false);
+				break;
+			
+			default:		// x2
+				X432R::d3dDisplayMethod.DoDisplay<2>(false);
+				break;
+		}
+	}
+	else
+	{
+		X432R::d3dDisplayMethod.Deinit(true);
+		
+		if(!CommonSettings.single_core())
+		{
+			//draw and composite the OSD (but not if we are drawing osd straight to screen)
+			DoDisplay_DrawHud();
+			T_AGG_RGBA target((u8*)video.finalBuffer(), video.width,video.height,video.width*4);
+			target.transformImage(aggDraw.hud->image<T_AGG_PF_RGBA>(), 0,0,video.width,video.height);
+			aggDraw.hud->clear();
+		}
+		
+		DD_DoDisplay();
+	}
+	#endif
 }
 
 void displayProc()
@@ -1977,7 +5591,34 @@
 void displayThread(void*)
 {
 	for(;;) {
+		#if !defined(X432R_CUSTOMRENDERER_ENABLED) || defined(X432R_D3D_DISPLAYMETHOD_ENABLED)
 		if(display_die) return;
+		#else
+		if(display_die)
+		{
+			X432R::DeleteScreenTexture();
+			gldisplay.kill();
+			return;
+		}
+		#endif
+		
+		#if defined(X432R_CUSTOMRENDERER_ENABLED) || defined(X432R_MENUITEMMOD_ENABLED)
+		if( (MainWindow == NULL) || IsMinimized( MainWindow->getHWnd() ) )
+		{
+			Sleep(200);
+			continue;
+		}
+		#endif
+		
+		#ifdef X432R_MENUITEMMOD_ENABLED
+		if( X432R::cpuPowerSavingEnabled && ( emu_paused || !execute || !romloaded ) )
+		{
+			Sleep(200);		// WaitForSingleObject()ではCPU使用率が下がらないのでSleep()を実行
+			
+			if( MainWindow->getHWnd() != GetForegroundWindow() ) continue;		// ウインドウがバックグラウンドなら画面出力を実行しない
+		}
+		#endif
+		
 		displayProc();
 		//Sleep(10); //don't be greedy and use a whole cpu core, but leave room for 60fps 
 		WaitForSingleObject(display_wakeup_event, 10); // same as sleep but lets something wake us up early
@@ -1989,10 +5630,19 @@
 	display_die = true;
 	SetEvent(display_wakeup_event);
 	g_thread_join(display_thread);
+	
+	#if defined(X432R_CUSTOMRENDERER_ENABLED) && !defined(X432R_D3D_DISPLAYMETHOD_ENABLED)
+	if( CommonSettings.single_core() )
+	{
+		X432R::DeleteScreenTexture();
+		gldisplay.kill();
+	}
+	#endif
 }
 
 void Display()
 {
+	#ifndef X432R_CUSTOMRENDERER_ENABLED
 	if(CommonSettings.single_core())
 	{
 		video.srcBuffer = (u8*)GPU_screen;
@@ -2019,6 +5669,62 @@
 
 		g_mutex_unlock(display_mutex);
 	}
+	#else
+	if( CommonSettings.single_core() )
+	{
+		if( X432R::IsHighResolutionRendererSelected() && X432R::backBuffer.IsCurrentFrameRendered() )
+			X432R::UpdateFrontBuffer();
+		
+		video.srcBuffer = (u8*)GPU_screen;
+		DoDisplay(true);
+	}
+	else
+	{
+		if(display_thread == NULL)
+		{
+			display_mutex = g_mutex_new();
+			display_thread = g_thread_create( (GThreadFunc)displayThread,
+											 NULL,
+											 TRUE,
+											 NULL);
+		}
+		
+		g_mutex_lock(display_mutex);
+		
+		#if 0
+		if( int diff = ( (currDisplayBuffer + 1) % 3 ) - newestDisplayBuffer )
+			newestDisplayBuffer += diff;
+		else
+			newestDisplayBuffer = (currDisplayBuffer + 2) % 3;
+		
+		memcpy( displayBuffers[newestDisplayBuffer], GPU_screen, 256 * 192 * 4 );
+		
+		X432R::UpdateFrontBuffer();
+		#else
+		int newest_index = newestDisplayBuffer;
+		
+		if( int diff = ( (currDisplayBuffer + 1) % 3 ) - newestDisplayBuffer )
+			newest_index += diff;
+		else
+			newest_index = (currDisplayBuffer + 2) % 3;
+		
+		if( !X432R::IsHighResolutionRendererSelected() )
+		{
+			newestDisplayBuffer = newest_index;
+			
+			memcpy( displayBuffers[newestDisplayBuffer], GPU_screen, 256 * 192 * 4 );
+		}
+		else if( X432R::backBuffer.IsCurrentFrameRendered() )
+		{
+			newestDisplayBuffer = newest_index;
+			
+			X432R::UpdateFrontBuffer();
+		}
+		#endif
+		
+		g_mutex_unlock(display_mutex);
+	}
+	#endif
 }
 
 
@@ -2097,7 +5803,10 @@
 
 static void StepRunLoop_Core()
 {
+	#ifndef X432R_TOUCHINPUT_ENABLED
 	input_acquire();
+	#endif
+	
 	NDS_beginProcessingInput();
 	{
 		input_process();
@@ -2156,7 +5865,11 @@
 	Display();
 
 	gfx3d.frameCtrRaw++;
+	#ifndef X432R_MENUITEMMOD_ENABLED
 	if(gfx3d.frameCtrRaw == 60) {
+	#else
+	if(gfx3d.frameCtrRaw >= 60) {
+	#endif
 		mainLoopData.fps3d = gfx3d.frameCtr;
 		gfx3d.frameCtrRaw = 0;
 		gfx3d.frameCtr = 0;
@@ -2164,6 +5877,8 @@
 
 
 	mainLoopData.toolframecount++;
+	
+	#ifndef X432R_MENUITEMMOD_ENABLED
 	if (mainLoopData.toolframecount == kFramesPerToolUpdate)
 	{
 		if(SoundView_IsOpened()) SoundView_Refresh();
@@ -2177,12 +5892,43 @@
 	mainLoopData.fpsframecount++;
 	QueryPerformanceCounter((LARGE_INTEGER *)&mainLoopData.curticks);
 	bool oneSecond = mainLoopData.curticks >= mainLoopData.fpsticks + mainLoopData.freq;
+	#else
+	mainLoopData.fpsframecount++;
+	QueryPerformanceCounter( (LARGE_INTEGER *)&mainLoopData.curticks );
+	const bool oneSecond = ( mainLoopData.curticks >= (mainLoopData.fpsticks + mainLoopData.freq) );
+	
+	if( !X432R::cpuPowerSavingEnabled || oneSecond )
+	{
+		if(mainLoopData.toolframecount >= kFramesPerToolUpdate)
+		{
+			if( SoundView_IsOpened() ) SoundView_Refresh();
+			RefreshAllToolWindows();
+			
+			mainLoopData.toolframecount = 0;
+		}
+		
+		Update_RAM_Search(); // Update_RAM_Watch() is also called.
+	}
+	#endif
+
 	if(oneSecond) // TODO: print fps on screen in DDraw
 	{
 		mainLoopData.fps = mainLoopData.fpsframecount;
 		mainLoopData.fpsframecount = 0;
 		QueryPerformanceCounter((LARGE_INTEGER *)&mainLoopData.fpsticks);
-	}
+		
+		#ifdef X432R_CUSTOMRENDERER_ENABLED
+		X432R::UpdateWindowCaptionFPS(mainLoopData.fps, mainLoopData.fps3d);
+		#endif
+		
+/*		#ifdef X432R_TOUCHINPUT_ENABLED
+		X432R::CheckTouchInputDeviceConnected();
+		#endif
+*/		
+/*		#if defined(X432R_CUSTOMRENDERER_ENABLED) && defined(X432R_CUSTOMSCREENSCALING_ENABLED)
+		X432R::ExecSmallScreenAutoSwap();
+		#endif
+*/	}
 
 	if(nds.idleFrameCounter==0 || oneSecond) 
 	{
@@ -2218,6 +5964,13 @@
 	int skipRate = (forceFrameSkip < 0) ? frameskiprate : forceFrameSkip;
 	int ffSkipRate = (forceFrameSkip < 0) ? 9 : forceFrameSkip;
 
+	#ifdef X432R_MENUITEMMOD_ENABLED
+	const bool throttled_fastforward = (forceFrameSkip < 0) && (X432R::currentTargetFps > 60);
+	
+	if(throttled_fastforward)
+		skipRate = 9;
+	#endif
+
 	if(lastskiprate != skipRate)
 	{
 		lastskiprate = skipRate;
@@ -2260,7 +6013,11 @@
 		SpeedThrottle();
 	}
 
+	#ifndef X432R_MENUITEMMOD_ENABLED
 	if (autoframeskipenab && frameskiprate)
+	#else
+	if(autoframeskipenab && frameskiprate && !throttled_fastforward)
+	#endif
 	{
 		if(!frameAdvance && !continuousframeAdvancing)
 		{
@@ -2319,6 +6076,7 @@
 
 	while(!finished)
 	{
+		#ifndef X432R_TOUCHINPUT_ENABLED
 		while(execute)
 		{
 			StepRunLoop_Core();
@@ -2328,7 +6086,23 @@
 		}
 		StepRunLoop_Paused();
 		CheckMessages();
+		#else
+		CheckMessages();
+		input_acquire();
+		X432R::HandleHotkeys();
+		
+		if( !execute )
+			StepRunLoop_Paused();
+		else
+		{
+			StepRunLoop_Core();
+			StepRunLoop_User();
+			StepRunLoop_Throttle();
 	}
+		
+		X432R::ExecDelayedTouchUp();
+		#endif
+	}
 
 	return 1;
 }
@@ -2556,8 +6330,10 @@
 //	DeleteMenu(configMenu,GetSubMenuIndexByHMENU(configMenu,advancedMenu),MF_BYPOSITION);
 //#endif
 
+	#ifndef X432R_MENUITEMMOD_ENABLED
 	if (!gShowConsole)
 		DeleteMenu(toolsMenu, IDM_CONSOLE_ALWAYS_ON_TOP, MF_BYCOMMAND);
+	#endif
 
 	return 1;
 }
@@ -2843,6 +6619,11 @@
 		ServiceDisplayThreadInvocations();
 
 		CheckMessages();
+		
+		#ifdef X432R_TOUCHINPUT_ENABLED
+		input_acquire();
+		X432R::HandleHotkeys();
+		#endif
 
 		if(!romloaded)
 			return ESTEP_DONE;
@@ -2862,6 +6643,10 @@
 		if(!disableUser)
 			StepRunLoop_User();
 
+		#ifdef X432R_TOUCHINPUT_ENABLED
+		X432R::ExecDelayedTouchUp();
+		#endif
+
 		return ESTEP_DONE;
 	}
 
@@ -2934,6 +6719,11 @@
 	InitializeCriticalSection(&win_execute_sync);
 	InitializeCriticalSection(&win_backbuffer_sync);
 	InitializeCriticalSection(&display_invoke_handler_cs);
+	
+	#ifdef X432R_CUSTOMRENDERER_ENABLED
+	InitializeCriticalSection(&X432R::customFrontBufferSync);
+	#endif
+	
 	display_invoke_ready_event = CreateEvent(NULL, TRUE, FALSE, NULL);
 	display_invoke_done_event = CreateEvent(NULL, FALSE, FALSE, NULL);
 	display_wakeup_event = CreateEvent(NULL, FALSE, FALSE, NULL);
@@ -2948,7 +6738,12 @@
 	//this helps give a substantial speedup for singlecore users
 	SYSTEM_INFO systemInfo;
 	GetSystemInfo(&systemInfo);
+	
+	#ifndef X432R_SINGLECORE_TEST
 	CommonSettings.num_cores = systemInfo.dwNumberOfProcessors;
+	#else
+	CommonSettings.num_cores = 1;
+	#endif
 
 	msgbox = &msgBoxWnd;
 
@@ -2972,6 +6767,10 @@
 	if(GetPrivateProfileBool("Video","Window Always On Top", false, IniName)) style |= DWS_ALWAYSONTOP;
 	if(GetPrivateProfileBool("Video","Window Lockdown", false, IniName)) style |= DWS_LOCKDOWN;
 	
+	#ifdef X432R_MENUITEMMOD_ENABLED
+	else if( GetPrivateProfileBool("X432R", "NoResize", true, IniName) ) style |= DWS_NORESIZE;
+	#endif
+	
 	if(GetPrivateProfileBool("Video","Display Method Filter", false, IniName))
 		style |= DWS_FILTER;
 	if(GetPrivateProfileBool("Video","VSync", false, IniName))
@@ -2984,10 +6783,14 @@
 	if(dispMethod == DISPMETHOD_OPENGL)
 		style |= DWS_OPENGL;
 
+	#ifndef X432R_CUSTOMSCREENSCALING_ENABLED
 	windowSize = GetPrivateProfileInt("Video","Window Size", 0, IniName);
+	ForceRatio = GetPrivateProfileBool("Video","Window Force Ratio", 1, IniName);
+	#else
+	windowSize = clamp( (float)X432R::GetPrivateProfileFloat("Video", "Window Size", 1.0f), 1.0f, 50.0f );
+	#endif
 	video.rotation =  GetPrivateProfileInt("Video","Window Rotate", 0, IniName);
 	video.rotation_userset =  GetPrivateProfileInt("Video","Window Rotate Set", video.rotation, IniName);
-	ForceRatio = GetPrivateProfileBool("Video","Window Force Ratio", 1, IniName);
 	PadToInteger = GetPrivateProfileBool("Video","Window Pad To Integer", 0, IniName);
 	WndX = GetPrivateProfileInt("Video","WindowPosX", CW_USEDEFAULT, IniName);
 	WndY = GetPrivateProfileInt("Video","WindowPosY", CW_USEDEFAULT, IniName);
@@ -3002,7 +6805,12 @@
 	{
 		video.layout = video.layout_old = 0;
 	}
+	
+	#ifndef X432R_CUSTOMSCREENSCALING_ENABLED
 	video.swap = GetPrivateProfileInt("Video", "LCDsSwap", 0, IniName);
+	#else
+	video.swap = clamp<int>( GetPrivateProfileInt("Video", "LCDsSwap", 0, IniName), 0, 1 );
+	#endif
 	
 	CommonSettings.hud.FpsDisplay = GetPrivateProfileBool("Display","Display Fps", false, IniName);
 	CommonSettings.hud.FrameCounterDisplay = GetPrivateProfileBool("Display","FrameCounter", false, IniName);
@@ -3016,8 +6824,18 @@
 	GetPrivateProfileString("MicSettings", "MicSampleFile", "micsample.raw", MicSampleName, MAX_PATH, IniName);
 	RefreshMicSettings();
 	
+	#ifndef X432R_CUSTOMSCREENSCALING_ENABLED
 	video.screengap = GetPrivateProfileInt("Display", "ScreenGap", 0, IniName);
+	#else
+	video.screengap = clamp( (s32)GetPrivateProfileInt("Display", "ScreenGap", 0, IniName), 0, 192 );
+	#endif
+	
+	#ifndef X432R_MENUITEMMOD_ENABLED
 	SeparationBorderDrag = GetPrivateProfileBool("Display", "Window Split Border Drag", true, IniName);
+	#else
+	SeparationBorderDrag = GetPrivateProfileBool("Display", "Window Split Border Drag", false, IniName);
+	#endif
+	
 	ScreenGapColor = GetPrivateProfileInt("Display", "ScreenGapColor", 0xFFFFFF, IniName);
 	FrameLimit = GetPrivateProfileBool("FrameLimit", "FrameLimit", true, IniName);
 	CommonSettings.showGpu.main = GetPrivateProfileInt("Display", "MainGpu", 1, IniName) != 0;
@@ -3320,6 +7138,7 @@
 		frameskiprate=atoi(text);
 	}
 
+	#ifndef X432R_TOUCHINPUT_ENABLED
 	if (KeyInDelayMSec == 0) {
 		DWORD dwKeyboardDelay;
 		SystemParametersInfo(SPI_GETKEYBOARDDELAY, 0, &dwKeyboardDelay, 0);
@@ -3336,8 +7155,37 @@
 		KeyInDelayMSec = KeyInRepeatMSec;
 
 	hKeyInputTimer = timeSetEvent (KeyInRepeatMSec, 0, KeyInputTimer, 0, TIME_PERIODIC);
+	#else
+	X432R::InitTouchInput();
+	#endif
+	
+	#ifndef X432R_CUSTOMRENDERER_ENABLED
+	cur3DCore = GetPrivateProfileInt("3D", "Renderer", GPU3D_DEFAULT, IniName);
+	#else
+	cur3DCore = GetPrivateProfileInt("X432R", "Renderer", GPU3D_DEFAULT, IniName);
+	
+	X432R::RGBA8888::InitBlendColorTable();
+	
+	#ifdef X432R_LOWQUALITYMODE_TEST
+	X432R::lowQualityMsaaEnabled = GetPrivateProfileBool("X432R", "LowQualityMsaaEnabled", false, IniName);
+	X432R::lowQualityAlphaBlendEnabled = GetPrivateProfileBool("X432R", "LowQualityAlphaBlendEnabled", false, IniName);
+	
+	if( X432R::lowQualityMsaaEnabled && !GetPrivateProfileBool("3D", "EnableAntiAliasing", 0, IniName) )
+	{
+		X432R::lowQualityMsaaEnabled = false;
+		WritePrivateProfileBool("X432R", "LowQualityMsaaEnabled", false, IniName);
+	}
+	#endif
+	
+	#ifdef X432R_D3D_DISPLAYMETHOD_ENABLED
+	X432R::d3dDisplayMethod.LoadShaderSettings();
+	
+	X432R::d3dSelectedShaderSlot = clamp<u32>( GetPrivateProfileInt("X432R", "D3DSelectedShaderSlot", 0, IniName), 0, X432R::d3dMaxShaderSlot );
+	X432R::d3dShaderEffectLevel = clamp<u32>( GetPrivateProfileInt("X432R", "D3DShaderEffectLevel", 0, IniName), 0, X432R::d3dMaxShaderEffectLevel );
+	X432R::d3dShaderEffectMode = clamp<u32>( GetPrivateProfileInt("X432R", "D3DShaderEffectMode", 0, IniName), 0, X432R::d3dMaxShaderEffectMode );
+	#endif
+	#endif
 
-	cur3DCore = GetPrivateProfileInt("3D", "Renderer", GPU3D_DEFAULT, IniName);
 	if(cur3DCore == GPU3D_NULL_SAVED)
 		cur3DCore = GPU3D_NULL;
 	else if(cur3DCore == GPU3D_NULL) // this value shouldn't be saved anymore
@@ -3376,6 +7224,19 @@
 	if (cmdline._spu_sync_method == -1)
 		CommonSettings.SPU_sync_method = GetPrivateProfileInt("Sound","SynchMethod",0,IniName);	
 	
+	#ifdef X432R_MENUITEMMOD_ENABLED
+	X432R::ChangeSoundEnabled( GetPrivateProfileBool("X432R", "SoundEnabled", X432R::soundOutputEnabled, IniName) );
+	X432R::cpuPowerSavingEnabled = GetPrivateProfileBool("X432R", "CpuPowerSavingEnabled", X432R::cpuPowerSavingEnabled, IniName);
+	X432R::showMenubarInFullScreen = GetPrivateProfileBool("X432R", "ShowMenubarInFullScreen", X432R::showMenubarInFullScreen, IniName);
+	
+	X432R::fastForwardLevel = clamp<u32>( GetPrivateProfileInt("X432R", "FastForwardLevel", 0, IniName), 0, X432R::fastForwardLevel_Max );
+	X432R::slowMotionLevel = clamp<u32>( GetPrivateProfileInt("X432R", "SlowMotionLevel", 0, IniName), 0, X432R::slowMotionLevel_Max );
+	
+	#ifdef X432R_CUSTOMSCREENSCALING_ENABLED
+	X432R::InitSmallScreenSetting();
+	#endif
+	#endif
+	
 	CommonSettings.DebugConsole = GetPrivateProfileBool("Emulation", "DebugConsole", false, IniName);
 	CommonSettings.EnsataEmulation = GetPrivateProfileBool("Emulation", "EnsataEmulation", false, IniName);
 	CommonSettings.UseExtBIOS = GetPrivateProfileBool("BIOS", "UseExtBIOS", false, IniName);
@@ -3443,7 +7304,21 @@
 		HK_StateLoadSlot(load, true);
 	}
 
+	#ifndef X432R_MENUITEMMOD_ENABLED
 	MainWindow->Show(SW_NORMAL);
+	#else
+	if( GetPrivateProfileBool("X432R","WindowFullScreen", false, IniName) )
+	{
+//		ToggleFullscreen();
+		SetStyle( GetStyle() | DWS_FULLSCREEN );
+		MainWindow->Show(SW_MAXIMIZE);
+	}
+	else if( GetPrivateProfileBool("X432R","WindowMaximized", false, IniName) )
+		MainWindow->Show(SW_MAXIMIZE);
+	
+	else
+		MainWindow->Show(SW_NORMAL);
+	#endif
 
 	//DEBUG TEST HACK
 	//driver->VIEW3D_Init();
@@ -3478,7 +7353,11 @@
 	//LogStop();
 #endif
 
+	#ifndef X432R_TOUCHINPUT_ENABLED
 	timeKillEvent(hKeyInputTimer);
+	#else
+	X432R::DeinitTouchInput();
+	#endif
 
 	GInfo_DeInit();
 
@@ -3502,6 +7381,9 @@
 
 	delete MainWindow;
 
+	#ifdef X432R_D3D_DISPLAYMETHOD_ENABLED
+	X432R::d3dDisplayMethod.Deinit(true);
+	#endif
 	ddraw.release();
 
 	UnregWndClass("DeSmuME");
@@ -3627,6 +7509,11 @@
 			SubScreenSrcRect.top = 0;
 			SubScreenSrcRect.right = video.height;
 			SubScreenSrcRect.bottom = video.width;
+			
+			#ifdef X432R_CUSTOMSCREENSCALING_ENABLED
+			if(video.rotation == 90)
+				std::swap(MainScreenSrcRect, SubScreenSrcRect);
+			#endif
 		}
 		else
 		{
@@ -3641,6 +7528,11 @@
 			SubScreenSrcRect.top = video.height/2;
 			SubScreenSrcRect.right = video.width;
 			SubScreenSrcRect.bottom = video.height;
+			
+			#ifdef X432R_CUSTOMSCREENSCALING_ENABLED
+			if(video.rotation == 180)
+				std::swap(MainScreenSrcRect, SubScreenSrcRect);
+			#endif
 		}
 	}
 }
@@ -3648,6 +7540,11 @@
 // re-run the aspect ratio calculations if enabled
 void FixAspectRatio()
 {
+/*	#ifdef X432R_MENUITEMMOD_ENABLED
+	if( (MainWindow == NULL) || IsZoomed( MainWindow->getHWnd() ) || ( GetStyle() & DWS_FULLSCREEN ) ) return;
+	#endif
+*/	
+	#ifndef X432R_CUSTOMSCREENSCALING_ENABLED
 	if(windowSize != 0)
 	{
 		ScaleScreen(windowSize, false);
@@ -3659,13 +7556,22 @@
 		SendMessage(MainWindow->getHWnd(), WM_SIZING, WMSZ_BOTTOMRIGHT, (LPARAM)&rc); // calls WINCLASS::sizingMsg
 		MoveWindow(MainWindow->getHWnd(), rc.left, rc.top, rc.right-rc.left, rc.bottom-rc.top, TRUE);
 	}
+	#else
+	ScaleScreen(windowSize, false);
+	#endif
 }
 
 void SetScreenGap(int gap)
 {
+	#ifndef X432R_CUSTOMSCREENSCALING_ENABLED
 	video.screengap = gap;
 	SetMinWindowSize();
 	FixAspectRatio();
+	#else
+	video.screengap = clamp(gap, 0, 192);
+	SetMinWindowSize();
+	ScaleScreen(windowSize, false);
+	#endif
 	UpdateWndRects(MainWindow->getHWnd());
 }
 
@@ -3672,10 +7578,25 @@
 //========================================================================================
 void SetRotate(HWND hwnd, int rot, bool user)
 {
+	#ifdef X432R_MENUITEMMOD_ENABLED
+	if(video.layout != 0)
+	{
+		if(user) return;
+		
+		rot = 0;
+	}
+	
+//	if(rot == video.rotation) return;
+	#endif
+	
 	bool maximized = IsZoomed(hwnd)==TRUE;
 	if(((rot == 90) || (rot == 270)) == ((video.rotation == 90) || (video.rotation == 270)))
 		maximized = false; // no need to toggle out to windowed if the dimensions aren't changing
+	
+//	#ifndef X432R_MENUITEMMOD_ENABLED
 	if(maximized) ShowWindow(hwnd,SW_NORMAL);
+//	#endif
+	
 	{
 	Lock lock (win_backbuffer_sync);
 
@@ -3686,6 +7607,7 @@
 
 	video.rotation = rot;
 
+//	#ifndef X432R_CUSTOMSCREENSCALING_ENABLED
 	GetClientRect(hwnd, &rc);
 	oldwidth = (rc.right - rc.left);
 	oldheight = (rc.bottom - rc.top) - MainWindowToolbar->GetHeight();
@@ -3716,13 +7638,28 @@
 		}
 		break;
 	}
-
+/*	#else
+//	GetClientRect(hwnd, &rc);
+	GetNdsScreenRect(&rc);
+	
+	newwidth = rc.right - rc.left;
+	newheight = rc.bottom - rc.top;
+	
+	if( ( (oldrot == 90) || (oldrot == 270) ) != ( (rot == 90) || (rot == 270) ) )
+		std::swap(newwidth, newheight);
+	#endif
+*/
 	osd->setRotate(rot);
 
 	SetMinWindowSize();
 
+//	#ifndef X432R_MENUITEMMOD_ENABLED
 	MainWindow->setClientSize(newwidth, newheight);
-
+/*	#else
+	if( !maximized )
+		MainWindow->setClientSize(newwidth, newheight);
+	#endif
+*/
 	int cwid, ccwid;
 	switch (rot)
 	{
@@ -3747,7 +7684,10 @@
 	UpdateScreenRects();
 	UpdateWndRects(hwnd);
 	}
+	
+//	#ifndef X432R_MENUITEMMOD_ENABLED
 	if(maximized) ShowWindow(hwnd,SW_MAXIMIZE);
+//	#endif
 }
 
 void AviEnd()
@@ -4005,11 +7945,17 @@
 	{
 		if(path.savelastromvisit)
 		{
+			#ifndef X432R_FILEPATHMOD_ENABLED
 			char *lchr, buffer[MAX_PATH];
 			ZeroMemory(buffer, sizeof(buffer));
 
 			lchr = strrchr(filename, '\\');
 			strncpy(buffer, filename, strlen(filename) - strlen(lchr));
+			#else
+			char buffer[MAX_PATH] = {0};
+			strncpy( buffer, filename, sizeof(buffer) );
+			PathRemoveFileSpec(buffer);
+			#endif
 			
 			path.setpath(path.ROMS, buffer);
 			WritePathSettings();
@@ -4353,8 +8299,12 @@
 	UpdateWndRects(hwnd);
 	SetScreenGap(video.screengap);
 	SetRotate(hwnd, video.rotation, false);
+	#ifndef X432R_CUSTOMSCREENSCALING_ENABLED
 	if(user && windowSize==0) {}
 	else ScaleScreen(windowSize, false);
+	#else
+	ScaleScreen(windowSize, false);
+	#endif
 	WritePrivateProfileInt("Video", "Filter", video.currentfilter, IniName);
 	WritePrivateProfileInt("Video", "Width", video.width, IniName);
 	WritePrivateProfileInt("Video", "Height", video.height, IniName);
@@ -4495,10 +8445,14 @@
 			// LCDs swap
 			MainWindow->checkMenu(ID_LCDS_NOSWAP,  video.swap == 0);
 			MainWindow->checkMenu(ID_LCDS_SWAP,    video.swap == 1);
+			#ifndef X432R_CUSTOMSCREENSCALING_ENABLED
 			MainWindow->checkMenu(ID_LCDS_MAINGPU, video.swap == 2);
 			MainWindow->checkMenu(ID_LCDS_SUBGPU,  video.swap == 3);
+			#endif
 			//Force Maintain Ratio
+			#ifndef X432R_CUSTOMSCREENSCALING_ENABLED
 			MainWindow->checkMenu(IDC_FORCERATIO, ((ForceRatio)));
+			#endif
 			MainWindow->checkMenu(IDC_VIEW_PADTOINTEGER, ((PadToInteger)));
 			//Screen rotation
 			MainWindow->checkMenu(IDC_ROTATE0, ((video.rotation_userset==0)));
@@ -4506,6 +8460,7 @@
 			MainWindow->checkMenu(IDC_ROTATE180, ((video.rotation_userset==180)));
 			MainWindow->checkMenu(IDC_ROTATE270, ((video.rotation_userset==270)));
 
+			#ifndef X432R_CUSTOMSCREENSCALING_ENABLED
 			//Window Size
 			MainWindow->checkMenu(IDC_WINDOW1X, ((windowSize==1)));
 			MainWindow->checkMenu(IDC_WINDOW1_5X, ((windowSize==kScale1point5x)));
@@ -4515,6 +8470,40 @@
 			MainWindow->checkMenu(IDC_WINDOW4X, ((windowSize==4)));
 			MainWindow->checkMenu(IDM_ALWAYS_ON_TOP, (GetStyle()&DWS_ALWAYSONTOP)!=0);
 			MainWindow->checkMenu(IDM_LOCKDOWN, (GetStyle()&DWS_LOCKDOWN)!=0);
+			#else
+			MainWindow->checkMenu( IDC_WINDOW1X,			(windowSize == 1.0f) );
+			MainWindow->checkMenu( IDC_WINDOW1_5X,			(windowSize == 1.5f) );
+			MainWindow->checkMenu( IDC_WINDOW2X,			(windowSize == 2.0f) );
+			MainWindow->checkMenu( IDC_WINDOW2_5X,			(windowSize == 2.5f) );
+			MainWindow->checkMenu( IDC_WINDOW3X,			(windowSize == 3.0f) );
+			MainWindow->checkMenu( IDC_WINDOW4X,			(windowSize == 4.0f) );
+			MainWindow->checkMenu( IDM_ALWAYS_ON_TOP,		( ( GetStyle() & DWS_ALWAYSONTOP ) != 0 ) );
+			MainWindow->checkMenu( IDM_LOCKDOWN,			( ( GetStyle() & DWS_LOCKDOWN) != 0 ) );
+			
+			MainWindow->checkMenu( X432R_MENUITEM_SCREENSIZE_0,				( X432R::smallScreenSetting_Current == X432R::smallScreenSetting_Min ) );
+			MainWindow->checkMenu( X432R_MENUITEM_SCREENSIZE_1,				( X432R::smallScreenSetting_Current == (X432R::smallScreenSetting_Min + 1) ) );
+			MainWindow->checkMenu( X432R_MENUITEM_SCREENSIZE_2,				( X432R::smallScreenSetting_Current == (X432R::smallScreenSetting_Min + 2) ) );
+			MainWindow->checkMenu( X432R_MENUITEM_SCREENSIZE_3,				( X432R::smallScreenSetting_Current == (X432R::smallScreenSetting_Min + 3) ) );
+			MainWindow->checkMenu( X432R_MENUITEM_SCREENSIZE_4,				( X432R::smallScreenSetting_Current == (X432R::smallScreenSetting_Min + 4) ) );
+			MainWindow->checkMenu( X432R_MENUITEM_SCREENSIZE_5,				( X432R::smallScreenSetting_Current == (X432R::smallScreenSetting_Min + 5) ) );
+			MainWindow->checkMenu( X432R_MENUITEM_SCREENSIZE_6,				( X432R::smallScreenSetting_Current == (X432R::smallScreenSetting_Min + 6) ) );
+			MainWindow->checkMenu( X432R_MENUITEM_SCREENSIZE_7,				( X432R::smallScreenSetting_Current == (X432R::smallScreenSetting_Min + 7) ) );
+			MainWindow->checkMenu( X432R_MENUITEM_SCREENSIZE_8,				( X432R::smallScreenSetting_Current == (X432R::smallScreenSetting_Min + 8) ) );
+			MainWindow->checkMenu( X432R_MENUITEM_SCREENSIZE_9,				( X432R::smallScreenSetting_Current == (X432R::smallScreenSetting_Min + 9) ) );
+			MainWindow->checkMenu( X432R_MENUITEM_SCREENSIZE_10,			( X432R::smallScreenSetting_Current == (X432R::smallScreenSetting_Min + 10) ) );
+			
+/*			#ifdef X432R_CUSTOMRENDERER_ENABLED
+			MainWindow->checkMenu( X432R_MENUITEM_SCREENSIZE_AUTOSWAP,		X432R::smallScreen_AutoSwapEnabled );
+			#endif
+*/			
+			MainWindow->checkMenu( X432R_MENUITEM_SCREENHORIZONTALALIGN_LEFT,		(X432R::smallScreenOffset_Horizontal == 0) );
+			MainWindow->checkMenu( X432R_MENUITEM_SCREENHORIZONTALALIGN_CENTER,		(X432R::smallScreenOffset_Horizontal == 1) );
+			MainWindow->checkMenu( X432R_MENUITEM_SCREENHORIZONTALALIGN_RIGHT,		(X432R::smallScreenOffset_Horizontal == 2) );
+			
+			MainWindow->checkMenu( X432R_MENUITEM_SCREENVERTICALALIGN_TOP,			(X432R::smallScreenOffset_Vertical == 0) );
+			MainWindow->checkMenu( X432R_MENUITEM_SCREENVERTICALALIGN_CENTER,		(X432R::smallScreenOffset_Vertical == 1) );
+			MainWindow->checkMenu( X432R_MENUITEM_SCREENVERTICALALIGN_BOTTOM,		(X432R::smallScreenOffset_Vertical == 2) );
+			#endif
 
 			//Screen Separation
 			MainWindow->checkMenu(IDM_SCREENSEP_NONE,   ((video.screengap==kGapNone)));
@@ -4585,6 +8574,58 @@
 			MainWindow->checkMenu(IDM_RENDER_4XBRZ, video.currentfilter == video._4XBRZ );
 			MainWindow->checkMenu(IDM_RENDER_5XBRZ, video.currentfilter == video._5XBRZ );
 
+			#ifdef X432R_CUSTOMRENDERER_ENABLED
+			const u32 render_magnification = X432R::GetCurrentRenderMagnification();
+			const bool highreso = (render_magnification > 1);
+			
+			MainWindow->checkMenu( X432R_MENUITEM_CHANGERESOLUTION_X1,		(render_magnification == 1) );
+			MainWindow->checkMenu( X432R_MENUITEM_CHANGERESOLUTION_X2,		(render_magnification == 2) );
+			MainWindow->checkMenu( X432R_MENUITEM_CHANGERESOLUTION_X3,		(render_magnification == 3) );
+			MainWindow->checkMenu( X432R_MENUITEM_CHANGERESOLUTION_X4,		(render_magnification == 4) );
+			
+			DesEnableMenuItem(mainMenu, IDM_RENDER_NORMAL,					!highreso);
+			DesEnableMenuItem(mainMenu, IDM_RENDER_LQ2X,					!highreso);
+			DesEnableMenuItem(mainMenu, IDM_RENDER_LQ2XS,					!highreso);
+			DesEnableMenuItem(mainMenu, IDM_RENDER_HQ2X,					!highreso);
+			DesEnableMenuItem(mainMenu, IDM_RENDER_HQ4X,					!highreso);
+			DesEnableMenuItem(mainMenu, IDM_RENDER_HQ2XS,					!highreso);
+			DesEnableMenuItem(mainMenu, IDM_RENDER_2XSAI,					!highreso);
+			DesEnableMenuItem(mainMenu, IDM_RENDER_SUPER2XSAI,				!highreso);
+			DesEnableMenuItem(mainMenu, IDM_RENDER_SUPEREAGLE,				!highreso);
+			DesEnableMenuItem(mainMenu, IDM_RENDER_SCANLINE,				!highreso);
+			DesEnableMenuItem(mainMenu, IDM_RENDER_BILINEAR,				!highreso);
+			DesEnableMenuItem(mainMenu, IDM_RENDER_NEAREST2X,				!highreso);
+			DesEnableMenuItem(mainMenu, IDM_RENDER_EPX,						!highreso);
+			DesEnableMenuItem(mainMenu, IDM_RENDER_EPXPLUS,					!highreso);
+			DesEnableMenuItem(mainMenu, IDM_RENDER_2XBRZ,					!highreso);
+			DesEnableMenuItem(mainMenu, IDM_RENDER_3XBRZ,					!highreso);
+			DesEnableMenuItem(mainMenu, IDM_RENDER_4XBRZ,					!highreso);
+			DesEnableMenuItem(mainMenu, IDM_RENDER_5XBRZ,					!highreso);
+			
+			#ifndef X432R_D3D_DISPLAYMETHOD_ENABLED
+			DesEnableMenuItem(mainMenu, IDM_RENDER_EPX1POINT5,				!highreso);
+			DesEnableMenuItem(mainMenu, IDM_RENDER_EPXPLUS1POINT5,			!highreso);
+			DesEnableMenuItem(mainMenu, IDM_RENDER_NEAREST1POINT5,			!highreso);
+			DesEnableMenuItem(mainMenu, IDM_RENDER_NEARESTPLUS1POINT5,		!highreso);
+			#else
+			const bool ddraw_displaymethod = !( GetStyle() & DWS_OPENGL );
+			
+			DesEnableMenuItem(mainMenu, IDM_RENDER_EPX1POINT5,				!highreso && ddraw_displaymethod);
+			DesEnableMenuItem(mainMenu, IDM_RENDER_EPXPLUS1POINT5,			!highreso && ddraw_displaymethod);
+			DesEnableMenuItem(mainMenu, IDM_RENDER_NEAREST1POINT5,			!highreso && ddraw_displaymethod);
+			DesEnableMenuItem(mainMenu, IDM_RENDER_NEARESTPLUS1POINT5,		!highreso && ddraw_displaymethod);
+			
+			X432R::d3dDisplayMethod.UpdateShaderMenuItems(false);
+			#endif
+			
+			#ifdef X432R_CUSTOMRENDERER_DEBUG
+			MainWindow->checkMenu(X432R_MENUITEM_ENABLEDEBUGMODE,			X432R::debugModeEnabled);
+			MainWindow->checkMenu(X432R_MENUITEM_ENABLEDEBUGMODE2,			X432R::debugModeEnabled2);
+			DesEnableMenuItem(mainMenu, X432R_MENUITEM_ENABLEDEBUGMODE,		highreso);
+			DesEnableMenuItem(mainMenu, X432R_MENUITEM_ENABLEDEBUGMODE2,	highreso);
+			#endif
+			#endif
+
 			MainWindow->checkMenu(IDC_STATEREWINDING, staterewindingenabled == 1 );
 
 			MainWindow->checkMenu(ID_DISPLAYMETHOD_VSYNC, (GetStyle()&DWS_VSYNC)!=0);
@@ -4619,9 +8660,11 @@
 				DesEnableMenuItem(mainMenu, IDM_SCREENSEP_NDSGAP, false);
 				DesEnableMenuItem(mainMenu, IDM_SCREENSEP_NDSGAP2, false);
 				DesEnableMenuItem(mainMenu, IDM_SCREENSEP_DRAGEDIT, false);
+				#ifndef X432R_CUSTOMSCREENSCALING_ENABLED
 				DesEnableMenuItem(mainMenu, IDM_SCREENSEP_COLORWHITE, false);
 				DesEnableMenuItem(mainMenu, IDM_SCREENSEP_COLORGRAY, false);
 				DesEnableMenuItem(mainMenu, IDM_SCREENSEP_COLORBLACK, false);
+				#endif
 			}
 
 			// load type
@@ -4631,6 +8674,38 @@
 			// Tools
 			MainWindow->checkMenu(IDM_CONSOLE_ALWAYS_ON_TOP, gConsoleTopmost);
 
+			#ifndef X432R_CUSTOMRENDERER_ENABLED
+			bool softrast_selected = (cur3DCore == GPU3D_SWRAST);
+			#else
+			const bool softrast_selected = X432R::IsSoftRasterzierSelected();
+			#endif
+			
+			#ifdef X432R_MENUITEMMOD_ENABLED
+			MainWindow->checkMenu(X432R_MENUITEM_NORESIZE, GetStyle() & DWS_NORESIZE);
+			MainWindow->checkMenu(X432R_MENUITEM_SHOWMENUBAR_IN_FULLSCREEN, X432R::showMenubarInFullScreen);
+			
+			MainWindow->checkMenu(X432R_MENUITEM_SOFTRASTERIZER, softrast_selected);
+			
+			MainWindow->checkMenu(X432R_MENUITEM_SOUNDOUTPUT, X432R::soundOutputEnabled);
+			DesEnableMenuItem(mainMenu, X432R_MENUITEM_SOUNDOUTPUT, sndcoretype != 0);
+			
+			MainWindow->checkMenu(X432R_MENUITEM_CPUPOWERSAVING, X432R::cpuPowerSavingEnabled);
+			
+			MainWindow->checkMenu( X432R_MENUITEM_FASTFORWARDSPEED_0,		(X432R::fastForwardLevel == 0) );
+			MainWindow->checkMenu( X432R_MENUITEM_FASTFORWARDSPEED_1,		(X432R::fastForwardLevel == 1) );
+			MainWindow->checkMenu( X432R_MENUITEM_FASTFORWARDSPEED_2,		(X432R::fastForwardLevel == 2) );
+			MainWindow->checkMenu( X432R_MENUITEM_FASTFORWARDSPEED_3,		(X432R::fastForwardLevel == 3) );
+			MainWindow->checkMenu( X432R_MENUITEM_FASTFORWARDSPEED_4,		(X432R::fastForwardLevel == 4) );
+			MainWindow->checkMenu( X432R_MENUITEM_SLOWMOTIONSPEED_0,		(X432R::slowMotionLevel == 0) );
+			MainWindow->checkMenu( X432R_MENUITEM_SLOWMOTIONSPEED_1,		(X432R::slowMotionLevel == 1) );
+			MainWindow->checkMenu( X432R_MENUITEM_SLOWMOTIONSPEED_2,		(X432R::slowMotionLevel == 2) );
+			MainWindow->checkMenu( X432R_MENUITEM_SLOWMOTIONSPEED_3,		(X432R::slowMotionLevel == 3) );
+			MainWindow->checkMenu( X432R_MENUITEM_SLOWMOTIONSPEED_4,		(X432R::slowMotionLevel == 4) );
+			
+			MainWindow->checkMenu(X432R_MENUITEM_SHOWCONSOLE, gShowConsole);
+			DesEnableMenuItem(mainMenu, IDM_CONSOLE_ALWAYS_ON_TOP, gShowConsole);
+			#endif
+
 			UpdateHotkeyAssignments();	//Add current hotkey mappings to menu item names
 
 			CallRegisteredLuaFunctions(LUACALL_ONINITMENU);
@@ -4682,12 +8757,28 @@
 			NDS_Pause();
 			if (true/*AskSave()*/)	//Ask Save comes from the Ram Watch dialog.  The dialog uses .wch files and this allows asks the user if he wants to save changes first, should he cancel, closing will not happen
 			{
+				#ifdef X432R_MENUITEMMOD_ENABLED
+				const bool fullscreen_mode = GetStyle() & DWS_FULLSCREEN;
+				const bool window_maximized = IsZoomed(hwnd) && !fullscreen_mode;
+				
+				WritePrivateProfileBool("X432R","WindowFullScreen", fullscreen_mode, IniName);
+				WritePrivateProfileBool("X432R","WindowMaximized", window_maximized, IniName);
+				
+				if(window_maximized || fullscreen_mode)
+					ShowWindow(hwnd, SW_NORMAL);		// 最大化状態を解除してSaveWindowSize()を実行できるようにする（フルスクリーンモードだとうまく動作しない？）
+				#endif
+				
 				//Save window size
+				#ifndef X432R_CUSTOMSCREENSCALING_ENABLED
 				WritePrivateProfileInt("Video","Window Size",windowSize,IniName);
 				if (windowSize==0)
 				{
 					SaveWindowSize(hwnd);
 				}
+				#else
+				X432R::WritePrivateProfileFloat("Video", "Window Size", windowSize);
+				SaveWindowSize(hwnd);
+				#endif
 
 				//Save window position
 				SaveWindowPos(hwnd);
@@ -4724,6 +8815,7 @@
 			else
 				NDS_UnPause();
 			delete MainWindowToolbar;
+			
 			return 0;
 		}
 	case WM_MOVING:
@@ -4756,6 +8848,7 @@
 
 	case WM_SIZING:
 		{
+			#ifndef X432R_CUSTOMSCREENSCALING_ENABLED
 			{
 				Lock lock(win_backbuffer_sync);
 				backbuffer_invalidate = true;
@@ -4870,12 +8963,133 @@
 
 				UpdateWndRects(MainWindow->getHWnd());
 			}
+			#else
+//			if( IsMaximized(hwnd) || IsMinimized(hwnd) ) return 1;
+			
+			{
+				Lock lock(win_backbuffer_sync);
+				backbuffer_invalidate = true;
 		}
+			
+			InvalidateRect(hwnd, NULL, FALSE); 
+			UpdateWindow(hwnd);
+			
+			
+			const bool sideways = (video.rotation == 90) || (video.rotation == 270);
+			const bool horizontal_drag = (wParam == WMSZ_LEFT) || (wParam == WMSZ_RIGHT);
+			const bool vertical_drag = (wParam == WMSZ_TOP) || (wParam == WMSZ_BOTTOM);
+			
+			LONG forceRatioFlags = WINCLASS::NOKEEP;
+			bool set_gap = false;
+/*			bool fullscreen = false;
+			
+			if(wParam == 999)
+			{
+				//special fullscreen message
+				fullscreen = true;
+				wParam = WMSZ_BOTTOMRIGHT;
+				forceRatioFlags = WINCLASS::FULLSCREEN;
+			}
+*/			
+			float mainscreen_scale, subscreen_scale;
+			X432R::GetScreenScales(mainscreen_scale, subscreen_scale);
+			
+			const u32 mainscreen_minwidth = 256 * mainscreen_scale;
+			const u32 mainscreen_minheight = 192 * mainscreen_scale;
+			const u32 subscreen_minwidth = 256 * subscreen_scale;
+			const u32 subscreen_minheight = 192 * subscreen_scale;
+			
+			int min_width = 0;
+			int min_height = 0;
+			
+			// horizontal
+			if(video.layout == 1)
+			{
+				min_width = mainscreen_minwidth + subscreen_minwidth;
+				min_height = max(mainscreen_minheight, subscreen_minheight);
+			}
+			// one LCD
+			else if(video.layout == 2)
+			{
+				min_width = 256;
+				min_height = 192;
+			}
+			// vertical
+			else if(sideways)
+			{
+				min_width = mainscreen_minheight + subscreen_minheight;
+				min_height = max(mainscreen_minwidth, subscreen_minwidth);
+			}
+			else
+			{
+				min_width = max(mainscreen_minwidth, subscreen_minwidth);
+				min_height = mainscreen_minheight + subscreen_minheight;
+			}
+			
+			if( vertical_drag && !sideways && SeparationBorderDrag && (video.layout == 0) )
+			{
+				forceRatioFlags |= WINCLASS::KEEPX;
+				min_width *= windowSize;
+				min_height *= windowSize;
+				set_gap = true;
+			}
+			else if( horizontal_drag && sideways && SeparationBorderDrag && (video.layout == 0) )
+			{
+				forceRatioFlags |= WINCLASS::KEEPY;
+				min_width *= windowSize;
+				min_height *= windowSize;
+				set_gap = true;
+			}
+			else
+			{
+				forceRatioFlags |= WINCLASS::KEEPX;
+				forceRatioFlags |= WINCLASS::KEEPY;
+				
+				if(sideways)
+					min_width += video.screengap;
+				else
+					min_height += video.screengap;
+			}
+			
+			MainWindow->setMinSize(min_width, min_height);
+			MainWindow->sizingMsg(wParam, lParam, forceRatioFlags);
+			
+			
+			const HWND window_handle = MainWindow->getHWnd();
+			const RECT new_rect = *(RECT *)lParam;
+			
+			RECT window_rect, client_rect;
+			GetWindowRect(window_handle, &window_rect);
+			GetClientRect(window_handle, &client_rect);
+			
+			client_rect.bottom -= MainWindowToolbar->GetHeight();
+			
+			const u32 new_clientwidth = (new_rect.right - new_rect.left) - ( (window_rect.right - window_rect.left) - client_rect.right );
+			const u32 new_clientheight = (new_rect.bottom - new_rect.top) - ( (window_rect.bottom - window_rect.top) - client_rect.bottom );
+			
+			if(set_gap)
+				X432R::UpdateScreenGap(sideways ? new_clientwidth : new_clientheight, windowSize);
+			else
+			{
+				if( ( (video.layout == 0) && sideways) || (video.layout == 2) )
+					windowSize = (float)new_clientheight / (float)min_height;
+				else
+					windowSize = (float)new_clientwidth / (float)min_width;
+				
+//				X432R::WritePrivateProfileFloat("Video", "Window Size", windowSize);
+			}
+			
+			
+//			UpdateWndRects(window_handle);
+			#endif
+		}
 		return 1;
 		//break;
 
 	case WM_GETMINMAXINFO:
+		#ifndef X432R_CUSTOMSCREENSCALING_ENABLED
 		if(ForceRatio)
+		#endif
 		{
 			// extend the window size limits, otherwise they can make our window get squashed
 			PMINMAXINFO pmmi = (PMINMAXINFO)lParam;
@@ -4887,7 +9101,11 @@
 
 	case WM_KEYDOWN:
 		//MainWindowToolbar->Show(false);
+		
+//		#ifndef X432R_TOUCHINPUT_ENABLED
 		input_acquire();
+//		#endif
+		
 		if(wParam != VK_PAUSE)
 			break;
 	
@@ -4910,6 +9128,7 @@
 
 			if(message == WM_SYSKEYDOWN && wParam==VK_RETURN && !(lParam&0x40000000))
 			{
+				#ifndef X432R_MENUITEMMOD_ENABLED
 				//having aspect ratio correction enabled during fullscreen switch causes errors to happen.
 				//90% sure this is because the aspect ratio correction calculations happens with the wrong frame/menu/nonclient properties in place.
 				//if we ToggleFullscreen before the ShowWindow() here, then the ShowWindow() will wreck the fullscreening.
@@ -4920,6 +9139,9 @@
 					ShowWindow(hwnd,SW_NORMAL); //maximize and fullscreen get mixed up so make sure no maximize now. IOW, alt+enter from fullscreen should never result in a maximized state
 				ToggleFullscreen();
 				ForceRatio = oldForceRatio;
+				#else
+				ToggleFullscreen();		// 上記のコメントによると、この変更により不具合が出る可能性がある？
+				#endif
 			}
 			else
 			{
@@ -4951,7 +9173,11 @@
 				return 0;
 			}
 		}
+		
+//		#ifndef X432R_TOUCHINPUT_ENABLED
 		input_acquire();
+//		#endif
+		
 		if(wParam != VK_PAUSE)
 			break;
 	case WM_SYSKEYUP:
@@ -4984,8 +9210,10 @@
 				if(pausedByMinimize)
 					NDS_UnPause();
 
+				#ifndef X432R_CUSTOMSCREENSCALING_ENABLED
 				if(wParam==SIZE_MAXIMIZED)
 				{
+					#ifndef X432R_MENUITEMMOD_ENABLED
 					RECT fullscreen;
 					GetClientRect(hwnd,&fullscreen);
 					int fswidth = fullscreen.right-fullscreen.left;
@@ -5003,12 +9231,27 @@
 					int xfudge = (fswidth-fakewidth)/2;
 					int yfudge = (fsheight-fakeheight)/2;
 					OffsetRect(&FullScreenRect,xfudge,yfudge);
+					#endif
 				}
 				else if(wParam==SIZE_RESTORED)
 				{
 					FixAspectRatio();
 				}
+				#else
+/*				if(wParam==SIZE_MAXIMIZED)
+				{
+					RECT fullscreen;
+					GetClientRect(hwnd, &fullscreen);
 				
+					SendMessage( MainWindow->getHWnd(), WM_SIZING, 999, (LPARAM)&FullScreenRect );
+				}
+				else if(wParam==SIZE_RESTORED)
+*/				if(wParam==SIZE_RESTORED)
+				{
+					FixAspectRatio();
+				}
+				#endif
+				
 				UpdateWndRects(hwnd);
 				MainWindowToolbar->OnSize();
 			}
@@ -5129,6 +9372,10 @@
 	case WM_MOUSEMOVE:
 	case WM_LBUTTONDOWN:
 	case WM_LBUTTONDBLCLK:
+		#ifdef X432R_TOUCHINPUT_ENABLED
+		if( X432R::IsMouseEventFromTouch() ) return 0;			// タッチ入力で発生したイベントを無視
+		#endif
+		
 		if (wParam & MK_LBUTTON)
 		{
 			SetCapture(hwnd);
@@ -5136,8 +9383,9 @@
 			s32 x = (s32)((s16)LOWORD(lParam));
 			s32 y = (s32)((s16)HIWORD(lParam));
 
+			#ifndef X432R_CUSTOMSCREENSCALING_ENABLED
 			UnscaleScreenCoords(x,y);
-
+			
 			if(HudEditorMode)
 			{
 				ToDSScreenRelativeCoords(x,y,0);
@@ -5147,8 +9395,19 @@
 			{
 				if ((video.layout == 2) && ((video.swap == 0) || (video.swap == 2 && !MainScreen.offset) || (video.swap == 3 && MainScreen.offset))) return 0;
 				ToDSScreenRelativeCoords(x,y,1);
+				
+				#ifndef X432R_TOUCHINPUT_ENABLED
 				if(x<0) x = 0; else if(x>255) x = 255;
 				if(y<0) y = 0; else if(y>192) y = 192;
+				#else
+				if(userTouchesScreen)
+				{
+					x = clamp(x, 0, 255);
+					y = clamp(y, 0, 191);
+				}
+				else if( (x < 0) || (x > 255) || (y < 0) || (y > 191) ) return 0;		// 下画面の範囲外で発生したマウスクリックを無視
+				#endif
+				
 				NDS_setTouchPos(x, y);
 				winLastTouch.x = x;
 				winLastTouch.y = y;
@@ -5155,7 +9414,34 @@
 				userTouchesScreen = true;
 				return 0;
 			}
+			#else
+			if(HudEditorMode)
+			{
+				UnscaleScreenCoords(x,y);
+				ToDSScreenRelativeCoords(x,y,0);
+				EditHud(x,y, &Hud);
 		}
+			else
+			{
+				if( (video.layout == 2) && (video.swap == 0) ) return 0;
+				
+				X432R::ToDSScreenRelativeCoords(x, y);
+				
+				if(userTouchesScreen)
+				{
+					x = clamp(x, 0, 255);
+					y = clamp(y, 0, 191);
+				}
+				else if( (x < 0) || (x > 255) || (y < 0) || (y > 191) ) return 0;		// 下画面の範囲外で発生したマウスクリックを無視
+				
+				NDS_setTouchPos(x, y);
+				winLastTouch.x = x;
+				winLastTouch.y = y;
+				userTouchesScreen = true;
+				return 0;
+			}
+			#endif
+		}
 		if (!StylusAutoHoldPressed)
 			NDS_releaseTouch();
 		userTouchesScreen = false;
@@ -5162,6 +9448,9 @@
 		return 0;
 
 	case WM_LBUTTONUP:
+		#ifdef X432R_TOUCHINPUT_ENABLED
+		if( X432R::IsMouseEventFromTouch() ) return 0;			// タッチ入力で発生したイベントを無視
+		#endif
 
 		ReleaseCapture();
 		HudClickRelease(&Hud);
@@ -5170,6 +9459,164 @@
 		userTouchesScreen = false;
 		return 0;
 
+	#ifdef X432R_TOUCHINPUT_ENABLED
+	case WM_TOUCH:
+	{
+		#ifndef X432R_CUSTOMSCREENSCALING_ENABLED
+		if( (video.layout == 2) && ( (video.swap == 0) || (video.swap == 2 && !MainScreen.offset) || (video.swap == 3 && MainScreen.offset) ) ) return 0;
+		#else
+		if( (video.layout == 2) && (video.swap == 0) ) return 0;
+		#endif
+		
+		#if 1
+		const UINT touch_count = LOWORD(wParam);
+		
+		if(touch_count != 1) return 0;
+		
+//		TOUCHINPUT touch_inputs[16];
+		TOUCHINPUT touch_input;
+		
+//		if( X432R::GetTouchInputInfo( (HTOUCHINPUT)lParam, 16, touch_inputs, sizeof(TOUCHINPUT) ) )
+		if( X432R::GetTouchInputInfo( (HTOUCHINPUT)lParam, 1, &touch_input, sizeof(TOUCHINPUT) ) )
+		{
+			if( (touch_input.dwFlags & TOUCHEVENTF_DOWN) || (touch_input.dwFlags & TOUCHEVENTF_MOVE) )
+			{
+//				TOUCHINPUT touch_input = touch_inputs[0];
+				POINT touch_location;
+				HWND window_handle = MainWindow->getHWnd();
+				
+				touch_location.x = TOUCH_COORD_TO_PIXEL(touch_input.x);
+				touch_location.y = TOUCH_COORD_TO_PIXEL(touch_input.y);
+				
+				ScreenToClient(window_handle, &touch_location);
+				
+				s32 touch_x = touch_location.x;
+				s32 touch_y = touch_location.y;
+				
+				#ifndef X432R_CUSTOMSCREENSCALING_ENABLED
+				UnscaleScreenCoords(touch_x, touch_y);
+				ToDSScreenRelativeCoords(touch_x, touch_y, 1);
+				#else
+				X432R::ToDSScreenRelativeCoords(touch_x, touch_y);
+				#endif
+				
+				if(userTouchesScreen)
+				{
+					touch_x = clamp(touch_x, 0, 255);
+					touch_y = clamp(touch_y, 0, 191);
+				}
+				else if( (touch_x < 0) || (touch_x > 255) || (touch_y < 0) || (touch_y > 191) ) goto finish_touchinput;		// 下画面の範囲外で発生したTOUCHEVENTF_DOWNを無視
+				
+				NDS_setTouchPos(touch_x, touch_y);
+				winLastTouch.x = touch_x;
+				winLastTouch.y = touch_y;
+				userTouchesScreen = true;
+				
+				X432R::SetTouchDownFlag();
+			}
+			
+			if(touch_input.dwFlags & TOUCHEVENTF_UP)
+			{
+//				if( !StylusAutoHoldPressed )
+//					NDS_releaseTouch();
+				
+//				userTouchesScreen = false;
+				
+				X432R::SetTouchUpFlag();
+			}
+			
+			finish_touchinput:
+			
+			X432R::CloseTouchInputHandle( (HTOUCHINPUT)lParam );
+		}
+		#else
+		const UINT touch_count = LOWORD(wParam);
+		
+		if( (touch_count < 1) || (touch_count >= 16) ) return 0;
+		
+		static float valid_input_id = -1.0f;
+		TOUCHINPUT touch_inputs[16];
+		
+		if( X432R::GetTouchInputInfo( (HTOUCHINPUT)lParam, 16, touch_inputs, sizeof(TOUCHINPUT) ) )
+		{
+			HWND window_handle = MainWindow->getHWnd();
+			TOUCHINPUT *touch_input;
+			float id;
+			DWORD flags;
+			POINT touch_location;
+			s32 touch_x, touch_y;
+			
+			for(u32 i = 0; i < touch_count; ++i)
+			{
+				touch_input = touch_inputs + i;
+				
+				id = (float)touch_input->dwID;
+				flags = touch_input->dwFlags;
+				
+				touch_location.x = TOUCH_COORD_TO_PIXEL(touch_input->x);
+				touch_location.y = TOUCH_COORD_TO_PIXEL(touch_input->y);
+				
+				ScreenToClient(window_handle, &touch_location);
+				
+				touch_x = touch_location.x;
+				touch_y = touch_location.y;
+				
+				UnscaleScreenCoords(touch_x, touch_y);
+				ToDSScreenRelativeCoords(touch_x, touch_y, 1);
+				
+				if(flags & TOUCHEVENTF_DOWN)
+				{
+					if( (valid_input_id >= 0.0f) || (touch_x < 0) || (touch_x > 255) || (touch_y < 0) || (touch_y > 191) ) continue;
+					
+					valid_input_id = id;
+					
+					NDS_setTouchPos(touch_x, touch_y);
+					winLastTouch.x = touch_x;
+					winLastTouch.y = touch_y;
+					userTouchesScreen = true;
+					break;
+				}
+				
+				if(id != valid_input_id) continue;
+				
+				if(flags & TOUCHEVENTF_MOVE)
+				{
+//					if(userTouchesScreen)
+//					{
+						touch_x = clamp(touch_x, 0, 255);
+						touch_y = clamp(touch_y, 0, 191);
+//					}
+//					else if( (touch_x < 0) || (touch_x > 255) || (touch_y < 0) || (touch_y > 191) ) return 0;		// 下画面の範囲外で発生したTOUCHEVENTF_DOWNを無視
+					
+					NDS_setTouchPos(touch_x, touch_y);
+					winLastTouch.x = touch_x;
+					winLastTouch.y = touch_y;
+					userTouchesScreen = true;
+					break;
+				}
+				
+				if(flags & TOUCHEVENTF_UP)
+				{
+//					if( !StylusAutoHoldPressed )
+//						NDS_releaseTouch();
+					
+//					userTouchesScreen = false;
+					
+					X432R::SetDelayedTouchUp();
+					
+					valid_input_id = -1.0f;
+					break;
+				}
+			}
+			
+			X432R::CloseTouchInputHandle( (HTOUCHINPUT)lParam );
+		}
+		#endif
+		
+		return 0;
+	}
+	#endif
+
 #if 0
 	case WM_INITMENU: {
 		HMENU menu = (HMENU)wParam;
@@ -5775,6 +10222,7 @@
 		case ID_LCDS_SWAP:
 			LCDsSwap(1);
 			return 0;
+		#ifndef X432R_CUSTOMSCREENSCALING_ENABLED
 		case ID_LCDS_MAINGPU:
 			LCDsSwap(2);
 			return 0;
@@ -5781,6 +10229,7 @@
 		case ID_LCDS_SUBGPU:
 			LCDsSwap(3);
 			return 0;
+		#endif
 
 		case ID_VIEW_FRAMECOUNTER:
 			CommonSettings.hud.FrameCounterDisplay ^= true;
@@ -5820,6 +10269,12 @@
 
 		case ID_VIEW_HUDEDITOR:
 			HudEditorMode ^= true;
+			
+			#ifdef X432R_CUSTOMSCREENSCALING_ENABLED
+			if(HudEditorMode)
+				X432R::ResetSmallScreenSetting();
+			#endif
+			
 			osd->clear();
 			osd->border(HudEditorMode);
 			return 0;
@@ -5862,6 +10317,83 @@
 			WritePrivateProfileInt("Controls", "AllowBackgroundInput", (int)allowBackgroundInput, IniName);
 			return 0;
 
+		#ifdef X432R_CUSTOMRENDERER_ENABLED
+		case X432R_MENUITEM_CHANGERESOLUTION_X1:
+		case X432R_MENUITEM_CHANGERESOLUTION_X2:
+		case X432R_MENUITEM_CHANGERESOLUTION_X3:
+		case X432R_MENUITEM_CHANGERESOLUTION_X4:
+		{
+//			Lock lock(win_backbuffer_sync);
+			
+			u32 render_magnification = clamp<s32>( LOWORD(wParam) - X432R_MENUITEM_CHANGERESOLUTION_X1, 0, 3 ) + 1;
+			X432R::ChangeRenderMagnification(render_magnification);
+			break;
+		}
+		
+		#ifdef X432R_D3D_DISPLAYMETHOD_ENABLED
+		case X432R_MENUITEM_D3D_SHADER_DISABLED:
+		case X432R_MENUITEM_D3D_SHADER_SLOT1:
+		case X432R_MENUITEM_D3D_SHADER_SLOT2:
+		case X432R_MENUITEM_D3D_SHADER_SLOT3:
+		case X432R_MENUITEM_D3D_SHADER_SLOT4:
+		case X432R_MENUITEM_D3D_SHADER_SLOT5:
+		case X432R_MENUITEM_D3D_SHADER_SLOT6:
+		case X432R_MENUITEM_D3D_SHADER_SLOT7:
+		case X432R_MENUITEM_D3D_SHADER_SLOT8:
+		case X432R_MENUITEM_D3D_SHADER_SLOT9:
+		{
+			Lock lock(win_backbuffer_sync);
+			
+			X432R::d3dSelectedShaderSlot = clamp<s32>( LOWORD(wParam) - X432R_MENUITEM_D3D_SHADER_DISABLED, 0, X432R::d3dMaxShaderSlot );
+			WritePrivateProfileInt("X432R", "D3DSelectedShaderSlot", X432R::d3dSelectedShaderSlot, IniName);
+			X432R::d3dShaderSettingsChanged = true;
+			break;
+		}
+		
+		case X432R_MENUITEM_D3D_SHADEREFFECT_LEVEL1:
+		case X432R_MENUITEM_D3D_SHADEREFFECT_LEVEL2:
+		case X432R_MENUITEM_D3D_SHADEREFFECT_LEVEL3:
+		case X432R_MENUITEM_D3D_SHADEREFFECT_LEVEL4:
+		{
+			Lock lock(win_backbuffer_sync);
+			
+			X432R::d3dShaderEffectLevel = clamp<s32>( LOWORD(wParam) - X432R_MENUITEM_D3D_SHADEREFFECT_LEVEL1, 0, X432R::d3dSelectedShaderMaxEffectLevel );
+			WritePrivateProfileInt("X432R", "D3DShaderEffectLevel", X432R::d3dShaderEffectLevel, IniName);
+			break;
+		}
+		
+		case X432R_MENUITEM_D3D_SHADEREFFECT_MODE1:
+		case X432R_MENUITEM_D3D_SHADEREFFECT_MODE2:
+		case X432R_MENUITEM_D3D_SHADEREFFECT_MODE3:
+		case X432R_MENUITEM_D3D_SHADEREFFECT_MODE4:
+		{
+			Lock lock(win_backbuffer_sync);
+			
+			X432R::d3dShaderEffectMode = clamp<s32>( LOWORD(wParam) - X432R_MENUITEM_D3D_SHADEREFFECT_MODE1, 0, X432R::d3dSelectedShaderMaxEffectMode );
+			WritePrivateProfileInt("X432R", "D3DShaderEffectMode", X432R::d3dShaderEffectMode, IniName);
+			break;
+		}
+		
+		case X432R_MENUITEM_D3D_RELOADSHADER:
+		{
+			Lock lock(win_backbuffer_sync);
+			
+			X432R::d3dDisplayMethod.LoadShaderSettings();
+			break;
+		}
+		#endif
+		
+		#ifdef X432R_CUSTOMRENDERER_DEBUG
+		case X432R_MENUITEM_ENABLEDEBUGMODE:
+			X432R::debugModeEnabled = !X432R::debugModeEnabled;
+			break;
+		
+		case X432R_MENUITEM_ENABLEDEBUGMODE2:
+			X432R::debugModeEnabled2 = !X432R::debugModeEnabled2;
+			break;
+		#endif
+		#endif
+
 		case ID_DISPLAYMETHOD_VSYNC:
 			SetStyle(GetStyle()^DWS_VSYNC);
 			WritePrivateProfileInt("Video","VSync", (GetStyle()&DWS_VSYNC)?1:0, IniName);
@@ -6087,6 +10619,7 @@
 			SetRotate(hwnd, 270);
 			return 0;
 
+		#ifndef X432R_CUSTOMSCREENSCALING_ENABLED
 		case IDC_WINDOW1_5X:
 			windowSize=kScale1point5x;
 			ScaleScreen(windowSize, true);
@@ -6122,6 +10655,35 @@
 			ScaleScreen(windowSize, true);
 			WritePrivateProfileInt("Video","Window Size",windowSize,IniName);
 			break;
+		#else
+		case IDC_WINDOW1_5X:
+			ScaleScreen(1.5f, true);
+			break;
+			
+		case IDC_WINDOW2_5X:
+			ScaleScreen(2.5f, true);
+			break;
+			
+		case IDC_WINDOW1X:
+			ScaleScreen(1.0f, true);
+			break;
+			
+		case IDC_WINDOW2X:
+			ScaleScreen(2.0f, true);
+			break;
+			
+		case IDC_WINDOW3X:
+			ScaleScreen(3.0f, true);
+			break;
+			
+		case IDC_WINDOW4X:
+			ScaleScreen(4.0f, true);
+			break;
+			
+		case IDC_WINDOW5X:
+			ScaleScreen(5.0f, true);
+			break;
+		#endif
 
 		case IDC_VIEW_PADTOINTEGER:
 			PadToInteger = (!PadToInteger)?TRUE:FALSE;
@@ -6129,21 +10691,31 @@
 			UpdateWndRects(hwnd);
 			break;
 
+		#ifndef X432R_CUSTOMSCREENSCALING_ENABLED
 		case IDC_FORCERATIO:
 			ForceRatio = (!ForceRatio)?TRUE:FALSE;
 			if(ForceRatio)
 				FixAspectRatio();
+			
+			#ifdef X432R_MENUITEMMOD_ENABLED
+			UpdateWndRects(hwnd);
+			#endif
+			
 			WritePrivateProfileInt("Video","Window Force Ratio",ForceRatio,IniName);
 			break;
+		#endif
 
 		case IDM_DEFSIZE:
 			{
+				#ifndef X432R_CUSTOMSCREENSCALING_ENABLED
 				windowSize = 1;
+				#endif
 				ScaleScreen(1, true);
 			}
 			break;
 		case IDM_LOCKDOWN:
 			{
+				#ifndef X432R_MENUITEMMOD_ENABLED
 				RECT rc; 
 				GetClientRect(hwnd, &rc);
 
@@ -6152,8 +10724,145 @@
 				MainWindow->setClientSize(rc.right-rc.left, rc.bottom-rc.top);
 
 				WritePrivateProfileBool("Video", "Window Lockdown", (GetStyle()&DWS_LOCKDOWN)!=0, IniName);
+				#else
+				u32 window_style = GetStyle();
+				
+				RECT client_rect; 
+				GetClientRect(hwnd, &client_rect);
+				
+				if(window_style & DWS_NORESIZE)
+				{
+					window_style &= ~DWS_NORESIZE;
+					WritePrivateProfileBool("X432R", "NoResize", false, IniName);
 			}
+				
+				window_style ^= DWS_LOCKDOWN;
+				
+				SetStyle(window_style);
+				WritePrivateProfileBool("Video", "Window Lockdown", window_style & DWS_LOCKDOWN, IniName);
+				
+//				MainWindow->setClientSize(client_rect.right, client_rect.bottom);
+				MainWindow->setClientSize( client_rect.right, client_rect.bottom - MainWindowToolbar->GetHeight() );
+				UpdateWndRects(hwnd);
+				#endif
+			}
 			return 0;
+
+		#ifdef X432R_MENUITEMMOD_ENABLED
+		case X432R_MENUITEM_NORESIZE:
+			{
+				u32 window_style = GetStyle();
+				
+				RECT client_rect; 
+				GetClientRect(hwnd, &client_rect);
+				
+				if(window_style & DWS_LOCKDOWN)
+				{
+					window_style &= ~DWS_LOCKDOWN;
+					WritePrivateProfileBool("X432R", "Window Lockdown", false, IniName);
+				}
+				
+				window_style ^= DWS_NORESIZE;
+				
+				SetStyle(window_style);
+				WritePrivateProfileBool("X432R", "NoResize", window_style & DWS_NORESIZE, IniName);
+				
+//				MainWindow->setClientSize(client_rect.right, client_rect.bottom);
+				MainWindow->setClientSize( client_rect.right, client_rect.bottom - MainWindowToolbar->GetHeight() );
+				UpdateWndRects(hwnd);
+			}
+			return 0;
+		
+		case X432R_MENUITEM_SHOWMENUBAR_IN_FULLSCREEN:
+			X432R::showMenubarInFullScreen = !X432R::showMenubarInFullScreen;
+			WritePrivateProfileBool("X432R", "ShowMenubarInFullScreen", X432R::showMenubarInFullScreen, IniName);
+			break;
+		
+		case X432R_MENUITEM_SOFTRASTERIZER:
+			{
+				void HK_ToggleRasterizer(int, bool justPressed);
+				
+				HK_ToggleRasterizer(0, false);
+			}
+			break;
+		
+		case X432R_MENUITEM_SOUNDOUTPUT:
+			X432R::HK_ToggleSoundEnabledKeyDown(0, false);
+			break;
+		
+		case X432R_MENUITEM_CPUPOWERSAVING:
+			X432R::cpuPowerSavingEnabled = !X432R::cpuPowerSavingEnabled;
+			WritePrivateProfileBool("X432R", "CpuPowerSavingEnabled", X432R::cpuPowerSavingEnabled, IniName);
+			break;
+		
+		case X432R_MENUITEM_FASTFORWARDSPEED_0:
+		case X432R_MENUITEM_FASTFORWARDSPEED_1:
+		case X432R_MENUITEM_FASTFORWARDSPEED_2:
+		case X432R_MENUITEM_FASTFORWARDSPEED_3:
+		case X432R_MENUITEM_FASTFORWARDSPEED_4:
+			X432R::SetFastForwardSpeedSetting( LOWORD(wParam) - X432R_MENUITEM_FASTFORWARDSPEED_0 );
+			break;
+		
+		case X432R_MENUITEM_SLOWMOTIONSPEED_0:
+		case X432R_MENUITEM_SLOWMOTIONSPEED_1:
+		case X432R_MENUITEM_SLOWMOTIONSPEED_2:
+		case X432R_MENUITEM_SLOWMOTIONSPEED_3:
+		case X432R_MENUITEM_SLOWMOTIONSPEED_4:
+			X432R::SetSlowMotionSpeedSetting( LOWORD(wParam) - X432R_MENUITEM_SLOWMOTIONSPEED_0 );
+			break;
+		
+		case X432R_MENUITEM_SHOWCONSOLE:
+			{
+				gShowConsole = !gShowConsole;
+				
+				if(gShowConsole)
+				{
+					OpenConsole();			// Init debug console
+					ConsoleAlwaysTop(gConsoleTopmost);
+				}
+				else
+					CloseConsole();
+				
+				WritePrivateProfileBool("Console", "Show", gShowConsole, IniName);
+			}
+			return 0;
+		
+		#ifdef X432R_CUSTOMSCREENSCALING_ENABLED
+		case X432R_MENUITEM_SCREENSIZE_0:
+		case X432R_MENUITEM_SCREENSIZE_1:
+		case X432R_MENUITEM_SCREENSIZE_2:
+		case X432R_MENUITEM_SCREENSIZE_3:
+		case X432R_MENUITEM_SCREENSIZE_4:
+		case X432R_MENUITEM_SCREENSIZE_5:
+		case X432R_MENUITEM_SCREENSIZE_6:
+		case X432R_MENUITEM_SCREENSIZE_7:
+		case X432R_MENUITEM_SCREENSIZE_8:
+		case X432R_MENUITEM_SCREENSIZE_9:
+		case X432R_MENUITEM_SCREENSIZE_10:
+			X432R::SetSmallScreenSettingIndex( LOWORD(wParam) - X432R_MENUITEM_SCREENSIZE_0 );
+			return 0;
+		
+/*		#ifdef X432R_CUSTOMRENDERER_ENABLED
+		case X432R_MENUITEM_SCREENSIZE_AUTOSWAP:
+			X432R::smallScreen_AutoSwapEnabled = !X432R::smallScreen_AutoSwapEnabled;
+			WritePrivateProfileBool("X432R", "SmallScreen_AutoSwapEnabled", X432R::smallScreen_AutoSwapEnabled, IniName);
+			return 0;
+		#endif
+*/		
+		case X432R_MENUITEM_SCREENHORIZONTALALIGN_LEFT:
+		case X432R_MENUITEM_SCREENHORIZONTALALIGN_CENTER:
+		case X432R_MENUITEM_SCREENHORIZONTALALIGN_RIGHT:
+			X432R::SetSmallScreenOffset_Horizontal( LOWORD(wParam) - X432R_MENUITEM_SCREENHORIZONTALALIGN_LEFT );
+			return 0;
+		
+		case X432R_MENUITEM_SCREENVERTICALALIGN_TOP:
+		case X432R_MENUITEM_SCREENVERTICALALIGN_CENTER:
+		case X432R_MENUITEM_SCREENVERTICALALIGN_BOTTOM:
+			X432R::SetSmallScreenOffset_Vertical( LOWORD(wParam) - X432R_MENUITEM_SCREENVERTICALALIGN_TOP );
+			return 0;
+		#endif
+		#endif
+		
 		case IDM_ALWAYS_ON_TOP:
 			{
 				SetStyle(GetStyle()^DWS_ALWAYSONTOP);
@@ -6171,6 +10880,7 @@
 
 		case IDM_SHOWTOOLBAR:
 			{
+//				#ifndef X432R_MENUITEMMOD_ENABLED
 				bool maximized = IsZoomed(hwnd)==TRUE;
 				if(maximized) ShowWindow(hwnd,SW_NORMAL);
 
@@ -6185,7 +10895,15 @@
 				WritePrivateProfileBool("Display", "Show Toolbar", nowvisible, IniName);
 
 				if(maximized) ShowWindow(hwnd,SW_MAXIMIZE);
-			}
+/*				#else
+				MainWindowToolbar->Show( !MainWindowToolbar->Visible() );
+				
+				if( IsZoomed(hwnd) )
+					UpdateWndRects( MainWindow->getHWnd() );
+				else
+					ScaleScreen(windowSize, false);
+				#endif
+*/			}
 			return 0;
 
 		case IDM_AUTODETECTSAVETYPE_INTERNAL: 
@@ -6279,8 +10997,17 @@
 
 void Change3DCoreWithFallbackAndSave(int newCore)
 {
+	#ifndef X432R_CUSTOMRENDERER_ENABLED
+	if( (newCore < 0) || (newCore > GPU3D_OPENGL_OLD) )
+		newCore = GPU3D_SWRAST;
+	#else
+	if( (newCore < 0) || (newCore > GPU3D_SWRAST_X4) )
+		newCore = GPU3D_SWRAST;
+	#endif
+	
 	printf("Attempting change to 3d core to: %s\n",core3DList[newCore]->name);
 
+	#ifndef X432R_CUSTOMRENDERER_ENABLED
 	if(newCore == GPU3D_OPENGL_OLD)
 		goto TRY_OGL_OLD;
 
@@ -6314,6 +11041,55 @@
 DONE:
 	int gpu3dSaveValue = ((cur3DCore != GPU3D_NULL) ? cur3DCore : GPU3D_NULL_SAVED);
 	WritePrivateProfileInt("3D", "Renderer", gpu3dSaveValue, IniName);
+	#else
+	switch(newCore)
+	{
+		case GPU3D_NULL:
+			NDS_3D_ChangeCore(GPU3D_NULL);
+			break;
+		
+		case GPU3D_OPENGL_X2:
+		case GPU3D_OPENGL_X3:
+		case GPU3D_OPENGL_X4:
+		case GPU3D_SWRAST_X2:
+		case GPU3D_SWRAST_X3:
+		case GPU3D_SWRAST_X4:
+/*			if(video.currentfilter != video.NONE)
+			{
+				Lock lock (win_backbuffer_sync);
+				video.setfilter(video.NONE);
+				FilterUpdate( MainWindow->getHWnd() );
+			}
+*/			
+			// fall-through to GPU3D_OPENGL_3_2
+		
+		case GPU3D_OPENGL_3_2:
+			if( NDS_3D_ChangeCore(newCore) ) break;
+			
+			printf("falling back to 3d core: %s\n", core3DList[GPU3D_OPENGL_OLD]->name);
+			
+			// fall-through to GPU3D_OPENGL_OLD
+		
+		case GPU3D_OPENGL_OLD:
+			if( NDS_3D_ChangeCore(GPU3D_OPENGL_OLD) ) break;
+			
+			printf("falling back to 3d core: %s\n", core3DList[GPU3D_SWRAST]->name);
+			
+			// fall-through to default
+		
+		default:
+			NDS_3D_ChangeCore(GPU3D_SWRAST);
+			break;
+	}
+	
+	int gpu3dSaveValue = ( (cur3DCore != GPU3D_NULL) ? cur3DCore : GPU3D_NULL_SAVED );
+	
+//	WritePrivateProfileInt("3D", "Renderer", gpu3dSaveValue, IniName);
+	WritePrivateProfileInt("X432R", "Renderer", gpu3dSaveValue, IniName);
+	
+	if( (gpu3D != NULL) && (osd != NULL) )
+		osd->addLine("%s", gpu3D->name);
+	#endif
 }
 
 LRESULT CALLBACK HUDFontSettingsDlgProc(HWND hw, UINT msg, WPARAM wp, LPARAM lp)
@@ -6371,6 +11147,11 @@
 				ComboBox_AddString(GetDlgItem(hw, IDC_3DCORE), core3DList[i]->name);
 			}
 			ComboBox_SetCurSel(GetDlgItem(hw, IDC_3DCORE), cur3DCore);
+
+			#ifdef X432R_LOWQUALITYMODE_TEST
+			CheckDlgButton(hw, X432R_CHECKBOX_LOWQUALITY_MSAA, X432R::lowQualityMsaaEnabled);
+			CheckDlgButton(hw, X432R_CHECKBOX_LOWQUALITY_ALPHABLEND, X432R::lowQualityAlphaBlendEnabled);
+			#endif
 		}
 		return TRUE;
 
@@ -6389,6 +11170,13 @@
 					CommonSettings.GFX3D_Zelda_Shadow_Depth_Hack  = GetDlgItemInt(hw,IDC_ZELDA_SHADOW_DEPTH_HACK,NULL,FALSE);
 					CommonSettings.GFX3D_TXTHack = IsDlgCheckboxChecked(hw,IDC_TXTHACK);
 
+					#ifdef X432R_LOWQUALITYMODE_TEST
+					X432R::lowQualityMsaaEnabled = IsDlgCheckboxChecked(hw, X432R_CHECKBOX_LOWQUALITY_MSAA) && CommonSettings.GFX3D_Renderer_Multisample;
+					X432R::lowQualityAlphaBlendEnabled = IsDlgCheckboxChecked(hw, X432R_CHECKBOX_LOWQUALITY_ALPHABLEND);
+					WritePrivateProfileBool("X432R", "LowQualityMsaaEnabled", X432R::lowQualityMsaaEnabled, IniName);
+					WritePrivateProfileBool("X432R", "LowQualityAlphaBlendEnabled", X432R::lowQualityAlphaBlendEnabled, IniName);
+					#endif
+
 					Change3DCoreWithFallbackAndSave(ComboBox_GetCurSel(GetDlgItem(hw, IDC_3DCORE)));
 					WritePrivateProfileBool("3D", "HighResolutionInterpolateColor", CommonSettings.GFX3D_HighResolutionInterpolateColor, IniName);
 					WritePrivateProfileBool("3D", "EnableEdgeMark", CommonSettings.GFX3D_EdgeMark, IniName);
@@ -7020,6 +11808,11 @@
 					CommonSettings.spu_advanced = IsDlgCheckboxChecked(hDlg,IDC_SPU_ADVANCED);
 					WritePrivateProfileBool("Sound","SpuAdvanced",CommonSettings.spu_advanced,IniName);
 
+					#ifdef X432R_MENUITEMMOD_ENABLED
+					X432R::soundOutputEnabled = true;
+					WritePrivateProfileBool("X432R","SoundOutputEnabled", true, IniName);
+					#endif
+
 					return TRUE;
 				}
 			case IDCANCEL:
Index: windows/main.h
===================================================================
--- windows/main.h	(revision 5164)
+++ windows/main.h	(working copy)
@@ -24,6 +24,22 @@
 #include "../types.h"
 #include "CWindow.h"
 
+
+//---CUSTOM--->
+#include "X432R_BuildSwitch.h"
+#include <locale.h>
+
+#ifndef X432R_D3D_DISPLAYMETHOD_ENABLED
+namespace X432R
+{
+//	GLuint GetScreenTexture();
+	u32 GetScreenTexture();
+	void DeleteScreenTexture();
+}
+#endif
+//<---CUSTOM---
+
+
 extern WINCLASS	*MainWindow;
 extern HINSTANCE hAppInst;
 extern HMENU mainMenu; //Holds handle to the main DeSmuME menu
@@ -57,6 +73,16 @@
 #define GPU3D_SWRAST 2
 #define GPU3D_OPENGL_OLD 3
 
+#ifdef X432R_CUSTOMRENDERER_ENABLED
+#define GPU3D_OPENGL_X2 4
+#define GPU3D_OPENGL_X3 5
+#define GPU3D_OPENGL_X4 6
+
+#define GPU3D_SWRAST_X2 7
+#define GPU3D_SWRAST_X3 8
+#define GPU3D_SWRAST_X4 9
+#endif
+
 static const int LANGUAGE_ENGLISH = 0;
 static const int LANGUAGE_FRENCH = 1;
 static const int LANGUAGE_CHINESE = 3;
Index: windows/OpenArchive.cpp
===================================================================
--- windows/OpenArchive.cpp	(revision 5164)
+++ windows/OpenArchive.cpp	(working copy)
@@ -31,6 +31,14 @@
 #include "resource.h"
 #include "main.h"
 
+//---CUSTOM--->
+#include "X432R_BuildSwitch.h"
+
+#ifdef X432R_FILEPATHMOD_ENABLED
+#include <mbstring.h>
+#endif
+//<---CUSTOM---
+
 static char Str_Tmp[1024];
 
 LRESULT CALLBACK ArchiveFileChooser(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
@@ -404,7 +412,13 @@
 	strcpy(LogicalName, Name);
 	strcpy(PhysicalName, Name);
 	strcpy(ArchivePaths, Name);
+	
+	#ifndef X432R_FILEPATHMOD_ENABLED
 	char* bar = strchr(ArchivePaths, '|');
+	#else
+	char *bar = (char *)_mbschr( (unsigned char *)ArchivePaths, '|' );
+	#endif
+	
 	if(bar)
 	{
 		PhysicalName[bar - ArchivePaths] = 0; // doesn't belong in the physical name
@@ -425,7 +439,12 @@
 			bool forceManual = false;
 			if(bar && *bar) // try following the in-archive part of the logical path
 			{
+				#ifndef X432R_FILEPATHMOD_ENABLED
 				char* bar2 = strchr(bar, '|');
+				#else
+				char *bar2 = (char *)_mbschr( (unsigned char *)bar, '|' );
+				#endif
+				
 				if(bar2) *bar2++ = 0;
 				int numItems = archive.GetNumItems();
 				for(int i = 0; i < numItems; i++)
Index: windows/recentroms.h
===================================================================
--- windows/recentroms.h	(revision 5164)
+++ windows/recentroms.h	(working copy)
@@ -24,7 +24,12 @@
 
 #include "main.h"
 
+#ifndef X432R_MENUITEMMOD_ENABLED
 static const unsigned int MAX_RECENT_ROMS = 10;	//To change the recent rom max, simply change this number
+#else
+static const unsigned int MAX_RECENT_ROMS = 30;
+#endif
+
 static const unsigned int recentRoms_clearid = IDM_RECENT_RESERVED0;			// ID for the Clear recent ROMs item
 static const unsigned int recentRoms_baseid = IDM_RECENT_RESERVED1;			//Base identifier for the recent ROMs items
 
Index: windows/resource.h
===================================================================
--- windows/resource.h	(revision 5164)
+++ windows/resource.h	(working copy)
@@ -1070,3 +1070,96 @@
 #define _APS_NEXT_SYMED_VALUE           101
 #endif
 #endif
+
+
+//---CUSTOM--->
+#include "X432R_BuildSwitch.h"
+
+#ifdef X432R_CUSTOMRENDERER_ENABLED
+	#define X432R_MENUITEM_CHANGERESOLUTION_X1				65000
+	#define X432R_MENUITEM_CHANGERESOLUTION_X2				65001
+	#define X432R_MENUITEM_CHANGERESOLUTION_X3				65002
+	#define X432R_MENUITEM_CHANGERESOLUTION_X4				65003
+	
+	#ifdef X432R_D3D_DISPLAYMETHOD_ENABLED
+	#define X432R_MENUITEM_D3D_SHADER_DISABLED				65010
+	#define X432R_MENUITEM_D3D_SHADER_SLOT1					65011
+	#define X432R_MENUITEM_D3D_SHADER_SLOT2					65012
+	#define X432R_MENUITEM_D3D_SHADER_SLOT3					65013
+	#define X432R_MENUITEM_D3D_SHADER_SLOT4					65014
+	#define X432R_MENUITEM_D3D_SHADER_SLOT5					65015
+	#define X432R_MENUITEM_D3D_SHADER_SLOT6					65016
+	#define X432R_MENUITEM_D3D_SHADER_SLOT7					65017
+	#define X432R_MENUITEM_D3D_SHADER_SLOT8					65018
+	#define X432R_MENUITEM_D3D_SHADER_SLOT9					65019
+	
+	#define X432R_MENUITEM_D3D_SHADEREFFECT_LEVEL1			65020
+	#define X432R_MENUITEM_D3D_SHADEREFFECT_LEVEL2			65021
+	#define X432R_MENUITEM_D3D_SHADEREFFECT_LEVEL3			65022
+	#define X432R_MENUITEM_D3D_SHADEREFFECT_LEVEL4			65023
+	
+	#define X432R_MENUITEM_D3D_SHADEREFFECT_MODE1			65024
+	#define X432R_MENUITEM_D3D_SHADEREFFECT_MODE2			65025
+	#define X432R_MENUITEM_D3D_SHADEREFFECT_MODE3			65026
+	#define X432R_MENUITEM_D3D_SHADEREFFECT_MODE4			65027
+	
+	#define X432R_MENUITEM_D3D_RELOADSHADER					65028
+	#endif
+	
+	#ifdef X432R_LOWQUALITYMODE_TEST
+	#define X432R_CHECKBOX_LOWQUALITY_MSAA					65030
+	#define X432R_CHECKBOX_LOWQUALITY_ALPHABLEND			65031
+	#endif
+	
+	#ifdef X432R_CUSTOMRENDERER_DEBUG
+	#define X432R_MENUITEM_ENABLEDEBUGMODE					65040
+	#define X432R_MENUITEM_ENABLEDEBUGMODE2					65041
+	#endif
+#endif
+
+#ifdef X432R_MENUITEMMOD_ENABLED
+	#define X432R_MENUITEM_SOFTRASTERIZER					65050
+	#define X432R_MENUITEM_SOUNDOUTPUT						65051
+	#define X432R_MENUITEM_CPUPOWERSAVING					65052
+	#define X432R_MENUITEM_NORESIZE							65053
+	#define X432R_MENUITEM_SHOWMENUBAR_IN_FULLSCREEN		65054
+	#define X432R_MENUITEM_SHOWCONSOLE						65055
+	
+	#define X432R_MENUITEM_FASTFORWARDSPEED_0				65060
+	#define X432R_MENUITEM_FASTFORWARDSPEED_1				65061
+	#define X432R_MENUITEM_FASTFORWARDSPEED_2				65062
+	#define X432R_MENUITEM_FASTFORWARDSPEED_3				65063
+	#define X432R_MENUITEM_FASTFORWARDSPEED_4				65064
+	#define X432R_MENUITEM_SLOWMOTIONSPEED_0				65065
+	#define X432R_MENUITEM_SLOWMOTIONSPEED_1				65066
+	#define X432R_MENUITEM_SLOWMOTIONSPEED_2				65067
+	#define X432R_MENUITEM_SLOWMOTIONSPEED_3				65068
+	#define X432R_MENUITEM_SLOWMOTIONSPEED_4				65069
+	
+	#ifdef X432R_CUSTOMSCREENSCALING_ENABLED
+	#define X432R_MENUITEM_SCREENSIZE_0						65070
+	#define X432R_MENUITEM_SCREENSIZE_1						65071
+	#define X432R_MENUITEM_SCREENSIZE_2						65072
+	#define X432R_MENUITEM_SCREENSIZE_3						65073
+	#define X432R_MENUITEM_SCREENSIZE_4						65074
+	#define X432R_MENUITEM_SCREENSIZE_5						65075
+	#define X432R_MENUITEM_SCREENSIZE_6						65076
+	#define X432R_MENUITEM_SCREENSIZE_7						65077
+	#define X432R_MENUITEM_SCREENSIZE_8						65078
+	#define X432R_MENUITEM_SCREENSIZE_9						65079
+	#define X432R_MENUITEM_SCREENSIZE_10					65080
+	
+//	#define X432R_MENUITEM_SCREENSIZE_AUTOSWAP				65081
+	
+	#define X432R_MENUITEM_SCREENHORIZONTALALIGN_LEFT		65082
+	#define X432R_MENUITEM_SCREENHORIZONTALALIGN_CENTER		65083
+	#define X432R_MENUITEM_SCREENHORIZONTALALIGN_RIGHT		65084
+	
+	#define X432R_MENUITEM_SCREENVERTICALALIGN_TOP			65085
+	#define X432R_MENUITEM_SCREENVERTICALALIGN_CENTER		65086
+	#define X432R_MENUITEM_SCREENVERTICALALIGN_BOTTOM		65087
+	#endif
+#endif
+
+//<---CUSTOM---
+
Index: windows/resources.rc
===================================================================
--- windows/resources.rc	(revision 5164)
+++ windows/resources.rc	(working copy)
@@ -112,6 +112,7 @@
     PUSHBUTTON      "&Cancel",IDCANCEL,127,94,50,16
 END
 
+#ifndef X432R_LOWQUALITYMODE_TEST
 IDD_3DSETTINGS DIALOGEX 0, 0, 190, 252
 STYLE DS_SETFONT | DS_MODALFRAME | WS_POPUP | WS_CAPTION | WS_SYSMENU
 CAPTION "3D settings"
@@ -138,6 +139,37 @@
     CONTROL         "Enable Anti-Aliasing",IDC_3DSETTINGS_ANTIALIASING,
                     "Button",BS_AUTOCHECKBOX | WS_TABSTOP,13,201,78,10
 END
+#else
+IDD_3DSETTINGS DIALOGEX 0, 0, 190, 280
+STYLE DS_SETFONT | DS_MODALFRAME | WS_POPUP | WS_CAPTION | WS_SYSMENU
+CAPTION "3D settings"
+FONT 8, "MS Sans Serif", 0, 0, 0x0
+BEGIN
+    DEFPUSHBUTTON   "OK",IDOK,83,260,50,14
+    PUSHBUTTON      "Cancel",IDCANCEL,137,260,50,14
+    PUSHBUTTON      "Default",IDC_DEFAULT,2,260,50,14
+    GROUPBOX        "Renderer:",IDC_STATIC,7,7,174,39
+    COMBOBOX        IDC_3DCORE,15,23,153,138,CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
+    CONTROL         "Unrealistically High-Precision Color Interpolation",IDC_INTERPOLATECOLOR,
+                    "Button",BS_AUTOCHECKBOX | WS_TABSTOP,13,64,165,10
+    GROUPBOX        "SoftRasterizer Options",IDC_STATIC,7,52,176,114
+    CONTROL         "Enable Edge Marking",IDC_3DSETTINGS_EDGEMARK,"Button",BS_AUTOCHECKBOX | WS_TABSTOP,13,76,84,10
+    CONTROL         "Enable Fog",IDC_3DSETTINGS_FOG,"Button",BS_AUTOCHECKBOX | WS_TABSTOP,13,88,52,10
+    CONTROL         "Enable Textures",IDC_3DSETTINGS_TEXTURE,"Button",BS_AUTOCHECKBOX | WS_TABSTOP,13,100,67,10
+    LTEXT           "Depth Comparison Threshold : \n  -0=normal behavior (recommended) \n  -bigger value can help Zelda PH/ST shadow issue",ID_LABEL_ZELDA_SHADOW_DEPTH_HACK,15,113,165,35
+    EDITTEXT        IDC_ZELDA_SHADOW_DEPTH_HACK,109,109,44,12
+    LTEXT           "Fixes some graphical bugs involving lines, but causes some other bugs. Not many games use lines.",ID_LABEL_ZELDA_SHADOW_DEPTH_HACK2,17,182,170,19
+    CONTROL         "Enable Line Hack",IDC_3DSETTINGS_LINEHACK,"Button",BS_AUTOCHECKBOX | WS_TABSTOP,13,170,73,10
+    LTEXT           "Fixes text bugs in some games.(e.g. Etrian Odyssey)",ID_LABEL_TXTHACK1,15,153,165,11
+    CONTROL         "Enable TXT Hack",IDC_TXTHACK,"Button",BS_AUTOCHECKBOX | WS_TABSTOP,13,141,73,10
+    LTEXT           "Reduces jagged edges on 3D objects. Only works in OpenGL renderer.",IDC_3DSETTINGS_ANTIALIASING1,17,211,169,19
+    CONTROL         "Enable Anti-Aliasing",IDC_3DSETTINGS_ANTIALIASING,
+                    "Button",BS_AUTOCHECKBOX | WS_TABSTOP,13,201,78,10
+	
+	CONTROL			"X432R: Low-Quality Anti-Alias", X432R_CHECKBOX_LOWQUALITY_MSAA, "Button", BS_AUTOCHECKBOX | WS_TABSTOP, 13, 232, 150, 10
+	CONTROL			"X432R: Low-Quality Alpha-Blend", X432R_CHECKBOX_LOWQUALITY_ALPHABLEND, "Button", BS_AUTOCHECKBOX | WS_TABSTOP, 13, 245, 150, 10
+END
+#endif
 
 IDD_ABOUT_BOX DIALOGEX 0, 0, 268, 198
 STYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | DS_CENTER | WS_POPUP | WS_CAPTION
@@ -1572,8 +1604,10 @@
             MENUITEM SEPARATOR
             MENUITEM "Top first (default)",         ID_LCDS_NOSWAP
             MENUITEM "Bottom first",                ID_LCDS_SWAP
+			#ifndef X432R_CUSTOMSCREENSCALING_ENABLED
             MENUITEM "Main screen first",           ID_LCDS_MAINGPU
             MENUITEM "Sub screen first",            ID_LCDS_SUBGPU
+			#endif
         END
         POPUP "&Rotation"
         BEGIN
@@ -1594,7 +1628,38 @@
             MENUITEM SEPARATOR
             MENUITEM "&Always On Top",              IDM_ALWAYS_ON_TOP
             MENUITEM "&Lockdown",                   IDM_LOCKDOWN
+			#ifdef X432R_MENUITEMMOD_ENABLED
+			MENUITEM "&No Resize",					X432R_MENUITEM_NORESIZE
+			#endif
         END
+		#ifdef X432R_CUSTOMSCREENSCALING_ENABLED
+		POPUP "&Screen Size"
+		BEGIN
+			MENUITEM "100% : 50%",					X432R_MENUITEM_SCREENSIZE_0
+			MENUITEM "100% : 60%",					X432R_MENUITEM_SCREENSIZE_1
+			MENUITEM "100% : 70%",					X432R_MENUITEM_SCREENSIZE_2
+			MENUITEM "100% : 80%",					X432R_MENUITEM_SCREENSIZE_3
+			MENUITEM "100% : 90%",					X432R_MENUITEM_SCREENSIZE_4
+			MENUITEM "100% : 100%",					X432R_MENUITEM_SCREENSIZE_5
+			MENUITEM "90% : 100%",					X432R_MENUITEM_SCREENSIZE_6
+			MENUITEM "80% : 100%",					X432R_MENUITEM_SCREENSIZE_7
+			MENUITEM "70% : 100%",					X432R_MENUITEM_SCREENSIZE_8
+			MENUITEM "60% : 100%",					X432R_MENUITEM_SCREENSIZE_9
+			MENUITEM "50% : 100%",					X432R_MENUITEM_SCREENSIZE_10
+			MENUITEM SEPARATOR
+/*			#ifdef X432R_CUSTOMRENDERER_ENABLED
+			MENUITEM "Auto Swap",					X432R_MENUITEM_SCREENSIZE_AUTOSWAP
+			MENUITEM SEPARATOR
+			#endif
+*/			MENUITEM "Horizontal Align: Left",		X432R_MENUITEM_SCREENHORIZONTALALIGN_LEFT
+			MENUITEM "Horizontal Align: Center",	X432R_MENUITEM_SCREENHORIZONTALALIGN_CENTER
+			MENUITEM "Horizontal Align: Right",		X432R_MENUITEM_SCREENHORIZONTALALIGN_RIGHT
+			MENUITEM SEPARATOR
+			MENUITEM "Vertical Align: Top",			X432R_MENUITEM_SCREENVERTICALALIGN_TOP
+			MENUITEM "Vertical Align: Center",		X432R_MENUITEM_SCREENVERTICALALIGN_CENTER
+			MENUITEM "Vertical Align: Bottom",		X432R_MENUITEM_SCREENVERTICALALIGN_BOTTOM
+		END
+		#endif
         POPUP "Screen &Gap"
         BEGIN
             MENUITEM "&None\t(0 px)",               IDM_SCREENSEP_NONE
@@ -1633,10 +1698,15 @@
             MENUITEM "4xBRZ",                       IDM_RENDER_4XBRZ
             MENUITEM "5xBRZ",                       IDM_RENDER_5XBRZ
         END
-        MENUITEM "&Maintain Asect Ratio",       IDC_FORCERATIO
+		#ifndef X432R_CUSTOMSCREENSCALING_ENABLED
+        MENUITEM "&Maintain Aspect Ratio",      IDC_FORCERATIO
+		#endif
         MENUITEM "&Pad To Integer",             IDC_VIEW_PADTOINTEGER
         MENUITEM SEPARATOR
         MENUITEM "Show &Toolbar",               IDM_SHOWTOOLBAR
+		#ifdef X432R_MENUITEMMOD_ENABLED
+		MENUITEM "Show Menubar in Full-Screen Mode",	X432R_MENUITEM_SHOWMENUBAR_IN_FULLSCREEN
+		#endif
         MENUITEM SEPARATOR
         POPUP "&HUD"
         BEGIN
@@ -1697,15 +1767,97 @@
         BEGIN
             MENUITEM "DirectDraw &HW",              ID_DISPLAYMETHOD_DIRECTDRAWHW
             MENUITEM "DirectDraw &SW",              ID_DISPLAYMETHOD_DIRECTDRAWSW
+			#ifndef X432R_D3D_DISPLAYMETHOD_ENABLED
             MENUITEM SEPARATOR
             MENUITEM "&OpenGL",                     ID_DISPLAYMETHOD_OPENGL
             MENUITEM "&Filter",                     ID_DISPLAYMETHOD_FILTER
             MENUITEM SEPARATOR
             MENUITEM "&VSync",                      ID_DISPLAYMETHOD_VSYNC
+			#else
+			MENUITEM "&VSync",						ID_DISPLAYMETHOD_VSYNC
+			MENUITEM SEPARATOR
+			MENUITEM "Direct&3D",					ID_DISPLAYMETHOD_OPENGL
+			MENUITEM "&Filter",						ID_DISPLAYMETHOD_FILTER
+			#endif
         END
+		#if defined(X432R_MENUITEMMOD_ENABLED) || defined(X432R_CUSTOMRENDERER_ENABLED)
+		MENUITEM SEPARATOR
+		#endif
+		#ifdef X432R_MENUITEMMOD_ENABLED
+		MENUITEM "SoftRasterizer",				X432R_MENUITEM_SOFTRASTERIZER
+		#endif
+		#ifdef X432R_CUSTOMRENDERER_ENABLED
+		POPUP "High-Resolution 3D Renderer"
+		BEGIN
+			MENUITEM "Disabled (256x192)",				X432R_MENUITEM_CHANGERESOLUTION_X1
+			MENUITEM "X2 (512x384)",					X432R_MENUITEM_CHANGERESOLUTION_X2
+			MENUITEM "X3 (768x576)",					X432R_MENUITEM_CHANGERESOLUTION_X3
+			MENUITEM "X4 (1024x768)",					X432R_MENUITEM_CHANGERESOLUTION_X4
+			#ifdef X432R_CUSTOMRENDERER_DEBUG
+			MENUITEM SEPARATOR
+			MENUITEM "Debug Mode"						X432R_MENUITEM_ENABLEDEBUGMODE
+			MENUITEM "Debug Mode 2"						X432R_MENUITEM_ENABLEDEBUGMODE2
+			#endif
     END
+		#ifdef X432R_D3D_DISPLAYMETHOD_ENABLED
+		POPUP "Post-Processing Shader"
+		BEGIN
+			MENUITEM "Disabled"						X432R_MENUITEM_D3D_SHADER_DISABLED
+			MENUITEM "Slot 1"						X432R_MENUITEM_D3D_SHADER_SLOT1
+			MENUITEM "Slot 2"						X432R_MENUITEM_D3D_SHADER_SLOT2
+			MENUITEM "Slot 3"						X432R_MENUITEM_D3D_SHADER_SLOT3
+			MENUITEM "Slot 4"						X432R_MENUITEM_D3D_SHADER_SLOT4
+			MENUITEM "Slot 5"						X432R_MENUITEM_D3D_SHADER_SLOT5
+			MENUITEM "Slot 6"						X432R_MENUITEM_D3D_SHADER_SLOT6
+			MENUITEM "Slot 7"						X432R_MENUITEM_D3D_SHADER_SLOT7
+			MENUITEM "Slot 8"						X432R_MENUITEM_D3D_SHADER_SLOT8
+			MENUITEM "Slot 9"						X432R_MENUITEM_D3D_SHADER_SLOT9
+			MENUITEM SEPARATOR
+			MENUITEM "Effect Level 1"				X432R_MENUITEM_D3D_SHADEREFFECT_LEVEL1
+			MENUITEM "Effect Level 2"				X432R_MENUITEM_D3D_SHADEREFFECT_LEVEL2
+			MENUITEM "Effect Level 3"				X432R_MENUITEM_D3D_SHADEREFFECT_LEVEL3
+			MENUITEM "Effect Level 4"				X432R_MENUITEM_D3D_SHADEREFFECT_LEVEL4
+			MENUITEM SEPARATOR
+			MENUITEM "Effect Mode 1"				X432R_MENUITEM_D3D_SHADEREFFECT_MODE1
+			MENUITEM "Effect Mode 2"				X432R_MENUITEM_D3D_SHADEREFFECT_MODE2
+			MENUITEM "Effect Mode 3"				X432R_MENUITEM_D3D_SHADEREFFECT_MODE3
+			MENUITEM "Effect Mode 4"				X432R_MENUITEM_D3D_SHADEREFFECT_MODE4
+			MENUITEM SEPARATOR
+			MENUITEM "Reload Shader Settings"		X432R_MENUITEM_D3D_RELOADSHADER
+		END
+		#endif
+		#endif
+		#ifdef X432R_MENUITEMMOD_ENABLED
+		MENUITEM SEPARATOR
+		MENUITEM "Sound Output",					X432R_MENUITEM_SOUNDOUTPUT
+		MENUITEM "CPU Power Saving",				X432R_MENUITEM_CPUPOWERSAVING
+		POPUP "Fast-Forward/Slow-Motion Speed Limit"
+		BEGIN
+			MENUITEM "Fast: Unlimited"					X432R_MENUITEM_FASTFORWARDSPEED_0
+			MENUITEM "Fast: 180 fps"					X432R_MENUITEM_FASTFORWARDSPEED_1
+			MENUITEM "Fast: 150 fps"					X432R_MENUITEM_FASTFORWARDSPEED_2
+			MENUITEM "Fast: 120 fps"					X432R_MENUITEM_FASTFORWARDSPEED_3
+			MENUITEM "Fast: 90 fps"						X432R_MENUITEM_FASTFORWARDSPEED_4
+			MENUITEM SEPARATOR
+			MENUITEM "Slow: 50 fps"						X432R_MENUITEM_SLOWMOTIONSPEED_0
+			MENUITEM "Slow: 40 fps"						X432R_MENUITEM_SLOWMOTIONSPEED_1
+			MENUITEM "Slow: 30 fps"						X432R_MENUITEM_SLOWMOTIONSPEED_2
+			MENUITEM "Slow: 20 fps"						X432R_MENUITEM_SLOWMOTIONSPEED_3
+			MENUITEM "Slow: 10 fps"						X432R_MENUITEM_SLOWMOTIONSPEED_4
+		END
+		#endif
+    END
     POPUP "&Tools"
     BEGIN
+		#ifdef X432R_MENUITEMMOD_ENABLED
+		MENUITEM "Disable &Cheats",				IDM_CHEATS_DISABLE
+		MENUITEM "Cheats &List",				IDM_CHEATS_LIST, INACTIVE
+		MENUITEM "Cheats &Search",				IDM_CHEATS_SEARCH, INACTIVE
+		MENUITEM "RAM Watch...",				ID_RAM_WATCH
+		MENUITEM "RAM Search...",				ID_RAM_SEARCH
+		MENUITEM SEPARATOR
+		#endif
+		
         MENUITEM "&Disassembler",               IDM_DISASSEMBLER
         MENUITEM "View &Memory",                IDM_MEMORY
         MENUITEM "View &Registers",             IDM_IOREG
@@ -1718,7 +1870,15 @@
         MENUITEM "View &Sound State",           IDM_SOUND_VIEW
         MENUITEM "View Nitro&FS",               ID_TOOLS_VIEWFSNITRO
         MENUITEM SEPARATOR
+		
+		#ifdef X432R_MENUITEMMOD_ENABLED
+		MENUITEM "Show Console",				X432R_MENUITEM_SHOWCONSOLE
+		MENUITEM "Console Always On Top",		IDM_CONSOLE_ALWAYS_ON_TOP
+		#else
         MENUITEM "&Console Always On Top",      IDM_CONSOLE_ALWAYS_ON_TOP
+		#endif
+		
+		#ifndef X432R_MENUITEMMOD_ENABLED
         POPUP "&Cheats"
         BEGIN
             MENUITEM "&List",                       IDM_CHEATS_LIST, INACTIVE
@@ -1728,6 +1888,8 @@
         END
         MENUITEM "RAM Watch...",                ID_RAM_WATCH
         MENUITEM "RAM Search...",               ID_RAM_SEARCH
+		#endif
+		
         MENUITEM SEPARATOR
         POPUP "&View Layers"
         BEGIN
Index: windows/sndxa2.cpp
===================================================================
--- windows/sndxa2.cpp	(revision 5164)
+++ windows/sndxa2.cpp	(working copy)
@@ -22,6 +22,12 @@
 #include "../types.h"
 #include "windriver.h"
 
+
+//---CUSTOM--->
+#include "X432R_BuildSwitch.h"
+//<---CUSTOM---
+
+
 int SNDXA2Init(int buffersize);
 void SNDXA2DeInit();
 void PushBuffer(u8 *pAudioData,u32 AudioBytes);
@@ -89,6 +95,11 @@
 			SPU_Emulate_user();
 		}
 		WaitForSingleObject(bufferReadyEvent,1000);
+		
+		#ifdef X432R_MENUITEMMOD_ENABLED
+		if(X432R::cpuPowerSavingEnabled)
+			Sleep(1);	// WaitForSingleObject()はCPU使用率を下げる役には立たないのでSleep()を実行してしまう
+		#endif
 	}
 	SetEvent(threadQuitEvent);
 	return 0;
Index: windows/throttle.cpp
===================================================================
--- windows/throttle.cpp	(revision 5164)
+++ windows/throttle.cpp	(working copy)
@@ -259,3 +259,15 @@
 }
 
 
+#ifdef X432R_MENUITEMMOD_ENABLED
+namespace X432R
+{
+	void SetTargetFps(const float target_fps)
+	{
+		const float scale = target_fps / 60.0f;
+		
+		desiredfps = core_desiredfps * scale;
+		desiredspf = 65536.0f / desiredfps;
+	}
+}
+#endif
Index: windows/winutil.cpp
===================================================================
--- windows/winutil.cpp	(revision 5164)
+++ windows/winutil.cpp	(working copy)
@@ -25,6 +25,11 @@
 #include <ShlObj.h>
 
 
+//---CUSTOM--->
+#include "X432R_BuildSwitch.h"
+//<---CUSTOM---
+
+
 char IniName[MAX_PATH];
 
 char* _hack_alternateModulePath;
@@ -33,8 +38,8 @@
 static char vPath[MAX_PATH*2], *szPath;
 
 void GetINIPath()
-{   
-
+{
+	#ifndef X432R_FILEPATHMOD_ENABLED
 	bool useModulePath = true;
 
 	//check if desmume is running from the temp directory.
@@ -87,6 +92,41 @@
 	}
 
 	FCEUD_MakePathDirs(IniName);
+	#else
+	std::string path, filename;
+	
+	{
+		char buffer_fullpath[MAX_PATH] = {0};
+		char buffer_filename[MAX_PATH] = {0};
+		char buffer_driveletter[MAX_PATH] = {0};
+		char buffer_directorypath[MAX_PATH] = {0};
+		
+		GetModuleFileName( NULL, buffer_filename, sizeof(buffer_filename) );								// exeのフルパスを取得
+		GetFullPathName( buffer_filename, sizeof(buffer_fullpath), buffer_fullpath, NULL );					// 相対パスが含まれる可能性があるため絶対パスに変換
+		_splitpath(buffer_fullpath, buffer_driveletter, buffer_directorypath, buffer_filename, NULL);		// パスを分割してexeファイル名(拡張子なし)を取得
+		
+		path = (std::string)buffer_driveletter + (std::string)buffer_directorypath;
+		filename = (std::string)buffer_filename + ".ini";
+	}
+	
+	u32 length = filename.length();
+	
+	if( ( path.length() + length ) < MAX_PATH )
+		path += filename;
+	
+	else if( ( strlen(".\\") + length ) < MAX_PATH )
+		path = ".\\" + filename;
+	
+	else
+		path.clear();
+	
+	memset( IniName, 0, sizeof(IniName) );
+	
+	length = path.length();
+	
+	if(length > 0)
+		strncpy(IniName, path.c_str(), length);
+	#endif
 }
 
 void PreventScreensaver()
Index: windows/X432R_BuildSwitch.h
===================================================================
--- windows/X432R_BuildSwitch.h	(revision 0)
+++ windows/X432R_BuildSwitch.h	(working copy)
@@ -0,0 +1,205 @@
+/*
+	Copyright (C) 2009-2010 DeSmuME team
+
+	This file is free software: you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation, either version 2 of the License, or
+	(at your option) any later version.
+
+	This file is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with the this software.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+
+// Author: yolky-nine
+
+
+#ifndef X432R_BUILDSWITCH_H_INCLUDED
+#define X432R_BUILDSWITCH_H_INCLUDED
+
+#include <cmath>
+#include <string>
+#include <assert.h>
+#include "../types.h"
+
+
+template <typename TYPE>
+inline TYPE clamp(const TYPE value, const TYPE min, const TYPE max)
+{
+	assert(min <= max);
+	
+	if(value < min) return min;
+	if(value > max) return max;
+	
+	return value;
+}
+
+
+// 高解像度3Dレンダリングを有効化
+#define X432R_CUSTOMRENDERER_ENABLED
+
+// タッチ入力関係の変更を有効化
+#define X432R_TOUCHINPUT_ENABLED
+
+// メニュー関係の変更を有効化
+#define X432R_MENUITEMMOD_ENABLED
+
+// ファイルパス関係の変更を有効化
+#define X432R_FILEPATHMOD_ENABLED
+
+
+namespace X432R
+{
+	//--- 高解像度3Dレンダリング ---
+	#ifdef X432R_CUSTOMRENDERER_ENABLED
+		// 3D Renderer
+		#define X432R_CUSTOMSOFTRASTENGINE_ENABLED			// ok
+		#define X432R_CUSTOMRENDERER_CLEARIMAGE_ENABLED		// not tested
+		
+		// GPU
+//		#define X432R_DISPCAPTURE_MAINMEMORYFIFO_TEST		// not tested
+		
+		
+		//--- experimental ---
+		#define X432R_SAMPLEDVRAMDATACHECK_TEST				// temp
+		#define X432R_LAYERPOSITIONOFFSET_TEST
+		
+		#define X432R_OPENGL_FOG_ENABLED
+		#define X432R_OPENGL_CUSTOMSTENCILTEST
+		
+		#define X432R_LOWQUALITYMODE_TEST
+		#define X432R_PPL_TEST
+		
+		#define X432R_D3D_DISPLAYMETHOD_ENABLED
+		
+		
+		#if 0
+//		#define X432R_OPENGL_CUSTOMFRAMEBUFFEROPERATION_TEST
+//		#define X432R_RENDER3D_BILLBOARDCHECK_TEST
+		
+//		#define X432R_OPENGL_CUSTOMFRAMEBUFFEROPERATION_TEST2
+//		#define X432R_SOFTRAST_OPTIMIZE_TEST
+		
+		
+		//--- incomplete ---
+//		#define X432R_LAYERPOSITIONOFFSET_TEST2
+//		#define X432R_HIGHRESO_BG_OBJ_ROTSCALE_TEST
+		
+//		#define X432R_OPENGL_2PASSSHADOW_TEST
+		
+//		#define X432R_3D_REARPLANE_TEST
+		
+//		#define X432R_CPP_AMP_TEST
+		
+		
+		//--- debug ---
+//		#define X432R_SINGLECORE_TEST
+		#define X432R_PROCESSTIME_CHECK
+		#define X432R_CUSTOMRENDERER_DEBUG
+//		#define X432R_CUSTOMRENDERER_DEBUG2
+//		#define X432R_HIGHRESOLUTION_RENDERLINE_DEBUG
+		#endif
+		
+		
+		#define X432R_STATIC_RENDER_MAGNIFICATION_CHECK() \
+			static_assert( (RENDER_MAGNIFICATION >= 2) && (RENDER_MAGNIFICATION <= 4) , "X432R: invalid rendering magnification" )
+		
+		
+		bool IsHighResolutionRendererSelected();
+		bool IsSoftRasterzierSelected();
+		u32 GetCurrentRenderMagnification();
+		void ClearBuffers();
+		
+		#ifdef X432R_LOWQUALITYMODE_TEST
+		extern bool lowQualityMsaaEnabled;
+		extern bool lowQualityAlphaBlendEnabled;
+		#endif
+		
+		#ifdef X432R_PROCESSTIME_CHECK
+		class ProcessTimeCounter
+		{
+			private:
+			u32 startTime;
+			u32 totalTime;
+//			u32 execCount;
+			
+			public:
+			u32 Time;
+//			u32 Count;
+			
+			void Start();
+			void Stop();
+			void Reset(const u32 fps);
+		};
+		
+		class AutoStopTimeCounter
+		{
+			private:
+			ProcessTimeCounter &timeCounter;
+			
+			public:
+			AutoStopTimeCounter(ProcessTimeCounter& counter) : timeCounter(counter)
+			{	timeCounter.Start();		}
+			
+			~AutoStopTimeCounter()
+			{	timeCounter.Stop();			}
+		};
+		
+		extern ProcessTimeCounter timeCounter_3D;
+		extern ProcessTimeCounter timeCounter_3DFinish1;
+		extern ProcessTimeCounter timeCounter_3DFinish2;
+		extern ProcessTimeCounter timeCounter_2D;
+		extern ProcessTimeCounter timeCounter_2DHighReso;
+		#endif
+		
+		#ifdef X432R_CUSTOMRENDERER_DEBUG
+		extern bool debugModeEnabled;
+		extern bool debugModeEnabled2;
+		
+		void ShowDebugMessage(std::string message);
+		#endif
+	#endif
+	
+	
+	//--- メニュー ---
+	#ifdef X432R_MENUITEMMOD_ENABLED
+		
+		#define X432R_CUSTOMSCREENSCALING_ENABLED
+		
+		
+		extern bool showMenubarInFullScreen;
+		extern bool cpuPowerSavingEnabled;
+		
+		void HK_ToggleSoundEnabledKeyDown(int, bool);
+		void HK_FastForwardKeyUp(int);
+		void HK_FastForwardKeyDown(int, bool);
+		void HK_ToggleFastForwardKeyDown(int, bool);
+		void HK_SlowMotionKeyUp(int);
+		void HK_SlowMotionKeyDown(int, bool);
+		void HK_ToggleSlowMotionKeyDown(int, bool);
+		
+		
+		#ifdef X432R_CUSTOMSCREENSCALING_ENABLED
+		void GetScreenScales(float &mainscreen_scale, float &subscreen_scale);
+		float GetSmallScreenOffset_Horizontal();
+		float GetSmallScreenOffset_Vertical();
+		
+		void WritePrivateProfileFloat(const std::string app_name, const std::string key_name, const float value);
+		float GetPrivateProfileFloat(const std::string app_name, const std::string key_name, const float default_value);
+		float CalculateDisplayScale(const float client_width, const float client_height, const float target_width, const float target_height);
+		
+		void HK_ChangeSmallScreenSetting(int, const bool decrease_upperscreen_size);
+		void HK_SwapSmallScreenSetting(int, bool);
+		#endif
+	#endif
+}
+
+#endif
+
+
+
